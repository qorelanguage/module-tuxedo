<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<script type="text/javascript">
/* <![CDATA[ */

/* DFQRCTsKlU-0000471-START */

var woas = {"version": "0.9.7B"};

var __marker = "DFQRCTsKlU-0000471";

woas["config"] = {
"permit_edits":true,
"dblclick_edit":false,
"save_on_quit":false,
"open_last_page":true,
"allow_diff":true,
"key_cache":true,
"cumulative_save":false,
"auto_save":0};

var current = 'TuxedoAdapter::receiveConversationData()';

var main_page = 'Tuxedo Integration into Qore';

var backstack = [
'Tuxedo Integration into Qore',
'High Level Layer',
'TuxedoAdapter',
'TuxedoAdapter::constructor()',
'High Level Layer',
'TuxedoAdapter'
];

var page_titles = [
'Main Page',
'::Menu',
'WoaS::Bootscript',
'WoaS::Aliases',
'Special::About',
'Special::Advanced',
'Special::Options',
'Special::Import',
'Special::Lock',
'Special::Search',
'Special::Security',
'Special::Embed',
'Special::Export',
'Special::License',
'Tuxedo Integration into Qore',
'Low Level Layer',
'Constants',
'tpchkauth()',
'tperrordetail()',
'TuxedoUserlog()',
'TuxedoQueueCtl',
'TuxedoTransactionId',
'TuxedoTypedBuffer',
'tpinit()',
'tpterm()',
'tptypes()',
'tpcall()',
'tpacall()',
'tpcancel()',
'tpgetrply()',
'tpdiscon()',
'tpabort()',
'tpbegin()',
'tpcommit()',
'tpopen()',
'tpclose()',
'tpconnect()',
'tpsend()',
'tprecv()',
'tpenqueue()',
'tpdequeue()',
'tpsprio()',
'tpgprio()',
'tpsuspend()',
'tpresume()',
'tpscmt()',
'tpgetlev()',
'tpstrerror()',
'tppost()',
'tx_begin()',
'tx_close()',
'tx_open()',
'tx_commit()',
'tx_rollback()',
'FML/FML32 support',
'processFMLDescriptionTables()',
'processFML32DescriptionTables()',
'High Level Layer',
'putFMLInTypedBuffer()',
'putFML32InTypedBuffer()',
'getFMLFromTypedBuffer()',
'getFML32FromTypedBuffer()',
'TuxedoContext',
'tpgetctxt()',
'tpsetctxt()',
'tx_set_commit_return()',
'tx_set_transaction_control()',
'tx_set_transaction_timeout()',
'tpxmltofml()',
'tpxmltofml32()',
'tpfmltoxml()',
'tpfml32toxml()',
'fmltofml32()',
'fml32tofml()',
'tpinitParams()',
'WoaS::Aliases',
'TuxedoAdapter',
'TuxedoAdapter::constructor()',
'TuxedoAdapter::destructor()',
'TuxedoAdapter::constructor() Hash',
'TuxedoAdapter::copy()',
'TuxedoAdapter::call()',
'TuxedoAdapter::asyncCall()',
'TuxedoAdapter::waitForAsyncReply()',
'TuxedoAdapter::cancelAsyncCall()',
'TuxedoAdapter::enqueue()',
'TuxedoAdapter::dequeue()',
'TuxedoAdapter::joinConversation()',
'TuxedoAdapter::breakConversation()',
'TuxedoAdapter::sendConversationData()',
'TuxedoAdapter::receiveConversationData()'
];

/* DFQRCTsKlU-0000471-DATA */
var page_attrs = [0,0,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];

var pages = [
'This is your empty main page',
'*[[Tuxedo Integration into Qore|Tuxedo Integration]]*\n\
---\n\
*[[High Level Layer|High level]]*\n\
---\n\
*[[Low Level Layer|Low level]]*\n\
[[Constants]]\n\
Misc functions\n\
* [[tpchkauth()]]\n\
\n\
* [[tpinit()]]\n\
* [[tpinitParams()]]\n\
* [[tpterm()]]\n\
* [[TuxedoTypedBuffer]]\n\
\n\
* [[tpgprio()]]\n\
* [[tpsprio()]]\n\
\n\
* [[tperrordetail()]]\n\
* [[tpstrerror()]]\n\
* [[TuxedoUserlog()]]\n\
---\n\
Request/response\n\
* [[tpcall()]]\n\
\n\
* [[tpacall()]]\n\
* [[tpgetrply()]]\n\
* [[tpcancel()]]\n\
---\n\
Queues\n\
* [[tpdequeue()]]\n\
* [[tpenqueue()]]\n\
* [[TuxedoQueueCtl]]\n\
---\n\
Conversational mode\n\
* [[tpconnect()]]\n\
* [[tprecv()]]\n\
* [[tpsend()]]\n\
* [[tpdiscon()]]\n\
---\n\
Event handling\n\
* [[tppost()]]\n\
---\n\
Resource manager\n\
* [[tpopen()]]\n\
* [[tpclose()]]\n\
* [[tx_open()]]\n\
* [[tx_close()]]\n\
---\n\
Transactions\n\
* [[tpbegin()]]\n\
* [[tpcommit()]]\n\
* [[tpabort()]]\n\
\n\
* [[tpsuspend()]]\n\
* [[tpresume()]]\n\
* [[TuxedoTransactionId]] \n\
\n\
* [[tpgetlev()]]\n\
* [[tpscmt()]]\n\
\n\
* [[tx_begin()]]\n\
* [[tx_commit()]]\n\
* [[tx_rollback()]]\n\
\n\
* [[tx_set_commit_return()]]\n\
* [[tx_set_transaction_control()]]\n\
* [[tx_set_transaction_timeout()]]\n\
---\n\
Context handling\n\
* [[tpgetctxt()]]\n\
* [[tpsetctxt()]]\n\
* [[TuxedoContext]]\n\
---\n\
*[[FML/FML32 support]]*\n\
* [[processFMLDescriptionTables()]] \n\
* [[processFML32DescriptionTables()]] \n\
\n\
* [[putFMLInTypedBuffer()]] \n\
* [[putFML32InTypedBuffer()]]\n\
* [[getFMLFromTypedBuffer()]] \n\
* [[getFML32FromTypedBuffer()]]\n\
\n\
* [[tpxmltofml()]]\n\
* [[tpxmltofml32()]]\n\
* [[tpfmltoxml()]]\n\
* [[tpfml32toxml()]]\n\
\n\
* [[fmltofml32()]]\n\
* [[fml32tofml()]]\n\
---\n\
',
'LyogaW5zZXJ0IGhlcmUgeW91ciBib290IHNjcmlwdCAqLw==',
'',
'[[Special::TOC]]\n\
= Welcome to Wiki on a Stick!\n\
Wiki on a Stick (in short *WoaS*) is a [[http://en.wikipedia.org/wiki/Wiki|wiki]] that lives in *one self-modifying XHTML file*. It\'s perfect to be used at home or at office, on your laptop or USB pen drive (along with [[http://portableapps.com/apps/internet/browsers/portable_firefox|Portable Firefox]] if you want) and even in a floppy disk! It can be used as a personal notepad, calendar, repository for software documentation and many other things; it allows full customization and extension by your own scripts or libraries. It also offers [[Special::Security|true AES encryption]] of pages.\n\
\n\
== Where to download\n\
Wiki on a Stick can always be downloaded through the official SF.net WoaS project file download service:\n\
\x3Cdiv style="text-align:center"\x3E\n\
\x3Cbig\x3E[[http://sourceforge.net/project/showfiles.php?group_id=155218|Download Wiki on a Stick]]\x3C/big\x3E\x3C/div\x3E\n\
\n\
== Where to get support\n\
\n\
You can use the [[http://woas.iragan.com/|official WoaS forums]] and/or the [[http://sf.net/projects/stickwiki/|SF.net WoaS project facilities]].\n\
\n\
== Version\n\
\n\
Current version is *v0.9.7B*\n\
Versions 0.9&tilde;0.9.7 by Daniele C. ([[http://sf.net/users/legolas558/|legolas558]])\n\
Original version (v0.01 &tilde; v0.04) by Andr\u00e9 Wagner\n\
\n\
\x3Ccenter\x3E\x3Cbig\x3E[[Special::License|Wiki on a Stick is licensed under the GNU/GPL license]].\x3C/big\x3E\x3C/center\x3E\n\
\n\
== Thanks to\n\
This project wouldn\'t be what it is without the help of other people. If you contributed to Wiki on a Stick and your name is not here (or if you do not want it to be listed here), please send an email to \x3Ca class="world" href="mailto:legolas558 _AT_ users.sourceforge.net"\x3Ethis email address\x3C/a\x3E.\n\
\n\
* *Jeremy Ruston* - the creator of the wonderful [[http://www.tiddlywiki.com/|TiddlyWiki]], who served as inspiration for Wiki on a Stick. He also kindly allowed the usage of his saving/loading routines.\n\
* *Philip O\'Donnel* - creator of the table syntax & parsing code\n\
* *Tim Lord*\n\
* *Knut Kohl*\n\
* *Rob Schmersel*\n\
* *Michiel van Everdingen* - [[http://home.versatel.nl/MAvanEverdingen/Code/|original javascript implementation]] of AES encryption\n\
* *Cyril Mazard* - search feature\n\
* *jimmac* - author of [[http://jimmac.musichall.cz/i.php?i=gorilla-stock|the icons set]] which we are currently using in WoaS\n\
* *martinellison* - transclusion patch\n\
\n\
And, last but not least:\n\
* [[http://groups.google.com/group/stickwiki/|the StickWiki google group]] users for their support, advices and testing which has pushed WoaS development up to the current status.\n\
\n\
== Important links\n\
* [[http://sf.net/projects/stickwiki/|SourceForge project home page]] - useful for contributing\n\
* [[http://woas.iragan.com/|Official WoaS forums]] - our discussion forums where you can also partecipate to the decision processes\n\
* [[http://sourceforge.net/tracker/?group_id=155218&atid=794925|SF.net WoaS project bug tracker]] - if you find a bug, post it here\n\
* [[http://sourceforge.net/tracker/?group_id=155218&atid=794928|SF.net WoaS project feature tracker]] - if you have have suggestions for improvements\n\
* [[http://woas.iragan.com/cgi-bin/wiki/|Official WoaS Documentation Wiki]] - under construction\n\
* [[http://groups.google.com/group/stickwiki/|Official WoaS Google Group]] - for public anonymous discussion (mailing list)',
'== Options\n\
You can customize Wiki on a Stick modifying a few [[Special::Options|Options]].  \n\
\n\
== Pages\n\
* [[Special::All Pages]]: a list of all user created pages in this wiki\n\
* [[Locked::]], [[Unlocked::]]: an index of all encrypted/plain pages\n\
* [[Tagged::]], [[Untagged::]]: an index of all tagged/untagged pages\n\
* [[Special::Search]]: search all wiki pages\n\
\n\
== Maintenance\n\
* [[Special::Dead Pages]]: a list of pages that have links to them, but were still not created \n\
* [[Special::Orphaned Pages]]: a list of pages that once were linked to, but now no page links to them anymore\n\
* [[Special::Export]] wiki into multiple linked static XHTML files\n\
* [[Special::Import]] wiki or theme from an early (or current) version\n\
* [[Special::Erase Wiki]]: delete ALL wiki pages and reset with default data\n\
\n\
== Advanced features\n\
* [[Special::Edit CSS]]: edit the global CSS styles\n\
* [[Special::Edit Bootscript]]: edit the custom script run once when WoaS is being loaded\n\
\n\
== Info\n\
This wiki was last modified in \x3Cspan id="lastDate"\x3E\x3C/span\x3E\n\
\x3Cscript\x3E$("lastDate").innerHTML = document.lastModified;\x3C/script\x3E',
'= Options\n\
\n\
\x3Clabel for="cb_allow_diff"\x3E\x3Cinput type="checkbox" id="cb_allow_diff" onclick="woas.config.allow_diff = $.checked(\'cb_allow_diff\')" /\x3EUse consistent newlines in saved data\x3Cbr /\x3E\n\
\x3Clabel for="cb_dblclick_edit"\x3E\x3Cinput type="checkbox" id="cb_dblclick_edit" onclick="woas.config.dblclick_edit = $.checked(\'cb_dblclick_edit\')" /\x3EDouble click to edit pages/menu\x3Cbr /\x3E\n\
\x3Clabel for="cb_save_on_quit"\x3E\x3Cinput type="checkbox" id="cb_save_on_quit" onclick="woas.config.save_on_quit = $.checked(\'cb_save_on_quit\')" /\x3EAutomatically save options (if changed) before quitting\x3Cbr /\x3E\n\
\x3Clabel for="cb_key_cache"\x3E\x3Cinput type="checkbox" id="cb_key_cache" onclick="woas.config.key_cache = !$.checked(\'cb_key_cache\')" /\x3EDo not temporarily cache the AES key\x3Cbr /\x3E\n\
\x3Clabel for="cb_fixed_layout"\x3E\x3Cinput type="checkbox" id="cb_fixed_layout" onclick="_set_layout($.checked(\'cb_fixed_layout\'))" /\x3EFixed menu area and topbar\x3Cbr /\x3E\n\
\x3Clabel for="cb_open_last_page"\x3E\x3Cinput type="checkbox" id="cb_open_last_page" onclick="woas.config.open_last_page = $.checked(\'cb_open_last_page\')" /\x3ESave last page visited when quitting\x3Cbr /\x3E\n\
\x3Clabel for="cb_cumulative_save"\x3E\x3Cinput type="checkbox" id="cb_cumulative_save" onclick="woas.config.cumulative_save = $.checked(\'cb_cumulative_save\')" /\x3EEnable cumulative save (will save to disk only when quitting)\x3Cbr /\x3E\n\
\x3Cp\x3E\x3Cinput type="button" onclick="ro_woas()" value="Disallow edits" /\x3E\x3C/p\x3E\n\
\x3Cp\x3E\x3Cinput type="button" onclick="save_options()" value="Save options" /\x3E\x3C/p\x3E\n\
\n\
\x3Cscript\x3E\n\
$("cb_allow_diff").checked = bool2chk(woas.config.allow_diff);\n\
$("cb_open_last_page").checked = bool2chk(woas.config.open_last_page);\n\
$("cb_key_cache").checked = bool2chk(!woas.config.key_cache);\n\
$("cb_dblclick_edit").checked = bool2chk(woas.config.dblclick_edit);\n\
$("cb_save_on_quit").checked = bool2chk(woas.config.save_on_quit);\n\
$("cb_cumulative_save").checked = bool2chk(woas.config.cumulative_save);\n\
$("cb_fixed_layout").checked = ($("sw_wiki_header").style.position == "fixed");\n\
if (ie6) $("cb_fixed_layout").disabled = true;\n\
\x3C/script\x3E',
'Import a wiki from an early (or current) version:\n\
\n\
File: \x3Cinput id="filename_" type="file" /\x3E&nbsp;\x3Cinput type="button" value="Import" onclick="import_wiki()" /\x3E\n\
\n\
\x3Clabel for="cb_import_content"\x3E\x3Cinput type="checkbox" id="cb_import_content" checked="checked"\x3E&nbsp;import the wiki pages\x3C/label\x3E\n\
\x3Clabel for="cb_import_css"\x3E\x3Cinput type="checkbox" id="cb_import_css" checked="checked"\x3E&nbsp;import also CSS (available only for versions v0.9 and above)\x3C/label\x3E\n\
\x3Clabel for="cb_import_icons"\x3E\x3Cinput type="checkbox" id="cb_import_icons" disabled="disabled"\x3E&nbsp;import the icons theme (available since v0.9.5B)\x3C/label\x3E\n\
',
'== AES encryption\n\
Read more about the [[Special::Security|embedded AES encryption]] used in Wiki On a Stick.\n\
\n\
== Password\n\
Enter your password for AES encryption. The more complex your password is, the more difficult it will be to attack the encryption. It is suggested *not* to use passwords whose textbox color is \x3Cspan style="background-color:red"\x3E&nbsp;red&nbsp;\x3C/span\x3E, and to accept passwords only when the textbox color is \x3Cspan style="background-color:lime"\x3E&nbsp;green&nbsp;\x3C/span\x3E. Punctuation and Mixed case characters will exponentially increase the strength of your password.\n\
\n\
 \x3Cinput type="password" id="pw1" style="background-color:red" value="" size="50" onfocus="custom_focus(true)" onblur="custom_focus(false)" onkeyup="pw_quality()" /\x3E&nbsp;\x3Cspan id="txtBits"\x3E&nbsp;\x3C/span\x3E\n\
 \x3Cinput type="password" id="pw2" value="" size="50" onfocus="custom_focus(true)" onblur="custom_focus(false)" /\x3E\n\
 \x3Cinput id="btn_lock" type="button" value="" /\x3E\n\
\n\
\x3Cscript\x3E\n\
function _lock_page() {\n\
if (current.indexOf("Lock::")!=0) return;\n\
var page = current.substring(6);\n\
\n\
$("btn_lock").value = "Lock "+page;\n\
$("pw1").focus();\n\
$("btn_lock").setAttribute("onclick", "lock_page(\'"+woas.js_encode(page)+"\')");\n\
}\n\
_lock_page();\n\
\x3C/script\x3E',
'= Search in Wiki\n\
\n\
\x3Cinput id="string_to_search" type="text" onfocus="search_focus(true)" onblur="search_focus(false)" /\x3E&nbsp;\x3Cinput type="button" value="Search" onclick="do_search()" /\x3E&nbsp;\x3Cinput type="button" value="Clear" onclick="clear_search()" /\x3E\n\
\n\
\x3Cscript\x3E\n\
var tmp = $(\'wiki_text\');\n\
var pre = \'\x3Cpre class="wiki_preformatted"\x3E\';\n\
var hl_text = cached_search.replace(/\x3Cdiv class="search_results"\x3E((.|\\n)*?)\x3C\\/div\x3E/g,\n\
function (str, ct) {\n\
    return \'\x3Cdiv class="search_results"\x3E\'+pre+ct.substr(pre.length).replace(_hl_reg, \'\x3Cspan class="search_highlight"\x3E$1\x3C/span\x3E\')+\'\x3C/div\x3E\';\n\
});\n\
\n\
tmp.innerHTML = tmp.innerHTML + hl_text;\n\
\n\
hl_text = null;\n\
//_hl_reg = null;\n\
// $("string_to_search").focus();\n\
\x3C/script\x3E',
'== AES encryption\n\
Since Wiki on a Stick v0.9 the [[http://en.wikipedia.org/wiki/Advanced_Encryption_Standard|AES]] 256-bit high security data encryption standard is supported to protect a single page or groups of them.\n\
\n\
The first password you enter after having started Wiki on a Stick gets cached (unless you have specified not to do it) and you will no more be asked for it. Further encryptions and decryptions will always use the last password entered; such password is not anyway stored in your saved files (true AES encryption is used).\n\
\n\
\x3Ccenter\x3E*If you forget the password there is no way to retrieve it or your data.*\x3C/center\x3E\n\
\n\
== How do I encrypt a page?\n\
In order to encrypt a page you will have to click on the /lock/ icon on the top-right navigation panel; if your page is already encrypted and you want to change the encryption key you will first have to unlock it.\n\
\n\
== Security level\n\
Security is never absolute. Data encrypted with these pages might be compromised in a variety of ways, including but not limited to the following:\n\
\n\
* You have not disabled the AES key cache, so when you will enter the password for the first time other users (if not you) will be able to see encrypted pages and could possibly get your key\n\
* Your Web browser and/or JavaScript interpreter may contain bugs or deliberate security violations which report activity on your computer back to some other Internet site\n\
* Some other applet running on another page in your browser, perhaps without you being aware of its existence, is spying on other windows\n\
* Some other "spyware" application running on your computer may have compromised your system\'s security and be snooping on your activity\n\
* The implementation of the encryption may contain a bug which makes its results insecure, Wiki on a Stick is open-source, you can judge for yourself whether the tool merits your confidence.\n\
* Your computer\'s security may have been compromised physically; when\'s the last time you checked that a bug that transmits your keystrokes and/or screen contents to that white van parked down the street wasn\'t lurking inside your computer cabinet?\n\
\n\
Apart from the above, your normal usage of encrypted pages can be considered secure.',
'= Embed %1\n\
\n\
\x3Cinput id="filename_" type="file" /\x3E&nbsp;\x3Cinput type="button" value="Embed" onclick="woas._embed_process(\'%1\')" /\x3E\n\
',
'= Export content into XHTML files\n\
\n\
==Paths\n\
Specify the destination folder which will contain all the exported XHTML files. *The folder must exist*\n\
\n\
\x3Cinput id="woas_ep_xhtml" type="text" size="80" /\x3E\n\
\n\
Specify the destination folder which will contain all the exported embedded pictures. *The folder must exist*\n\
\n\
\x3Cinput id="woas_ep_img" type="text" size="80" /\x3E\n\
\n\
==File naming\n\
\n\
Default extension for generated XHTML files\n\
\n\
\x3Cinput id="woas_ep_ext" type="text" size="8" value="htm" /\x3E\n\
\n\
\x3Clabel for="woas_cb_index_main"\x3E\x3Cinput type="checkbox" id="woas_cb_index_main" checked="checked"\x3EThe main page will be named index.htm\x3C/label\x3E\n\
\x3Clabel for="woas_cb_unix_norm"\x3E\x3Cinput type="checkbox" id="woas_cb_unix_norm" checked="checked"\x3EApply UNIX-style normalization (lowercase and spaces replaced by underscores) to generated filenames\x3C/label\x3E\n\
\n\
==Custom JavaScripts\n\
\x3Clabel for="woas_cb_js_ign"\x3E\x3Cinput type="radio" id="woas_cb_js_ign" name="woas_cb_js" checked="checked"\x3EDo not export\x3C/label\x3E\n\
\x3Clabel for="woas_cb_js_dyn"\x3E\x3Cinput type="radio" id="woas_cb_js_dyn" name="woas_cb_js"\x3ERun before exporting but do not export the javascript\x3C/label\x3E\n\
\x3Clabel for="woas_cb_js_exp"\x3E\x3Cinput type="radio" id="woas_cb_js_exp" name="woas_cb_js"\x3EExport javascript as is (you might need to include the framework code)\x3C/label\x3E\n\
\x3Clabel for="woas_cb_js_head"\x3E\x3Cinput type="radio" id="woas_cb_js_head" name="woas_cb_js" disabled="disabled"\x3EExport javascript into &lt;head /&gt; (you might need to include the framework code)\x3C/label\x3E\n\
\n\
\x3Clabel for="woas_cb_js_fw"\x3E\x3Cinput type="checkbox" id="woas_cb_js_fw" disabled="disabled"\x3EExport the javascript framework too\x3C/label\x3E\n\
\n\
==Other options\n\
META author (optional)\n\
\n\
\x3Cinput id="woas_ep_author" type="text" size="12" value="" /\x3E\n\
\n\
\x3Clabel for="woas_cb_sep_css"\x3E\x3Cinput type="checkbox" id="woas_cb_sep_css" checked="checked"\x3EExport CSS into shared file\x3C/label\x3E\n\
\x3Clabel for="woas_cb_wif" style="color:gray"\x3E\x3Cinput type="checkbox" id="woas_cb_wif" disabled="disabled"\x3EExport as WIF ([[http://www.wikisym.org/wiki/index.php/WSR_3|Wiki Interchange Format]])\x3C/label\x3E\n\
\x3Clabel for="woas_cb_export_menu"\x3E\x3Cinput type="checkbox" id="woas_cb_export_menu" checked="checked"\x3EExport menu and submenus\x3C/label\x3E\n\
\n\
\x3Cinput type="button" value="Export XHTML" onclick="woas.export_wiki()" /\x3E\n\
\n\
\x3Cscript\x3E\n\
var path = _get_this_path();\n\
path += "export" + path[path.length-1];\n\
$(\'woas_ep_xhtml\').value = path;\n\
$(\'woas_ep_img\').value = path;\n\
\n\
function _ep_focus() { search_focused = true; }\n\
function _ep_blur() { search_focused = false; }\n\
\n\
$(\'woas_ep_xhtml\').onfocus = $(\'woas_ep_img\').onfocus = $(\'woas_ep_ext\').onfocus = _ep_focus;\n\
$(\'woas_ep_xhtml\').onblur = $(\'woas_ep_img\').onblur = $(\'woas_ep_ext\').onblur = _ep_blur;\n\
\n\
\x3C/script\x3E',
'= Special::License\n\
\n\
Retrieved from [[http://www.gnu.org/licenses/gpl2.txt]]:\n\
\n\
\x3Ciframe border="0" width="100%" height="300" src="http://www.gnu.org/licenses/gpl2.txt"\x3E\x3C/iframe\x3E',
'*Tuxedo* is a middleware currently marketed by Bea. Complete online documentation is on [[http://edocs.bea.com/tuxedo/tux91/index.htm]]. For the integration Tuxedo version 9.1 (on Linux) has been used but older version was reported as working as well. Qore version used for the development was 0.5.2 and up.\n\
\n\
\n\
[[Low Level Layer|Low level]] layer and [[High Level Layer|high level]] (using the low level) are provided. The high level is recommended, the low level should be used for tasks not covered by the higher level layer. It is possible to use both levels at the same time.\n\
\n\
Copyright (c) Qore Technologies, 2006\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'Low level layer provides as much access to Tuxedo as possible. C API (called ATMI) is wrapped by standalone Qore functions (plus couple of small Qore classes). The ATMI documentation is on [[http://edocs.bea.com/tuxedo/tux91/rf3c/index.htm]].\n\
\n\
\n\
Tuxedo errors are passed to the caller as erroc codes, user errors (like wrong number of type of parameters) result in exception.\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
%requires Tuxedo\n\
\n\
#&nbsp;failure to connect to the Tuxedo server will result in error code\n\
$res = tpinit();\n\
\n\
#&nbsp;this will throw since no parameter is expected\n\
$res = tpinit(100);\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'All symbolic constants (as /TPSENDONLY/) used by C API are available in Qore in /Tuxedo/ namespace as a part of [[Low Level Layer|low level layer]]. Their complete list could be found in file \x3Ci\x3Emodules/Tuxedo/low_level_api.cc\x3C/i\x3E, at the bottom.\n\
\n\
If some constant is missing or misspelled please use the correct numeric value instead. All constants could be found in file \x3Ci\x3E$TUXDIR/include/atmi.h\x3C/i\x3E.\n\
\n\
FML and FML32 constants are *not* exported into Qore.\n\
\n\
*Example:*\n\
\x3Ctt\x3E\n\
%requires Tuxedo\n\
$flags = Tuxedo::TPNOTRAN;\n\
\x3C/tt\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'Check what kind of authentication is required. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c28.htm#1040017]].\n\
\n\
The function provides information what kind of authentification is needed to connect Tuxedo server. If used it should be first one from low level interafce to be called. The function is multithread safe. \n\
\n\
*Parameters:*\n\
# optional: hash (string to string) with environment variables to be set during Tuxedo tpchkauth() call. Values from the hash (if present) have priority over environment variables. \n\
\n\
* These hash items are recognized as equivalent of environment variables:\n\
** /TUXDIR/ (mandatory in hash or as env. variable). Example: \x3Ci\x3E///opt/bea/tuxedo91\x3C/i\x3E\n\
** /TUXCONFIG/ (mandatory or as env. variable). Example: \x3Ci\x3E///home/joe/tuxedo_test/tuxconfig\x3C/i\x3E\n\
** /WSENVFILE, WSNADDR, WSFADDR, WSFRANGE, WSDEVICE, WSTYPE, WSRPLYMAX, TMMINENCRYPTBITS, TMMAXENCRYPTBITS, TMNOTHREADS/ (likely not needed for tpchkauth())\n\
 \n\
*Returns:*\n\
* on failure list with single element, nonzero integer error code\n\
* on success listr with two elements: zero and then one if \n\
** Tuxedo::TPNOAUTH (no authentication needed) \n\
** Tuxedo::TPSYSAUTH (system authentication)  \n\
** Tuxedo::TPAPPAUTH (both system and application authentication)\n\
\n\
*Example 1:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpchkauth()|tpchkauth]]();\n\
\n\
if ($res[0] == 0) {\n\
  printf("Required authentication is %d\\n", $res[1]);\n\
} else {\n\
  printf("Error %d\\n", $res[0]);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 2:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$connection_params = ( \n\
  "TUXDIR" : "/opt/bea/tuxedo91", \n\
  "TUXCONFIG" : "/home/joe/tuxedo_test/tuxconfig"\n\
  );\n\
\n\
$res = [[tpchkauth()|tpchkauth]]($connection_params);\n\
\n\
... handle $res as in previous example\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*Notes:*\n\
* [[tpchkauth()]] requires the same environment variables (like /$TUXDIR/ and /$TUXCONFIG/) set as [[tpinit()]] and [[tpinitParams()]] to provide correct result. If parameters hash is used it should be the same.\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'Get more detailed information about the error from last Tuxedo call. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c40.htm#1021798]].\n\
\n\
*Parameters:*\n\
* none\n\
*Returns:*\n\
* detail error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = tprecv(...);\n\
\n\
if ($res != 0) {\n\
  $detail = tperrordetail();\n\
  printf("Error %d, detail %d\\n", $res, $detail);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Call this function immediatelly after Tuxedo failure. If you call any other Tuxedo function in between the old error code will be lost.\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'Write text message into central Tuxedo error log. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c110.htm#1049646]].\n\
\n\
*Parameters:*\n\
# text to be written, string\n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[TuxedoUserlog()|TuxedoUserlog]]("some text");\n\
\n\
if ($res == 0) {\n\
  printf("Logged OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Several environment variables influence behaviour of the /userlog()/ ATMI function. See Tuxedo documentation for details.\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E',
'The Qore class used to wrap C structure /TPQCTL/ (see \x3Ci\x3E$TUXDIR/include/atmi.h\x3C/i\x3E). The class is written in C++ and exposed into Qore, it is part of [[Low Level Layer|low level]] layer\n\
\n\
/TPQCTL/ is used to control behaviour of ATMI functions /tpenqueue()/ and /tpdequeue()/. The [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]] class does the same for Qore functions [[tpenqueue()]] and [[tpdequeue()]]. These functions read or write different fields of the structure. The Qore class provides getter and setter for every field.\n\
\n\
*Member functions:*\n\
* constructor with no parameters\n\
* getters and setters (see Tuxedo documentation and the header what the fields mean):\n\
* getFlags(), setFlags() - integer\n\
* getDeqTime(). setDeqTime() - integer\n\
* getPriority(), setPriority() - integer\n\
* getDiagnostic(), setDiagnostic() - integer\n\
* getExpTime(), setExpTime() - integer\n\
* getReplyQOS(), setReplyQOS() - integer\n\
* getDeliveryQOS(), setDeliveryQOS() - integer\n\
* getAppkey(), setAppkey() - integer \n\
* getUrcode(), setUrcode() - integer\n\
* getClientID(), setClientId() - binary, see the header for definition\n\
* getReplyQueue(), setReplyQueue() - string\n\
* getFailureQueue(), setFailureQueue() - string\n\
* getMsgId(), setMsgId() - binary, see the header for definition\n\
* getCorrId(), setCorrId() - binary, see the header for definition\n\
\n\
*Example 1:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$queue_ctl = new [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]]();\n\
$queue_ctl.setFlags(Tuxedo::TPQPRIORITY);\n\
$queue_ctl.setPriority(80);\n\
\n\
$data =  ... get instance of [[TuxedoTypedBuffer]] with data\n\
\n\
#The $queue_ctl must be passed by reference\n\
$res = [[tpenqueue()|tpenqueue]]("a queue space", "a queue name", \\$queue_ctl, \\$some_data, Tuxedo::TPNOTRAN);\n\
\n\
if ($res != 0) { \n\
   printf("Error %d\\n", $res); \n\
   if ($res == Tuxedo::TPEDIAGNOSTIC) {\n\
     $reason = $queue_ctl.getDiagnostic();\n\
     printf("Detailed error diagnostic = %d\\n", $reason);\n\
   }\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 2:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#It is possible to use the object as created\n\
$queue_ctl = new [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]]();\n\
$res = [[tpenqueue()|tpenqueue]]("a queue space", "a queue name", \\$queue_ctl, \\$data, 0);\n\
\n\
if ($res != 0) { ... }\n\
\n\
$queue_ctl = new Tuxedo::TuxedoQueueCtl();\n\
$res = [[tpdequeue()|tpdequeue]]("a queue space", "a queue name", \\$queue_ctl, \\$out_data, 0);\n\
\n\
if ($res != 0) { ... }\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 3:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$queue_ctl = new [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]]();\n\
$queue_ctl.setFlags(Tuxedo::TPQWAIT);\n\
\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
$res = [[tpalloc()|tpalloc]]("STRING", "", 100, \\$data);\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
#The $queue_ctl and $data must be passed by reference\n\
$res = [[tpdequeue()|tpdequeue]]("a queue space", "a queue name", \\$queue_ctl, \\$data, 0);\n\
\n\
if ($res != 0) { \n\
  printf("Error %d\\n", $res);\n\
} else {\n\
  $flags = $queue_ctl.getFlags();\n\
  if ($flags  & Tuxedo::TPQDELIVERYQOS) {\n\
    printf("Delivery quality of service was %d\\n", $queue_ctl.getDeliveryQOS());\n\
  }\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*See also:*\n\
* Overview of queuing in Tuxedo: [[http://edocs.bea.com/tuxedo/tux91/qgd/qpgm.htm]]\n\
* Tuxedo tpenqueue() documentation: [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c38.htm#1042179]]\n\
* Tuxedo tpdequeue() documentation: [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c36.htm#1041783]]\n\
* [[tpenqueue()]] and [[tpdequeue()]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-15./\x3C/small\x3E\n\
',
'The Qore class used to wrap C structure /TPTRANID/ (see \x3Ci\x3E$TUXDIR/include/atmi.h\x3C/i\x3E). The class is written in C++ and exposed into Qore as a part of [[Low Level Layer|low level]] layer.\n\
\n\
/TPTRANID/ is used by ATMI functions /tpsuspend/ and /tpresume/ (Tuxedo transactions API). The [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]] class does the same for Qore functionn [[tpsuspend()]] and [[tpresume()]]. Only constructor is provided and no getters or setters.\n\
\n\
*Member functions:*\n\
* constructor with no parameters\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$tranid = new [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]]();\n\
\n\
#suspend current transaction\n\
$res = [[tpsuspend()|tpsuspend]](\\$tranid, 0);  #must be passed by reference\n\
\n\
if ($res != 0) { printf("Error %d\\n", $res); ... }\n\
\n\
...\n\
\n\
#resume current transaction\n\
$res = [[tpresume()|tpresume]](\\$tranid, 0); #must be the object previously passed into tpsuspend()\n\
\n\
if ($res != 0) { printf("Error %d\\n", $res); ... }\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*See also:*\n\
* Tuxedo tpsuspend() documentation: [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c81.htm#1045633]]\n\
* Tuxedo tpresume() documentation: [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c65.htm#1044625]]\n\
* [[tpsuspend()]] and [[tpresume()]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18/\x3C/small\x3E',
'The Qore class used to deal with Tuxedo typed buffers. The class is written in C++ and exposed into Qore as a part of [[Low Level Layer|low level]] layer. For overview of typed buffers manipulation see [[http://edocs.bea.com/tuxedo/tux91/pgc/pgbuf.htm]].\n\
\n\
The class keeps allocated buffer and always frees it in the destructor. In is possible to write or read different data types from/to the typed buffer.\n\
\n\
!*Member functions:*\n\
* constructor with no parameters. The buffer is in "unallocated" state after construction.\n\
---\n\
* /alloc(type, subtype, size)/ - allocates memory block using ATMI call /tpalloc()/. More on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c23.htm#1021676]]. Any previously allocated memory is freed. \n\
* Parameters:\n\
## type (string). See Tuxedo documentation for allowed names. Examples: "STRING", "CARRAY", "FML32".\n\
## subtype (string). Usually empty string (equal to NULL).\n\
## size (integer). Size of the allocated memory block in bytes. See Tuxedo documentation for minimal requirements for individual types (use 4096 to fit all standard requirements).\n\
* Returns: 0 on success, otherwise error code.\n\
\n\
Example: \x3Ccode\x3E\x3Cpre\x3E\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = $data.alloc("STRING", "", 100);\n\
if ($res != 0) { .. handle error }\n\
\x3C/pre\x3E\x3C/code\x3E\n\
---\n\
* /realloc(new_size)/ - reallocates existing memory buffer using ATMI /realloc()/. More on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c63.htm#1044439]].\n\
* Parameters:\n\
## new size, integer\n\
* Returns: 0 on success, otherwise error code.\n\
\n\
Example: \x3Ccode\x3E\x3Cpre\x3E\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = $data.alloc("STRING", "", 100);\n\
if ($res != 0) { .. handle error }\n\
$res = $data.realloc(700);\n\
if ($res != 0) { .. handle error }\n\
\x3C/pre\x3E\x3C/code\x3E\n\
---\n\
* /types()/ - return information about memory buffer using ATMI /tptypes()/. More on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c87.htm#1045809]].\n\
* Parameters: none.\n\
* Returns: \n\
** on success a list with 4 items: zero, string type, string subtype, buffer size (integer)\n\
** on failure a list with 1 item: nonzero error code.\n\
\n\
Example: \x3Ccode\x3E\x3Cpre\x3E\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = $data.alloc("STRING", "", 100);\n\
if ($res[0] != 0) { .. handle error }\n\
$res = $data.types();\n\
if ($res != 0) { .. handle error }\n\
else printf("type = %s, subtype = %s, size = %d\\n", $res[1], $res[2], $res[3]);\n\
\x3C/pre\x3E\x3C/code\x3E\n\
---\n\
* /clear()/ - frees internally allocated typed buffer, if any. The buffer is then left in "unallocated" state. Could be used as a local optimization. \n\
* Parameters: no.\n\
* Returns nothing.\n\
* Example: \x3Ccode\x3E$data.clear() #destroy memory block kept inside\x3C/code\x3E\n\
---\n\
* /setStringEncoding()/ - all strings inserted into the buffer or retrieved from the buffer are converted into given encoding (including FML/FML32 strings). The default encoding is UTF-8 (/QCS_DEFAULT/). \n\
* Parameters:\n\
##  name of the encoding as a string. E.g. "UTF-8". See lib/charset.cc for all the names\n\
* Returns: nothing.\n\
* Notes: could be called repeatedly.\n\
* Example: \x3Ccode\x3E$data.setStringEncoding("ISO-8859-1"); #Western Europe encoding\x3C/code\x3E\n\
---\n\
* /setBinary(binary [, type, [subtype] ])/ - inserts data from Qore binary into the typed buffer. Previous data, if any, will be freed.\n\
* Parameters:\n\
## instance of Qore binary object, preferably passed by reference\n\
## optional type  for the buffer. Default value is "CARRAY" (character array). See Tuxedo documentation for allowed names.\n\
## optional subtype for the buffer. Default value is NULL.\n\
* Returns: nothing.\n\
* Notes: this call could be used to insert data created outside Qore (e.g. by a call to C function) and thus work around any possible limitations of Qore integration.\n\
* Example: \x3Ccode\x3E$data.setBinary(\\$a_binary, "MBSTRING"); #Insert binary data as MBSTRING (multibyte string) type.\x3C/code\x3E\n\
---\n\
* /getBinary()/ - returns data from typed buffer as an Qore binary. For unallocated typed buffer it returns empty binary, for uninitialized buffer it returns the uninitialized data as a binary (this would be likely a programmer mistake). The original data stay in buffer unchanged.\n\
* Parameters: none\n\
* Returns: instance of Qore binary with the data\n\
* Notes: use [[tptypes()]] to find out what is the type and subtype of the data inside typed buffer.\n\
* Example: \x3Ccode\x3E$bin = $data.getBinary();\x3C/code\x3E\n\
---\n\
* /setString(string [, type, [subtype] ])/ - inserts data from Qore string into the typed buffer. Previous data, if any, will be freed.\n\
* Parameters:\n\
## instance of Qore string, could be passed by reference. The string will be converted into the encoding given by /TuxedoTypedBuffer::setStringEncoding()/. Empty string is allowed. The trailing byte (assumed to be 0) is always inserted into the buffer.\n\
## optional type  for the buffer. Default value is "STRING". See Tuxedo documentation for allowed names.\n\
## optional subtype for the buffer. Default value is NULL.\n\
* Returns: nothing.\n\
* Example: \x3Ccode\x3E$data.setString("&lt;xml\x3Eabc&lt;/xml\x3E", "XML"); #Insert a string as XML type.\x3C/code\x3E\n\
---\n\
* /getString()/ - returns data from typed buffer as an Qore string. For unallocated typed buffer it returns empty string, for uninitialized buffer it returns the uninitialized data as a string (ending on the first 0, mostl likely error). The original data stay in buffer unchanged.\n\
* Parameters: none\n\
* Returns: instance of Qore string with the data\n\
* Notes: use [[tptypes()]] to find out what is the type and subtype of the data inside typed buffer\n\
* Example: \x3Ccode\x3Eprintf("Buffer contains %s\\n", $data.getString());\x3C/code\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Initialize connection with Tuxedo. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c55.htm#1022852]].\n\
\n\
This function wraps Tuxedo ATMI call tpinit(). You may pass parameters via a hash with parameters (as in [[tpchkauth()]]). [[tpinitParams()]] is a more explicit alternative to [[tpinit()]]. Calling the function is multithread safe.\n\
\n\
*Parameters:*\n\
# optional: hash (string to {string|boolean}) with variables to be set during Tuxedo tpinit() call. Values from the hash (if present) have priority over environment variables. If the hash is not used then tpinit(NULL) is called. If no flag is set to true and no TPINIT strings are set then tpinit(NULL) is also called. In other cases the TPINIT structure is filled with data extracted from the hast\n\
\n\
* These string hash items are recognized as environment variable equivalents:\n\
** /TUXDIR/ (mandatory in hash or as env. variable). Example: \x3Ci\x3E/opt/bea/tuxedo91\x3C/i\x3E\n\
** /TUXCONFIG/ (mandatory or as env variable). Example: \x3Ci\x3E/home/joe/tuxedo_test/tuxconfig\x3C/i\x3E\n\
** /WSENVFILE, WSNADDR, WSFADDR, WSFRANGE, WSDEVICE, WSTYPE, WSRPLYMAX, TMMINENCRYPTBITS, TMMAXENCRYPTBITS, TMNOTHREADS/ \n\
\n\
* These boolean hash items are recognized as values of flags:\n\
** /TPU_SIG, TPU_DIG, TPU_THREAD, TPU_IGN, TPSA_FASTPATH, TPSA_PROTECTED, TPMULTICONTEXTS/ - if true the appropriate flag bit is set\n\
\n\
* These string hash items are recognized as TPINIT values:\n\
** /username/\n\
** /clientname/\n\
** /password/\n\
** /groupname/\n\
\n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example 1:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#Environment variables need to be set. Calls tpinit(NULL).\n\
$res = [[tpinit()|tpinit]]();\n\
\n\
if ($res == 0) {\n\
  printf("Connected\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 2:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$params = (\n\
  "TUXDIR"      : "/opt/bea/tuxedo91",\n\
  "TUXCONFIG"   : "/home/joe/tuxedo_test/tuxconfig",\n\
  "TPMULTICONTEXTS" : true,\n\
  "TPU_SIG" : false # if false then it could be omitted\n\
  "username" : "joe",\n\
  "password" : "xyz"\n\
  );\n\
\n\
$res = [[tpinit()|tpinit]](\\$params);\n\
\n\
... handle $res\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 3:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$params = ("TUXDIR" : "/opt/bea/tuxedo91" );\n\
\n\
#$TUXCONFIG needs to be set as env. variable\n\
$res = [[tpinit()|tpinit]]($params);\n\
\n\
... handle $res\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*Notes:*\n\
* [[tpinitParams()]] also allows to pass a binary data into tpinit().\n\
* [[tpchkauth()]] should use the same settings.\n\
* [[tpterm()]] is used to close the connection to Tuxedo.\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Closes connection to Tuxedo. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c86.htm#1219084]].\n\
\n\
This function closes connection established by [[tpinit()]] or [[tpinitParams()]].\n\
\n\
*Parameters:* \n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
... successful call to [[tpinit()]] or [[tpinitParams()]]\n\
\n\
$res = [[tpterm()|tpterm]]();\n\
\n\
if ($res == 0) {\n\
  printf("Connection closed OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Get information about typed buffer. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c87.htm#1045809]].\n\
\n\
This function returns information about a typed buffer kept inside instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]. This information could be useful when the data was inserted there by function like [[tpgetrply()]].\n\
\n\
*Parameters:* \n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]], could be passed by reference. Needs to contain existing memory block (otherwise error is returned).\n\
# out: found type (string passed by reference)\n\
# out: found subtype (string passed by reference)\n\
# out: found size of the buffer (integer passed by reference)\n\
\n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]\n\
\n\
$type = "";\n\
$subtype = "";\n\
$size = 0;\n\
\n\
$res = [[tptypes()|tptypes]](\\$data, \\$type, \\$subtype, \\$size);\n\
\n\
if ($res == 0) {\n\
  printf("Type = %s, subtype = %s, size = %d B\\n", $type, $subtype, $size);\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* The typed buffer must be allocated before (either by [[tpalloc()]] or by some functions that fills it.\n\
* Overview of typed buffer manipulation is on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgbuf.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Call server with and return the result. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c26.htm#1021731]].\n\
\n\
This functions calls server and waits to response. Data passed to the server and received back are instances of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]].\n\
\n\
*Parameters:*\n\
# service name (string). \n\
# input data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with valid allocated memory block. Could be passed by reference.\n\
# out: received data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with uninitialized memory block (by [[tpalloc()]]). Needs to be passed by reference.\n\
# flags (integer)\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
$data.setString("abcd");\n\
\n\
$received = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
$res = [[tpalloc()|tpalloc]](\\$received, 10);\n\
\n\
if ($res != 0) { .... handle error }\n\
\n\
$res = [[tpcall()|tpcall]]("TOUPPER", \\$data, \\$received, Tuxedo::TPNOTIME | Tuxedo::TPNOCHANGE);\n\
\n\
if ($res == 0) {\n\
  printf("Call succeeded\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* asynchronous request/response [[tpacall()]] and [[tpgetrply()]] combination could be used instead of [[tpcall()]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Call server asynchronously. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c20.htm#1037129]].\n\
\n\
This functions calls server and _doesn\'t_ waits to for response. Data passed to the server are instances of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]. The response is read later by [[tpgetrply()]] or discarded by [[tpcancel()]].\n\
\n\
*Parameters:*\n\
# service name (string). \n\
# input data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with valid allocated memory block. Could be passed by reference.\n\
# flags (integer)\n\
# out: result handle used to retrieve the response later, an integer passed by reference.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
$data.setString("abcd");\n\
\n\
$handle = 0;\n\
\n\
$res = [[tpacall()|tpacall]]("TOUPPER", \\$data, 0, \\$handle);\n\
\n\
if ($res == 0) {\n\
  printf("Called\\n");\n\
\n\
  $res = tpgetrply(....); #Read the response\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Synchronous [[tpacall()]] could be used instead of combination [[tpacall()]] and [[tpgetrply()]].\n\
* If the response is not read with [[tpgetrply()]] then the handle needs to be closed by [[tpcancel()]].\n\
* If flag Tuxedo::TPNOREPLY is set then no response will be sent and the handle will be 0 (zero means no response to be expected).\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Cancel the asynchronous call. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c27.htm#1039772]].\n\
\n\
This functions cancels pending request created by [[tpacall()]]. It shoukd be used if the reqponse to the call is no longer needsd Otherwise [[tpgetrply()]] should be used to read the response.\n\
\n\
*Parameters:*\n\
# integer handle obtained from [[tpacall()]]\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = [[TuxedoTypedBuffer|new Tuxedo::TuxedoTypedBuffer()]];\n\
$data.setString("abcd");\n\
\n\
$handle = 0;\n\
\n\
$res = [[tpacall()|tpacall]]("TOUPPER", \\$data, 0, \\$handle);\n\
\n\
if ($res != 0) { ... handle error ... }\n\
\n\
$res = [[tpcancel()|tpcancel]]($handle);\n\
if ($res == 0) {\n\
  printf("Cancelled OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* If the handle is not "consumed" by [[tpgetrply()]] it needs to be passed into [[tpcancel()]]. If it is used by [[tpgetrply()]] it doesn\'t need not be cancelled.\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Retrieve response to the the asynchronous call. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocsbea.com/tuxedo/tux91/rf3c/rf3c52.htm#1021885]].\n\
\n\
This functions retrieves data requested by previous call of [[tpacall()]] (unless flag Tuxedo::TPNOREPLY was specified). If this function is not called then the handle needs to be closed by calling [[tpcancel()]].\n\
\n\
*Parameters:*\n\
# integer handle obtained from [[tpacall()]]\n\
# out: received data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with uninitialized memory block (by [[tpalloc()]]). Needs to be passed by reference.\n\
# flags (integer)\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = [[TuxedoTypedBuffer|new Tuxedo::TuxedoTypedBuffer()]];\n\
$data.setString("abcd");\n\
\n\
$handle = 0;\n\
\n\
$res = [[tpacall()|tpacall]]("TOUPPER", \\$data, 0, \\$handle);\n\
\n\
if ($res != 0) { .. handle error ... }\n\
\n\
$received_data = [[TuxedoTypedBuffer|new Tuxedo::TuxedoTypedBuffer()]];\n\
$res = [[tpalloc()|tpalloc]]("STRING", "", 10, \\$received_data);\n\
\n\
if ($res != 0) { ... handle error ... }\n\
\n\
$res = [[tpgetrply()|tpgetrply]]($handle, \\$received_data, Tuxedo::TPNOTIME);\n\
if ($res == 0) {\n\
  printf("Data read, expolore content of $received_data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
  [[tpcancel()|tpcancel]]($handle); #Just in case, do not check the result.\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Synchronous [[tpcall()]] could replace [[tpacall()]] and [[tpgetrply()]] combination.\n\
* if [[tpgetrply()]] fails it may be good idea to close the handle with [[tpcancel()]] not checking the result, just to be sure there\'s no leak.\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Forcibly tear down conversational connection. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c37.htm#1042150]].\n\
\n\
This functions forcibly tears down conversational connection established by [[tpconnect()]]. Preferably, the application should cooperate with the server and close the conversation through use of [[tpsend()]] and [[tprecv()]].\n\
\n\
*Parameters:*\n\
# integer handle obtained from [[tpconnect()]]\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$handle = 0;\n\
$empty = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = [[tpconnect()|tpconnect]]("server name", \\$empty, 0, \\$handle);\n\
\n\
if ($res != 0) { .. handle error }\n\
\n\
#The connection needs to be broken by force\n\
$res = [[tpdiscon()|tpdiscon]]($handle);\n\
\n\
if ($res == 0) {\n\
  printf("Conversational connection closed\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* In transaction mode [[tpdiscon()]] will mark the current transaction as abort-only.\n\
* See writing conversational clients and servers [[http://edocs.bea.com/tuxedo/tux91/pgc/pgconv.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Abort current transaction. Standalone function, part of [[Low Level Layer|low level]] layer Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c19.htm#1036832]].\n\
\n\
This functions aborts the transaction established by [[tpbegin()]].\n\
\n\
*Parameters:*\n\
* none \n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpbegin()|tpbegin]](10);\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tpabort()|tpabort]]();\n\
\n\
if ($res == 0) {\n\
  printf("Transaction aborted\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Use [[tpcommit()]] to sucessfully close the transaction\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Starts new transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c24.htm#1039168]].\n\
\n\
The transaction could be closed by [[tpcommit()]] or [[tpabort()]].\n\
\n\
*Parameters:*\n\
# timeout in seconds, integer\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpbegin()|tpbegin]](10);\n\
\n\
if ($res == 0) {\n\
  printf("Transaction started\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Commit current transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c31.htm#1040811]].\n\
\n\
This functions commits the transaction established by [[tpbegin()]].\n\
\n\
*Parameters:*\n\
# timeout in seconds, integer\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpbegin()|tpbegin]](10);\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tpcommit()|tpcommit]]();\n\
\n\
if ($res == 0) {\n\
  printf("Transaction comitted OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* Use [[tpabort()]] to abort the transaction\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Open resource management. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c61htm#1043391]].\n\
\n\
To close resource management use [[tpclose()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpopen()|tpopen]]();\n\
\n\
if ($res == 0) {\n\
  printf("Resource manager opened OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Close resource management. Standalone function, part of [[Low Level Layer|low level]] layer Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c30.htm#1040568]].\n\
\n\
The resource management needs to be opened by [[tpopen()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpopen()|tpopen]]();\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tpclose()|tpclose]]();\n\
\n\
if ($res == 0) {\n\
  printf("Resource manager opened OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Establish conversational connection. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c32.htm#1041087]].\n\
\n\
Use [[tpsend()]] and [[tprecv()]] to pass data and find out when the connection was closed. Use [[tpdiscon()]] to forcibly tear down the connection.\n\
\n\
*Parameters:*\n\
# service name string\n\
# initial data to be sent, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]. Could be passed by reference. Could be empty.\n\
# flags (integer)\n\
# out: handle, integer passed by reference. The handle is used by [[tpsend()]], [[tprecv()]] and [[tpdiscon()]].\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$handle = 0;\n\
$empty = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = [[tpconnect()|tpconnect]]("server name", \\$empty, Tuxedo::TPNOTRAN, \\$handle);\n\
\n\
if ($res == 0) {\n\
  printf("Failed to establish conversational connection\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing conversational clients and servers [[http://edocs.bea.com/tuxedo/tux91/pgc/pgconv.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Send data in conversational connection. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c70.htm#1023105]].\n\
\n\
The semantic of [[tpsend()]] and [[tprecv()]] is quite complex - see Tuxedo documentation for details.\n\
\n\
*Parameters:*\n\
# handle integer, obtained from [[tpconnect()]]\n\
# data to be sent, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with valid allocated memory block. Could be passed by reference.\n\
# flags integer\n\
# out: received event (if any), integer passed by reference. See Tuxedo documentation for details.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code. If the error code is Tuxedo::TPEVENT then an event was received and should be examined.\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$handle = ... valid handle from [[tpconnect()]]\n\
\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$data.setString("abc");\n\
\n\
$event = 0;\n\
$res = [[tpsend()|tpsend]]($handle, \\$data, 0, \\$event);\n\
\n\
if ($res == 0) {\n\
  printf("Data sent OK\\n");\n\
} else {\n\
  if ($res == Tuxedo::TPEVENT) {\n\
    printf("Data not sent but event %d received\\n", $event);\n\
  } else {\n\
    printf("Error %d\\n", $res);\n\
  }\n\
}\n\
\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing conversational clients and servers [[http://edocs.bea.com/tuxedo/tux91/pgc/pgconv.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Receive data in conversational connection. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c64.htm#1022967]].\n\
\n\
The semantic of [[tpsend()]] and [[tprecv()]] is quite complex - see Tuxedo documentation for details.\n\
\n\
*Parameters:*\n\
# handle integer, obtained from [[tpconnect()]]\n\
# out: received data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with uninitialized memory block (by [[tpalloc()]]). Needs to be passed by reference.\n\
# flags integer\n\
# out: received event (if any), integer passed by reference. See Tuxedo documentation for details.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code. If the error code is Tuxedo::TPEVENT then an event was received and should be examined. Tuxedo::TPETIME error has rather complex semantic.\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$handle = ... valid handle from [[tpconnect()]]\n\
\n\
$received_data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = [[tpalloc()|tpalloc]]("STRING", "", 0, \\$received_data);\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
$event = 0;\n\
$res = [[tprecv()|tprecv]]($handle, \\$received_data, Tuxedo::TPNOCHANGE | Tuxedo::TPNOBLOCK, \\$event);\n\
\n\
if ($res == 0) {\n\
  printf("Data received OK\\n");\n\
} else {\n\
  if ($res == Tuxedo::TPEVENT) {\n\
    printf("Data not received but got event %d\\n", $event);\n\
  } else {\n\
    printf("Error %d\\n", $res);\n\
  }\n\
}\n\
\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing conversational clients and servers [[http://edocs.bea.com/tuxedo/tux91/pgc/pgconv.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Enqueue a message. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c38.htm#1042179]].\n\
\n\
Puts a message into a queue. [[tpdequeue()]] will take the message from queue.\n\
\n\
*Parameters:*\n\
# queue space string\n\
# queue string\n\
# inout: instance of [[TuxedoQueueCtl|Tuxedfo::TuxedoQueueCtl]] class passed by reference. The instance contains parameters controlling [[tpenqueue()]] and received information on return. See tuxedo documentation on details.\n\
# data to be queued, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with valid data inside. Could be passed by reference.\n\
# flags (integer)\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$queue_ctl = new [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]]();\n\
$queue_ctl.setFlags(Tuxedo::TPQPRIORITY);\n\
$queue_ctl.setPriority(80);\n\
\n\
$data =  .... get instance of [[TuxedoTypedBuffer]] with data\n\
\n\
#The $queue_ctl must be passed by reference\n\
$res = [[tpenqueue()|tpenqueue]]("a queue space", "a queue name", \\$queue_ctl, \\$some_data, Tuxedo::TPNOTRAN);\n\
\n\
if ($res != 0) { \n\
   printf("Error %d\\n", $res); \n\
   if ($res == Tuxedo::TPEDIAGNOSTIC) {\n\
     $reason = $queue_ctl.getDiagnostic();\n\
     printf("Detailed error diagnostic = %d\\n", $reason);\n\
   }\n\
} else {\n\
  printf("Data enqueued OK\\n");\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See overview of queueing [[http://edocs.bea.com/tuxedo/tux91/qgd/qoview.htm]]\n\
* See overview of queueing in C [[http://edocs.bea.com/tuxedo/tux91/qgd/qpgm.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Get a message from queue. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c38.htm#1042179]].\n\
\n\
Retrieves message put into a queue by [[tpenqueue()]].\n\
\n\
*Parameters:*\n\
# queue space string\n\
# queue string\n\
# inout: instance of [[TuxedoQueueCtl|Tuxedfo::TuxedoQueueCtl]] class passed by reference. The instance contains parameters controlling [[tpenqueue()]] and receives information on return. See Tuxedo documentation on details.\n\
# out: received data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with uninitialized memory block (by [[tpalloc()]]). Needs to be passed by reference.\n\
# flags (integer)\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$queue_ctl = new [[TuxedoQueueCtl|Tuxedo::TuxedoQueueCtl]]();\n\
$queue_ctl.setFlags(Tuxedo::TPQWAIT);\n\
\n\
$data = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
$res = [[tpalloc()|tpalloc]]("STRING", "", 100, \\$data);\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
#The $queue_ctl and $data must be passed by reference\n\
$res = [[tpdequeue()|tpdequeue]]("a queue space", "a queue name", \\$queue_ctl, \\$data, 0);\n\
\n\
if ($res != 0) { \n\
  printf("Error %d\\n", $res);\n\
} else {\n\
  printf("Data read from queue\\n");\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See overview of queueing [[http://edocs.bea.com/tuxedo/tux91/qgd/qoview.htm]].\n\
* See overview of queueing in C [[http://edocs.bea.com/tuxedo/tux91/qgd/qpgm.htm]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Set service priority. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c77.htm#1045232]].\n\
\n\
The function could be used to change priority of requests and message queues. [[tpgprio()]] returns the current priority.\n\
\n\
*Parameters:* \n\
# integer priority\n\
# integer flags (0 or Tuxedo::TPABSOLUTE)\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpsprio()|tpsprio]](80, Tuxedo::TPABSOLUTE);\n\
\n\
if ($res == 0) {\n\
  printf("Priority set OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Get service priority. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c53.htm#1042995]].\n\
\n\
The function retrieves either the default priority or the value set before by [[tpsprio()]].\n\
\n\
*Parameters:* \n\
# out: current priority as integer passed by reference\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$priority = 0;\n\
$res = [[tpgprio()|tpgprio]](\\$priority);\n\
\n\
if ($res == 0) {\n\
  printf("Priority is %d\\n", $priority);\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'Suspend current transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c81.htm#1045633]].\n\
\n\
A transaction, started by [[tpbegin()]] could be suspended and the resumed by [[tpresume()]].\n\
\n\
*Parameters:*\n\
# instance of newly created [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]] class passed by reference.\n\
# integer flags\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$tranid = new [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]]();\n\
\n\
#suspend current transaction\n\
$res = [[tpsuspend()|tpsuspend]](\\$tranid, 0);  #must be passed by reference\n\
\n\
if ($res == 0) {\n\
  printf("Transaction suspended\\n");\n\
} else { \n\
  printf("Error %d\\n", $res);\n\
}\n\
\n\
$res = [[tpresume()|tpresume]](\\$tranid, 0);\n\
\n\
if ($res != 0) { ... handle error }\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Resume suspended current transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c65.htm#1044625]].\n\
\n\
A transaction suspended by [[tpsuspend()]] could be resumed by this function. The instance of [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]] filled by [[tpsuspend()]] needs to be passed into the function.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]] class filled by [[tpsuspend()]], possibly passed by reference.\n\
# integer flags\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$tranid = new [[TuxedoTransactionId|Tuxedo::TuxedoTransactionId]]();\n\
\n\
#suspend current transaction\n\
$res = [[tpsuspend()|tpsuspend]](\\$tranid, 0);  #must be passed by reference\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
\n\
$res = [[tpresume()|tpresume]](\\$tranid, 0);\n\
\n\
if ($res == 0) {\n\
  printf("Transaction resumed\\n");\n\
} else { \n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Change commit settings.  Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c68.htm#1044795]].\n\
\n\
Routine for setting when [[tpcommit()]] should return.\n\
\n\
*Parameters:*\n\
# integer flags: Tuxedo::TP_CMT_LOGGED or Tuxedo::TP_CMT_COMPLETE.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tpscmt()|tpscmt]](Tuxedo::TP_CMT_LOGGED);  \n\
\n\
if ($res == 0) {\n\
  printf("Change OK\\n");\n\
} else { \n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Find transaction state.  Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c49.htm#1225812]].\n\
\n\
Routine to find whether transaction is in progress or not.\n\
\n\
*Parameters:*\n\
# out: integer indicator passed by reference. On successful return it will contain 0 for no transaction and 1 for transaction in progress\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$transaction_running = 0;\n\
\n\
$res = [[tpgetlev()|tpgetlev]](\\$transaction_running);  \n\
\n\
if ($res == 0) {\n\
  if ($transaction_running == 0) {\n\
    printf("No transaction\\n");\n\
  } else {\n\
    printf("Transaction running\\n");\n\
  }  \n\
} else { \n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See writing global transactions on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgglob.htm#1136054]].\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Get error description. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c78.htm#1023204]].\n\
\n\
*Parameters:*\n\
# error integer (the \x3C\x3E 0 value returned by most of the ATMI wrappers)\n\
# out: error message string passed by reference\n\
\n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = ... some ATMI wrapper\n\
\n\
if ($res != 0) {\n\
  $str = "";\n\
  $res2 = [[tpstrerror()|tpstrerror]]($res, \\$str);\n\
  if ($res2 == 0) {\n\
    printf("Error % means %s\\n", $res, $str);\n\
  } else {\n\
    printf("Even tpstrerror() failed\\n");\n\
  } \n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-19./\x3C/small\x3E',
'Post an event. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c62.htm#1044210]].\n\
\n\
Posts event with given data.\n\
\n\
*Parameters:* \n\
# event name string\n\
# event data, instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with valid allocated memory block. Could be passed by reference.\n\
# integer flags\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer()]];\n\
\n\
$res = [[tppost()|tppost]]("an event name", \\$data, 0);\n\
\n\
if ($res == 0) {\n\
  printf("Event posted OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See event based servers and clients overview on [[http://edocs.bea.com/tuxedo/tux91/pgc/pgevb.htm]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Starts new X/Open TX  transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c101.htm#1046168]].\n\
\n\
The transcation could be closed by [[tx_rollback()]] or [[tx_commit()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_begin()|tx_begin]]();\n\
\n\
if ($res == 0) {\n\
  printf("Transaction started\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[http://edocs.bea.com/tuxedo/tux91/overview/overview.htm#1110058]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Close X/Open resource managers. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c30.htm#1040568]].\n\
\n\
The managers are opened by [[tx_open()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_open()|tx_open]]();\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tx_close()|tx_close]]();\n\
\n\
if ($res == 0) {\n\
  printf("Resource manager closed OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Open X/Open resource managers. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c102.htm#1046217]].\n\
\n\
The managers are close by [[tx_close()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_open()|tx_open]]();\n\
\n\
if ($res == 0) {\n\
  printf("Resource manager opened OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Commit started X/Open TX  transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c103.htm#1046266]].\n\
\n\
The transcation needs to be started by [[tx_begin()]]. To roll back the transaction use [[tx_rollback()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_begin()|tx_begin]]();\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
\n\
$res = [[tx_commit()|tx_commit]]();\n\
\n\
if ($res == 0) {\n\
  printf("Transaction comitted\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[http://edocs.bea.com/tuxedo/tux91/overview/overview.htm#1110058]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Roll back started X/Open TX  transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.beacom/tuxedo/tux91/rf3c/rf3c106.htm#1046426]].\n\
\n\
The transcation needs to be started by [[tx_begin()]]. To commit the transaction use [[tx_commit()]].\n\
\n\
*Parameters:*\n\
* none\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_begin()|tx_begin]]();\n\
\n\
if ($res != 0) { ... handle error }\n\
\n\
\n\
$res = [[tx_rollback()|tx_rollback]]();\n\
\n\
if ($res == 0) {\n\
  printf("Transaction rolled back\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[http://edocs.bea.com/tuxedo/tux91/overview/overview.htm#1110058]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-20./\x3C/small\x3E',
'Unlike [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c.htm|ATMI]] functions  the [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731|FML and FML32 ]] functions  are *not* wrapped and exported to Qore.\n\
\n\
Standalone functions are provided:\n\
* [[processFMLDescriptionTables()]] and [[processFML32DescriptionTables()]] - to obtain settings needed to read or write FML/FML32 data.\n\
* [[putFMLInTypedBuffer()]] and [[putFML32InTypedBuffer()]] that fill instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] class from given hash with values.\n\
* [[getFMLFromTypedBuffer()]] and [[getFML32FromTypedBuffer()]] that extract hash with values from instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] class.\n\
* conversions between XML/FML/FML32\n\
\n\
The ATMI wrappers like [[tpcall()]] could be then used to deal with the data inside the typed buffer. Instead of returning error code as with ATMI wrappers an exception is thrown if something fails in the FML/FML32 interaction.\n\
\n\
*Notes:*\n\
* FML/FML32 overview: [[http://edocs.bea.com/tuxedo/tux91/fml/fml01.htm]]\n\
* FMLK/FML32 API: [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731]]',
'This function reads description tables needed by the FML during runtime ([[http://edocs.bea.com/tuxedo/tux91/fml/fml04.htm|details]]) and returns hash with settings needed to create or read FML data. It allows to avoid manual setting of environment variables and also allows to create settings for many services, independently and thread safely.\n\
\n\
*Parameters:*\n\
# single string or list of strings. All strings need to be full files names of table description files\n\
*Returns:*\n\
* Hash with settings. Each field from the table is one hash item . Key is the filed name, value is list of (1) integer ID used by FML, (2) integer type (e.g. Tuxedo::FLD_SHORT). It could be treated as a opaque structure.\n\
\n\
*Example of description table:*\n\
(the same syntax is used for FML32)\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#comment\n\
*base 500\n\
#name           rel-number      type           flags   comment\n\
#----           ----------      ----           ------  -------\n\
EMPNAME         1               string         -       emp name\n\
EMPID           2               long           -       emp id\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example of use:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#exception on error\n\
$hash_settings = [[processFMLDescriptionTables()|processFMLDescriptionTables]]("/tmp/my_table");\n\
\n\
#use the settings later\n\
[[putFMLInTypedBuffer()|putFMLInTypedBuffer]](\\$hash_settings, ....); \n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*Notes:*\n\
* During the call these environment variables are set: /FIELDTBLS/ (to the files), /FLDTBRDIR/ (set empty). On return previous values are set again. This is implemented MT safe. The loaded tables are flushed by this call. Several different settings could exist at the same time.\n\
* Setting up environment for FML/FML32: [[http://edocs.bea.com/tuxedo/tux91/fml/fml03.htm]]\n\
* [[processFML32DescriptionTables()]] is FML32 equivalent\n\
',
'This function reads description tables needed by the FML32 during runtime ([[http://edocs.bea.com/tuxedo/tux91/fml/fml04.htm|details]]) and returns hash with settings needed to create or read FML32 data. It allows to avoid manual setting of environment variables and also allows to create settings for many services, independently and thread safely.\n\
\n\
*Parameters:*\n\
# single string or list of strings. All strings need to be full files names of table description files\n\
*Returns:*\n\
* Hash with settings. Each field from the table is one hash item . Key is the filed name, value is list of (1) integer ID used by FML32, (2) integer type (e.g. Tuxedo::FLD_SHORT). It could be treated as a opaque structure.\n\
\n\
*Example of description table:*\n\
(the same syntax is used for FML)\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#comment\n\
*base 500\n\
#name           rel-number      type           flags   comment\n\
#----           ----------      ----           ------  -------\n\
EMPNAME         1               string         -       emp name\n\
EMPID           2               long           -       emp id\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example of use:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#exception on error\n\
$hash_settings = [[processFML32DescriptionTables()|processFML32DescriptionTables]]("/tmp/my_table");\n\
\n\
#use the settings later\n\
[[putFML32InTypedBuffer()|putFML32InTypedBuffer]](\\$hash_settings, ....); \n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*Notes:*\n\
* During the call these environment variables are set: /FIELDTBLS32/ (to the files), /FLDTBRDIR32/ (set empty). On return previous values are set again. This is implemented MT safe. The loaded tables are flushed by this call. Several different settings could exist at the same time.\n\
* Setting up environment for FML/FML32: [[http://edocs.bea.com/tuxedo/tux91/fml/fml03htm]]\n\
* [[processFMLDescriptionTables()]] is FML equivalent\n\
',
'The high-level interface is implemented in Qore, using [[Low Level Layer|lower level]] wrappers over ATMI functions (e.g. [[tpcall()]] and [[FML/FML32 support|FML/FML32 functions]].\n\
\n\
The high-level interface consists of the [[TuxedoAdapter]] class.\n\
\n\
',
'Fill instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with FML data structure. The buffer could then be passed to ATMI wrappers like [[tpcall()]].\n\
\n\
*Parameters:*\n\
# Hash with settings returned by [[processFMLDescriptionTables()]]. Could be passed by reference. Data for the FML buffer need to be consistent with this description, otherwise exception is thrown.\n\
# List with data to be inserted into FML buffer. The items in the list are sub-lists with string item name (the FML field, as in description table) and then the value (which needs to be something convertible into the type defined in description table).\n\
# out: instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with uninitialized FML buffer created inside. Needs to be passed by reference\n\
\n\
*Returns:*\n\
* nothing (exception is thrown on error)\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$hash_settings = [[processFMLDescriptionTables()|processFMLDescriptionTables]]("/tmp/my_description_table");\n\
\n\
#add two employees\n\
$values = (\n\
  ("employee_name" : "John Smith"), ("employee_number" : 7182),\n\
  ("employee_name" : "Joe Brown"), ("employee_number" : 6321),\n\
  );\n\
\n\
$buffer = new [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]]();\n\
$res = [[tpalloc()|tpalloc]]("FML", "", 4096, \\$buffer);\n\
if ($res != 0) { .. handle error }\n\
\n\
[[putFMLInTypedBuffer()|putFMLInTypedBuffer]](\\$hash_settings, \\$values, \\$buffer);\n\
\n\
$received_data = new [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]]();\n\
$res = [[tpcall()|tpcall]]("ADD_EMPLOYEE", \\$buffer, \\$received_data, 0);\n\
\n\
if ($res != 0) { ... handle error }\n\
#process received data\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*See also:*\n\
* FML/FML32 API [[http://edocsbea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731]]\n\
* [[getFMLFromTypedBuffer()]] for the opposite operation\n\
',
'Fill instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with FML32 data structure. The buffer could then be passed to ATMI wrappers like [[tpcall()]].\n\
\n\
*Parameters:*\n\
# Hash with settings returned by [[processFML32DescriptionTables()]]. Could be passed by reference. Data for the FML32 buffer need to be consistent with this description, otherwise exception is thrown.\n\
# List with data to be inserted into FML32 buffer. The items in the list are sub-lists with string item name (the FML32 field, as in description table) and then the value (which needs to be something convertible into the type defined in description table).\n\
# out: instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with uninitialized FML32 buffer created inside. Needs to be passed by reference.\n\
\n\
*Returns:*\n\
* nothing (exception is thrown on error)\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$hash_settings = [[processFML32DescriptionTables()|processFM32LDescriptionTables]]("/tmp/my_description_table");\n\
\n\
#add two employees\n\
$values = (\n\
  ("employee_name" : "John Smith"), ("employee_number" : 7182),\n\
  ("employee_name" : "Joe Brown"), ("employee_number" : 6321),\n\
  );\n\
\n\
$buffer = new [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]]();\n\
$res = [[tpalloc()|tpalloc]]("FML32", "", 4096, \\$buffer);\n\
if ($res != 0) { ... handle error }\n\
\n\
[[putFML32InTypedBuffer()|putFML32InTypedBuffer]](\\$hash_settings, \\$values, \\$buffer);\n\
\n\
$received_data = new [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]]();\n\
$res = [[tpcall()|tpcall]]("ADD_EMPLOYEE", \\$buffer, \\$received_data, 0);\n\
\n\
if ($res != 0) { ... handle error }\n\
#process received data\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*See also:*\n\
* FML/FML32 API [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731]]\n\
* [[getFML32FromTypedBuffer()]] for the opposite operation\n\
',
'Extract FML data from instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] class. The buffer needs to be filled (e.g. by [[tpgetrply()]]) and needs to contain FML data structure (use [[tptypes()]] to find out details). The extracted data are converted into Qore list of lists with name of the FML field (as in description tables) and the value is converted from FML type (e.g. /FLD_SHORT/) to appropriate Qore type (here integer).\n\
\n\
*Parameters:*\n\
# Hash with settings returned by [[processFMLDescriptionTables()]]. Could be passed by reference. Data in the FML buffer needs to be consistent with this description, otherwise exception is thrown.\n\
# instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with FML data inside. Could be passed by reference.\n\
*Returns:*\n\
* List of lists with FML field name and Qore value. On error an exception is thrown.\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$hash_settings = [[processFMLDescriptionTables()|processFMLDescriptionTables]]("/tmp/my_description_table");\n\
\n\
$buffer = ...  [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] instance with FML data\n\
\n\
$retrieved_values = [[getFMLFromTypedBuffer()|getFMLFromTypedBuffer]](\\$hash_settings, \\$buffer);\n\
\n\
#process the retrieved data\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*See also:*\n\
* FML/FML32 API [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731]]\n\
* [[putFMLInTypedBuffer()]] for the opposite operation\n\
',
'Extract FML32 data from instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] class. The buffer needs to be filled (e.g. by [[tpgetrply()]]) and needs to contain FML32 data structure (use [[tptypes()]] to find out details). The extracted data are converted into Qore list of lists with name of the FML32 field (as in description tables) and the value is converted from FML32 type (e.g. /FLD_SHORT/) to appropriate Qore type (here integer).\n\
\n\
*Parameters:*\n\
# Hash with settings returned by [[processFML32DescriptionTables()]]. Could be passed by reference. Data in the FML32 buffer needs to be consistent with this description, otherwise exception is thrown.\n\
# instance of [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] with FML32 data inside. Could be passed by reference.\n\
\n\
*Returns:*\n\
* List of lists with FML32 field name and Qore value. On error an exception is thrown.\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$hash_settings = [[processFML32DescriptionTables()|processFML32DescriptionTables]]("/tmp/my_description_table");\n\
\n\
$buffer = ...  [[TuxedoTypedBuffer|Tudexo::TuxedoTypedBuffer]] instance with FML32 data\n\
\n\
$retrieved_values = [[getFML32FromTypedBuffer()|getFML32FromTypedBuffer]](\\$hash_settings, \\$buffer);\n\
\n\
#process the retrieved data\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*See also:*\n\
* FML/FML32 API [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1011731]]\n\
* [[putFML32InTypedBuffer()]] for the opposite operation\n\
',
'The Qore class used to wrap C structure /TPCONTEXT_T/ (see \x3Ci\x3E$TUXDIR/include/atmi.h\x3C/i\x3E). The class is written in C++ and exposed into Qore as a part of [[Low Level Layer|low level]] layer\n\
\n\
/TPCONTEXT_T/ is used by ATMI functions /tpgetctxt/ and /tpsetctxt/. The [[TuxedoContext|Tuxedo::TuxedoContext]] class does the same for Qore functionn [[tpgetctxt()]] and [[tpsetctxt()]]. \n\
\n\
*Member functions:*\n\
* constructor with no parameters\n\
* /isNullContext()/ returning True if the context is 0 (TPNULLCONTEXT). See Tuxedo documentation for semantic: [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c48.htm#1226460]].\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$ctx = new [[TuxedoContext|Tuxedo::TuxedoContext]]();\n\
\n\
$res = [[tpgetctxt()|tpgetctxt]](\\$ctx);  #must be passed by reference\n\
\n\
if ($res != 0) { printf("Error %d\\n", $res); ... }\n\
\n\
#boolean\n\
$is_null = $ctx.isNullContext();\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Get current context. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c48.htm#1226460]].\n\
\n\
The context could be the changed by using [[tpsetctxt()]].\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoContext|Tuxedo::TuxedoContext]] class passed by reference.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$ctx = new [[TuxedoContext|Tuxedo::TuxedoContext]]();\n\
\n\
$res = [[tpgetctxt()|tpgetctxt]](\\$ctx);  #must be passed by reference\n\
\n\
if ($res == 0) { \n\
  printf("Context obtained.\\n");\n\
} else {\n\
  printf("Error %d\\n", $res); \n\
} \n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Set current context. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c72.htm#1223538]].\n\
\n\
The context needs to be obtained before by [[tpgetctxt()]].\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoContext|Tuxedo::TuxedoContext]] class, could be passed by reference.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$ctx = new [[TuxedoContext|Tuxedo::TuxedoContext]]();\n\
\n\
$res = [[tpgetctxt()|tpgetctxt]](\\$ctx);  #must be passed by reference\n\
\n\
if ($res != 0) { ... handle error  }\n\
\n\
$res = [[tpsetctxt()|tpsetctxt]](\\$ctx);  \n\
\n\
if ($res == 0) {\n\
  printf("Context changed OK\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Settings for X/Open TX transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c107.htm#1046490]].\n\
\n\
This function has effect on [[tx_commit()]].\n\
\n\
*Parameters:*\n\
# integer flags: either /Tuxedo::TX_COMMIT_DECISION_LOGGED/ or /Tuxedo::TX_COMMIT_COMPLETED/.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_set_commit_return()|tx_set_commit_return]](Tuxedo::TX_COMMIT_COMPLETED);\n\
\n\
if ($res == 0) {\n\
  printf("Transaction settings changed\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Settings for X/Open transaction commit. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c107.htm#1046490]].\n\
\n\
Specifies whether transaction is started implicitly or [[tx_begin()]] is needed.\n\
\n\
*Parameters:*\n\
# integer flags: either /Tuxedo::TX_UNCHAINED/ or /Tuxedo::TX_CHAINED/.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_set_transaction_control()|tx_set_transaction_control]](Tuxedo::TX_UNCHAINED);\n\
\n\
if ($res == 0) {\n\
  printf("Transaction settings changed\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Settings for X/Open TX transaction. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c107.htm#1046490]].\n\
\n\
This function sets timeout for transaction.\n\
\n\
*Parameters:*\n\
# integer timeout in seconds. 0 means no timeout.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$res = [[tx_set_transaction_timeout()|tx_set_transaction_timeout]](3);\n\
\n\
if ($res == 0) {\n\
  printf("Transaction timout set\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert XML data to FML. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c92.htm#2011500]].\n\
\n\
Converts XML data from [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] instance into FML.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with XML data inside, could be passed by reference\n\
# fully qualified file name to XML schema or empty string if not used (by flags)\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where FML will be stored, needs to be passed by reference. The buffer should contain uninitialized FML memory block.\n\
# integer flags\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with XML data\n\
\n\
$out_fml = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = tpalloc("FML", "", 4096, \\$out_fml);\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tpxmltofml()|tpxmltofml]](\\$data, "", \\$out_fml, Tuxedo::TXPARSNEVER);\n\
\n\
if ($res == 0) {\n\
  printf("$out_fml now contains FML data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[tpxmltofml32()]], [[tpfmltoxml()]], [[tpfml32toxml()]].\n\
* Conversion of typed buffers into XML [[http://edocs.bea.com/salt/docs11/admin/datamap.html]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert XML data to FML32. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c91.htm#2009111]].\n\
\n\
Converts XML data from [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] instance into FML32.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with XML data inside, could be passed by reference\n\
# fully qualified file name to XML schema or empty string if not used (by flags)\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where FML32 will be stored, needs to be passed by reference. The buffer should contain uninitialized FML memory block.\n\
# integer flags\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with XML data\n\
\n\
$out_fml32 = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = tpalloc("FML32", "", 4096, \\$out_fml32);\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[tpxmltofml32()|tpxmltofml32]](\\$data, "", \\$out_fml32, Tuxedo::TXPARSNEVER);\n\
\n\
if ($res == 0) {\n\
  printf("$out_fml32 now contains FML data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[tpxmltofml()]], [[tpfmltoxml()]], [[tpfml32toxml()]].\n\
* Conversion of typed buffers into XML [[http://edocs.bea.com/salt/docs11/admin/datamap.html]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert FML data to XML. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c43.htm#2178284]].\n\
\n\
Converts FML data from [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] instance into XML.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML data inside, could be passed by reference\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where XML will be stored, needs to be passed by reference. Needs to contain uninitialized XML type buffer.\n\
# string name of top level XML tag. Use empty string for default value &lt;FML\x3E\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML data\n\
\n\
$out_xml = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = [[tpalloc()|tpalloc]]("XML", "", 4096, \\$out_xml);\n\
if ($res != 0) { ... handle error  }\n\
\n\
$res = [[tpfmltoxml()|tpfmltoxml]](\\$data, "", \\$out_xml, "");\n\
\n\
if ($res == 0) {\n\
  printf("$out_xml now contains XML data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[tpxmltofml32()]], [[tpxmltofml()]], [[tpfml32toxml()]].\n\
* Conversion of typed buffers into XML [[http://edocs.bea.com/salt/docs11/admin/datamap.html]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert FML32 data to XML. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c42.htm#1987733]].\n\
\n\
Converts FML32 data from [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] instance into XML.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML32 data inside, could be passed by reference\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where XML will be stored, needs to be passed by reference. Needs to contain uninitialized XML type buffer.\n\
# string name of top level XML tag. Use empty string for default value &lt;FML32\x3E\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML32 data\n\
\n\
$out_xml = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
$res = [[tpalloc()|tpalloc]]("XML", "", 4096, \\$out_xml);\n\
if ($res != 0) { ... handle error  }\n\
\n\
$res = [[tpfmltoxml()|tpfmltoxml]](\\$data, "", \\$out_xml, "");\n\
\n\
if ($res == 0) {\n\
  printf("$out_xml now contains XML data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[tpxmltofml32()]], [[tpxmltofml()]], [[tpfmltoxml()]].\n\
* Conversion of typed buffers into XML [[http://edocs.bea.com/salt/docs11/admin/datamap.html]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert FML data to FML32. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1005524]].\n\
\n\
Wraps FML function /F16to32/.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML data inside, could be passed by reference\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where FML32 will be stored, needs to be passed by reference. It needs to contain preallocated memory block of FML32 type\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML data\n\
\n\
$out_fml32 = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = [[tpalloc()|tpalloc]]("FML32", "", 4096, \\$out_fml32);\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[fmltofml32()|fmltofml32]](\\$data, \\$out_fml32,);\n\
\n\
if ($res == 0) {\n\
  printf("$out_fml32 now contains converted data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[fml32tofml()]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25./\x3C/small\x3E',
'Convert FML32 data to FML. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3fml/rf3fml.htm#1005524]].\n\
\n\
Wraps FML function /F32to16/.\n\
\n\
*Parameters:*\n\
# instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML32 data inside, could be passed by reference\n\
# out: instance of [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] where FML will be stored, needs to be passed by reference. It needs to contain preallocated memory block of FML type.\n\
 \n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$data = ... [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]] with FML32 data\n\
\n\
$out_fml = new [[TuxedoTypedBuffer|Tuxedo::TuxedoTypedBuffer]]();\n\
\n\
$res = [[tpalloc()|tpalloc]]("FML", "", 4096, \\$out_fml);\n\
if ($res != 0) { ... handle error }\n\
\n\
$res = [[fml32tofml()|fml32tofml]](\\$data, \\$out_fml,);\n\
\n\
if ($res == 0) {\n\
  printf("$out_fml32 now contains converted data\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Notes:*\n\
* See also [[fmltofml32()]]\n\
\n\
\n\
\x3Csmall\x3E/Created on 2006-10-25/\x3C/small\x3E',
'Initialize connection with Tuxedo. Standalone function, part of [[Low Level Layer|low level]] layer. Documented on [[http://edocs.bea.com/tuxedo/tux91/rf3c/rf3c55.htm#1022852]].\n\
\n\
This is alternative to [[tpinit()]] functions. It makes some parameters more explicit and allows also to pass binary data to the Tuxedo tpinit() call. Calling the function is multithread safe.\n\
\n\
*Parameters:*\n\
# user name (string)\n\
# client name (string)\n\
# cleartext password (string)\n\
# group name (string)\n\
# flags (integer)\n\
# optional: additional binary data (Qore binary)\n\
# optional: hash with values replacing environment variables (see [[tpinit()]] for more on this) \n\
\n\
* These string hash items are recognized as environment variable equivalents:\n\
** /TUXDIR/ (mandatory in hash or as env. variable). Example: \x3Ci\x3E///opt/bea/tuxedo91\x3C/i\x3E\n\
** /TUXCONFIG/ (mandatory or as env. variable). Example: \x3Ci\x3E///home/joe/tuxedo_test/tuxconfig\x3C/i\x3E\n\
** /WSENVFILE, WSNADDR, WSFADDR, WSFRANGE, WSDEVICE, WSTYPE, WSRPLYMAX, TMMINENCRYPTBITS, TMMAXENCRYPTBITS, TMNOTHREADS/ \n\
\n\
*Returns:*\n\
* 0 on success, otherwise error code\n\
\n\
*Example 1:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#Five parameters\n\
$res = [[tpinitParams()|tpinitParams]]("name", "", "my_password", "", Tuxedo::TPU_IGN | Tuxedo::TPSA_FASTPATH);\n\
\n\
if ($res == 0) {\n\
  printf("Connected\\n");\n\
} else {\n\
  printf("Error %d\\n", $res);\n\
}\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 2:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
$params = (\n\
  "TUXDIR"      : "/opt/bea/tuxedo91",\n\
  "TUXCONFIG"   : "/home/joe/tuxedo_test/tuxconfig",\n\
  );\n\
\n\
#Six parameters (binary omitted)\n\
$res = [[tpinitParams()|tpinitParams]]("name", "", "my_password", "", Tuxedo::TPU_IGN | Tuxedo::TPSA_FASTPATH, $params);\n\
\n\
... handle $res\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
*Example 3:*\n\
\x3Cpre\x3E\x3Ccode\x3E\n\
#All parameters set.\n\
$params = (\n\
  "TUXDIR"      : "/opt/bea/tuxedo91",\n\
  "TUXCONFIG"   : "/home/joe/tuxedo_test/tuxconfig",\n\
  );\n\
$bin = ... Qore binary\n\
\n\
#Six parameters (binary omitted)\n\
$res = [[tpinitParams()|tpinit_params]]("name", "", "my_password", "", Tuxedo::TPU_IGN | Tuxedo::TPSA_FASTPATH, $bin, $params);\n\
\n\
... handle $res\n\
\x3C/code\x3E\x3C/pre\x3E\n\
\n\
\n\
*Notes:*\n\
* [[tpinit()]] could be used when no parameters are needed.\n\
* [[tpchkauth()]] should use the same settings.\n\
* [[tpterm()]] is used to close the connection to Tuxedo.\n\
\n\
\x3Csmall\x3E/Created on 2006-10-18./\x3C/small\x3E',
'',
'= TuxedoAdapter\n\
TuxedoAdapter Class\n\
\n\
The TuxedoAdapter class is used to communicate with Tuxedo servers. Detailed description of Tuxedo interface can be found on Tuxedo 9.1 reference and related pages. TuxedoAdapter class provides multithread safe wrapper over the messaging part of the Tuxedo API. Constants from Tuxedo API (like {{{TPAPPAUTH}}}) are all exposed in the {{{Tuxedo}}} namespace.\n\
\n\
\n\
{|\n\
|+ TuxedoAdapter Class Overview\n\
| *Method* || *Description*\n\
| [[TuxedoAdapter::constructor()]] || Creates the Tuxedo adapter based on parameters passed as a hash.\n\
| [[TuxedoAdapter::destructor()]] || Destroys the TuxedoAdapter object.\n\
| [[TuxedoAdapter::copy()]] || Copying objects of this class is not supported, an exception will be thrown.\n\
| [[TuxedoAdapter::call()]] || Calls a Tuxedo service, returns the reply.\n\
| [[TuxedoAdapter::asyncCall()]] || Calls an Tuxedo service and returns immediatelly The reply can be retrieved later.\n\
| [[TuxedoAdapter::waitForAsyncReply()]] || Waits for a reply for an asynchronous call.\n\
| [[TuxedoAdapter::cancelAsyncCall()]] || Cancels reply from an asynchonous call.\n\
| [[TuxedoAdapter::enqueue()]] || Puts data into a Tuxedo queue.\n\
| [[TuxedoAdapter::dequeue()]] || Retrieves data from a Tuxedo queue.\n\
| [[TuxedoAdapter::joinConversation()]] || Opens new communication with a Tuxedo service in conversational mode.\n\
| [[TuxedoAdapter::breakConversation()]] || Forcibly closes a communication in conversational mode.\n\
| [[TuxedoAdapter::sendConversationData()]] || Sends data to a Tuxedo service in conversational mode.\n\
| [[TuxedoAdapter::receiveConversationData()]] || Retrieves data from a Tuxedo service in conversational mode.\n\
| [[TuxedoAdapter::openResourceManager()]] || Connects with the Tuxedo (not TX) resource manager.\n\
| [[TuxedoAdapter::closeResourceManager()]] || Disconnects from the Tuxedo (not TX) resource manager.\n\
| [[TuxedoAdapter::openTxResourceManager()]] || Connects with the X/Open (TX) compatible resource manager.\n\
| [[TuxedoAdapter::closeTxResourceManager()]] || Disconnects from the X/Open (TX) compatible resource manager.\n\
| [[TuxedoAdapter::beginTransaction()]] || Starts a Tuxedo transaction.\n\
| [[TuxedoAdapter::commitTransaction()]] || Commits a Tuxedo transaction.\n\
| [[TuxedoAdapter::abortTransaction()]] || Rolls back a Tuxedo transaction.\n\
| [[TuxedoAdapter::suspendTransaction()]] || Temporarily suspends a Tuxedo transaction.\n\
| [[TuxedoAdapter::resumeTransaction()]] || Resumes suspended Tuxedo transaction.\n\
| [[TuxedoAdapter::isTransactionRunning()]] || Returns information whether a Tuxedo transaction is currently active.\n\
| [[TuxedoAdapter::finishCommitAfterDataLogged()]] || Sets a commit protocol used by the Tuxedo transaction.\n\
| [[TuxedoAdapter::finishCommitAfterTwoPhaseCompletes()]] || Sets a commit protocol used by the Tuxedo transaction.\n\
| [[TuxedoAdapter::beginTxTransaction()]] || Starts a X/Open compatible transaction.\n\
| [[TuxedoAdapter::commitTxTransaction()]] || Commits a X/Open compatible transaction.\n\
| [[TuxedoAdapter::abortTxTransaction()]] || Rolls back a X/Open compatible transaction.\n\
| [[TuxedoAdapter::finishTxCommitAfterDataLogged()]] || Sets a commit protocol used by the X/Open compatible transaction.\n\
| [[TuxedoAdapter::finishTxCommitAfterTwoPhaseCompletes()]] || Sets a commit protocol used by the X/Open compatible transaction.\n\
| [[TuxedoAdapter::setChainedTxTransactions()]] || Finishing one X/Open compatible transaction will automatically start the next one.\n\
| [[TuxedoAdapter::setUnchainedTxTransactions()]] || Each X/Open compatible transaction needs to be started explicitly.\n\
| [[TuxedoAdapter::setTxTransactionTimeout()]] || Sets timeout for X/Open compatible transaction commit.\n\
| [[TuxedoAdapter::setStringEncoding()]] || Sets the string encoding for the object; any strings serialized and deserialized with this object will be tagged with this character encoding.\n\
| [[TuxedoAdapter::error2string()]] || Converts numeric Tuxedo error code into a descriptive text.\n\
| [[TuxedoAdapter::writeToLog()]] || Writes a message into Tuxedo log file.\n\
| [[TuxedoAdapter::lastErrorDetails()]] || Returns details (an error code) for the last failed Tuxedo call.\n\
| [[TuxedoAdapter::getPriority()]] || Returns numeric priority used by Tuxedo.\n\
| [[TuxedoAdapter::setPriority()]] || Sets numeric priority used by Tuxedo.\n\
| [[TuxedoAdapter::postEvent()]] || Generates a Tuxedo event.\n\
|}\n\
',
'= constructor()\n\
*Synopsis*\n\
Creates the TuxedoAdapter instance based on the passed settings.\n\
\n\
*Usage*\n\
{{{TuxedoAdapter::constructor(settings)}}}\n\
\n\
The passed settings ([[TuxedoAdapter::constructor() Hash]]) could and should to set up all relevant parameters to connect a Tuxedo server. The environment variables, used by Tuxedo C API don\'t need to be set explicitly. They will be examined if and only if their equivalent is not present among the settings. See [[tpinit()]] documentation for details. All recognized settings are listed in the table TuxedoAdapter::constructor() settings bellow. The settings names are case insensitive. Unrecognized settings result in the exception {{{TUXEDO-ADAPTER-CONSTRUCTOR}}}. At least {{{TUXDIR}}} and {{{TUXCONFIG}}} settings need to be specified explicitly (either through the hash or with environment variables). For settings not set explicitly, defaults are used.\n\
\n\
*Return Value*\n\
Object: The newly created TuxedoAdapter object\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-CONSTRUCTOR}}}: Invalid or unrecognized value of settings\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.',
'= destructor()\n\
*Synopsis*\n\
Destroys the TuxedoAdapter object. All pending asynchronous calls are cancelled, all opened conversations are forcibly stopped, the connection to Tuxedo is terminated.\n\
\n\
*Usage*\n\
{{{delete }}}/lvalue/\n\
\n\
*Exceptions*\n\
This method does not throw any exceptions.',
'= constructor() Hash\n\
{|\n\
|+ TuxedoAdapter::constructor() Options Hash\n\
| *Value* || *Type* || *Description* || *Default*\n\
| TUXDIR || {{{String}}} || Full path to the directory where Tuxedo is installed. Environment variable TUXDIR is used if this value is not present among the settings || required explicitly\n\
| TUXCONFIG || {{{String}}} || Full path to the configuration file used by this TuxedoAdapter instance. Environment variable TUXCONFIG is used if this value is not present among the settings || required explicitly\n\
| UserName || {{{String}}} || User name to connect the Tuxedo server. See [[tpinit()]] documentation for details. || empty string\n\
| Password || {{{String}}} || Password required to connect the Tuxedo server. See [[tpinit()]] documentation for details. || empty string\n\
| ClientName || {{{String}}} || Client name to connect the Tuxedo server. See [[tpinit()]] documentation for details. || empty string\n\
| GroupName || {{{String}}} || Group name to connect the Tuxedo server. See [[tpinit()]] documentation for details. || empty string\n\
| BinaryConnectionData || {{{Binary}}} || Binary data that are passed to the Tuxedo server during connection. See tpinit() documentation for details. || no data passed\n\
| ConnectionFlags || {{{Integer}}} || Flags passed to the tpinit(). The flag TPMULTICONTEXT (the application may have several connection at the same time) is set automatically || {{{TPMULTICONTEXT}}} (always set)\n\
| StringEncoding || {{{String}}} || Encoding used for all sent and retrieved strings. || \'UTF8\'\n\
| DefaultFlagsForCall || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::call()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::call()]] requires the \'flags\' parameter. See [[tpcall()]] documentation for details. || n/a\n\
| DefaultFlagsForAsyncCall || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::asyncCall()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::asyncCall()]] requires the \'flags\' parameter. See [[tpacall()]] documentation for details. || n/a\n\
| DefaultFlagsForWaitForAsyncReply || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::waitForAsyncReply()]] does not specify them explicitly. If this settings is not present the TuxedoAdapter::waitForAsyncReply() requires the \'flags\' parameter. See [[tpgetrply()]] documentation for details. || n/a\n\
| DefaultFlagsForPostEvent || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::postEvent()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::postEvent()]] requires the \'flags\' parameter. See [[tppost()]] documentation for details. || n/a\n\
| DefaultFlagsForJoinConversation || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::joinConversation()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::joinConversation()]] requires the \'flags\' parameter. See [[tpconnect()]] documentation for details. || n/a\n\
| DefaultFlagsForSendConversationData || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::sendConversationData()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::sendConversationData()]] requires the \'flags\' parameter. See [[tpsend()]] documentation for details. || n/a\n\
| DefaultFlagsForReceiveConversationData || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::receiveConversationData()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::receiveConversationData()]] requires the \'flags\' parameter. See [[tprecv()]] documentation for details. || n/a\n\
| DefaultFlagsForEnqueue || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::enqueue()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::enqueue()]] requires the \'flags\' parameter. See [[tpenqueue()]] documentation for details. || n/a\n\
| DefaultFlagsForDequeue || {{{Integer}}} || Flags used as a default when the [[TuxedoAdapter::dequeue()]] does not specify them explicitly. If this settings is not present the [[TuxedoAdapter::dequeue()]] requires the \'flags\' parameter. See [[tpdequeue()]] documentation for details. || n/a\n\
| DefaultFmlType || {{{String}}} || Either \'FML\' or \'FML32\'.  Selects into which FML type Hash data will be serialized if no direct hint is given. If this settings is not present then any function serializing Hash data requires explicit hint about the result FML type. || \'FML32\'\n\
| DefaultFmlDescriptionFile || {{{String}}} || If used it should be full file path to a text file formatted according to FML description file specification. This file should describe all FML data used by this instance of TuxedoAdapter. The file is read only during construction of the adapter. This settings is mutually exclusive with DefaultFmlDescription (description provided in a Hash). || n/a\n\
| DefaultFmlDescription || {{{Hash}}} || Description of all FML data used by this instance of TuxedoAdapter. The key is FML item name, the value is integer (e.g. FLD_STRING) specifying the type. This settings is mutually exclusive with DefaultFmlDescriptionFile (description provided in a file). See FML description file specification for details. || n/a\n\
| DefaultFmlDescriptionBase || {{{Integer}}} || Base offset of the FML items specified by the DefaultFmlDescription. Used only when DefaultFmlDescription is also specified. For details see FML description file specification. || 0\n\
| DefaultFml32DescriptionFile || {{{String}}} || If used it should be full file path to a text file formatted according to FML32 description file specification. This file should describe all FML32 data used by this instance of TuxedoAdapter. The file is read only during construction of the adapter. This settings is mutually exclusive with DefaultFml32Description (description provided in a Hash). || n/a\n\
| DefaultFml32Description || {{{Hash}}} || Description of all FML32 data used by this instance of TuxedoAdapter. The key is FML32 item name, the value is integer (e.g. FLD_STRING) specifying the type. This settings is mutually exclusive with DefaultFml32DescriptionFile (description provided in a file). See FML32 description file specification for details. || n/a\n\
| DefaultFml32DescriptionBase || {{{Integer}}} || Base offset of the FML32 items specified by the DefaultFmlDescription. Used only when DefaultFml32Description is also specified. For details see FML32 description file specification. || 0\n\
| Priority || {{{Integer}}} (1..100) || Default Priority used for communication with Tuxedo servers. [[TuxedoAdapter::setPriority()]] can be used later to change the priority again. See [[tpspprio()]] documentation for details. || set in configuration file\n\
| WhenCommitFinishes || {{{String}}} || either \'AfterDataAreLogged\' or \'AfterTwoPhaseCompletes\'.  Specifies which mechanism is used when Tuxedo transaction (NOT TX transaction) commits. The settings could be changed later by [[TuxedoAdapter::finishCommitAfterDataLogged()]] or [[TuxedoAdapter::finishCommitAfterTwoPhaseCompletes()]]. See [[tpscmt()]] documentation for details. || set in configuration file\n\
| WhenTxCommitFinishes || {{{String}}} || Either \'AfterDataAreLogged\' or \'AfterTwoPhaseCompletes\'.  Specifies which mechanism is used when X/Open (TX) transaction commits. The settings could be changed later by [[TuxedoAdapter::finishTxCommitAfterDataLogged()]] or [[TuxedoAdapter::finishTxCommitAfterTwoPhaseCompletes()]]. See [[tx_set_commit_return()]] documentation for details. || \'AfterTwoPhaseCompletes\'\n\
| AreTxTransactionsChained || {{{Boolean}}} || Specifies whether a new X/Open (TX) transaction starts automatically after commit or rollback (when value is True) or whether it needs to be started explicitly by [[TuxedoAdapter::beginTxTransaction()]] (when value is False). See [[tx_set_transaction_control()]] documentation for details. || False\n\
| WSENVFILE || {{{String}}} || Equivalent of {{{WSENVFILE}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSNADDR || {{{String}}} || Equivalent of {{{WSNADDR}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSFADDR || {{{String}}} || Equivalent of {{{WSFADDR}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSFRANGE || {{{String}}} || Equivalent of {{{WSFRANGE}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSDEVICE || {{{String}}} || Equivalent of {{{WSDEVICE}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSTYPE || {{{String}}} || Equivalent of {{{WSTYPE}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| WSRPLYMAX || {{{String}}} || Equivalent of {{{WSRPLYMAX}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| TMMINENCRYPTBITS || {{{String}}} || Equivalent of {{{TMMINENCRYPTBITS}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
| TMMAXENCRYPTBITS || {{{String}}} || Equivalent of {{{TMMAXENCRYPTBITS}}} environment variable described in [[tpinit()]] documentation. || empty string\n\
|}',
'= copy()\n\
*Synopsis*\n\
Copying objects of this class is not supported, an exception will be thrown.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-COPY-ERROR}}}: objects of this class may not be copied',
'= call()\n\
*Synopsis*\n\
Invokes a Tuxedo service, waits for the reply and converts it into returned data structure. See tpcall() documentation for details.\n\
\n\
*Usage*\n\
{{{TuxedoAdapter:call(service name, data [, flags])}}}\n\
\n\
* service name: String: As defined in configuration file (TUXCONFIG).\n\
* data: NOTHING,String, Binary or Hash: Data serialized into the Tuxedo format and passed to the service. Hash is converted either into FML or FML32, based on the hint in \'flags\' or on the settings \'DefaultFmlType\' passed into the constructor.\n\
* [flags]: Integer or Hash: If the value is Integer then it is equivalent with flags used by [[tpcall()]]. A hash value may contrain following items: bool value \'use_fml32\' (whether to process Hash data as FML or FML32), integer value \'flags\' (the same as for [[tpcall()]]) and string value \'DefaultReturnedDataType\' (allowed values \'CARRAY\', \'STRING\', \'FML\' or \'FML32\') giving a hint of output data type. If the TuxedoAdapter constructor did not specified \'DefaultFlagsForCall\' settings then the \'flags\' needs to be present (either as the Integer or part of the Hash).\n\
\n\
*Return Value*\n\
String, Binary or Hash: Received reply converted into a Qore datatype. FML and FML32 are encoded into the Hash.\n\
\n\
*Exceptions*\n\
{{{TUXEDO-ADAPTER-CALL}}}: Invalid parameter.\n\
{{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash parameter has a member \'error\' with Tuxedo error code.',
'= asyncCall()\n\
*Synopsis*\n\
Invokes a Tuxedo service asynchronously, without waiting for the reply. See [[tpacall()]] documentation for details. To retrieve the reply use [[TuxedoAdapter::waitForAsyncReply()]] or cancel the pending reply with [[TuxedoAdapter::cancelAsyncCall()]]. The same service may be called either synchronously with [[TuxedoAdapter::call()]] or asynchronously.\n\
\n\
*Usage*\n\
{{{TuxedoAdapter:asyncCall(service name, data [, flags])}}}\n\
\n\
*service name: String: As defined in configuration file (TUXCONFIG).\n\
* data:NOTHING, String, Binary or Hash: Data serialized into the Tuxedo format and passed to the service. Hash is converted either into FML or FML32, based on the hint in \'flags\' or on the settings \'DefaultFmlType\' passed into the constructor.\n\
* [flags]: Integer or Hash: If the value is Integer then it is equivalent with flags used by the [[tpacall()]]. Hash value may contain following items: bool value \'use_fml32\' (whether to process Hash data as FML or FML32), integer value \'flags\' (the same as for [[tpacall()]]) and If the TuxedoAdapter constructor did not specified \'DefaultFlagsForAsyncCall\' settings then the \'flags\' needs to be present (either as the Integer or part of the Hash).\n\
\n\
*Return Value*\n\
Integer: Handle used to later retrieve the pending reply with [[TuxedoAdapter::waitForAsyncReply()]]. To cancel the call [[TuxedoAdapter::cancelAsyncCall()]]. All pending asynchronous calls are automatically cancelled when the TuxedoAdapter instance is destroyed.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-ASYNC-CALL}}}: Invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.',
'= waitForAsyncReply()\n\
*Synopsis*\n\
Waits for reply started by [[TuxedoAdapter::asyncCall()]] and not cancelled by [[TuxedoAdapter::cancelAsyncCall()]]. See [[tpgetrply()]] documentation for details. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter::waitForAsyncReply(handle, [flags])}}}\n\
\n\
* handle: Integer: The value returned by [[TuxedoAdapter::asyncCall()]] and not yet canceled or used in another [[TuxedoAdapter::waitForAsyncReply()]].\n\
* [flags]: Integer or Hash: Integer with values as described in [[tpacall()]] documentation. The Hash may contain: string value \'DefaultReturnedDataType\' (valid values are \'CARRAY\', \'STRING\', \'FML\', \'FML32\') which provides hint about output data type (Tuxedo may ignore this hint) and integer \'flags\' (the same as for [[tpgetrply()]]). If the TuxedoAdapter constructor did not specified \'DefaultFlagsForwaitForAsyncReply\' settings then the \'flags\' needs to be present (either as the integer or part of the hash).\n\
\n\
*Return Value*\n\
String, Binary or Hash: Received reply converted into a Qore type.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-WAIT-FOR-ASYNC-REPLY}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.',
'= cancelAsyncCall()\n\
*Synopsis*\n\
Cancels asynchronous call to a Tuxedo service started by the [[TuxedoAdapter::asyncCall()]] See [[tpcancel()]] documentation for details. When a TuxedoAdapter object is destroyed all pending asynchronous calls are cancelled automatically. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter::cancelAsyncCall(handle)}}}\n\
\n\
* handle: 	Integer: The value returned by [[TuxedoAdapter::asyncCall()]], neither canceled nor used by a [[TuxedoAdapter::waitForAsyncReply()]].\n\
\n\
*Return Value*\n\
This method does not return any value.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-CANCEL-ASYNC-CALL}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
',
'= enqueue()\n\
*Synopsis*\n\
Puts data into a Tuxedo queue. For details see [[tpenqueue()]].\n\
\n\
*Usage*\n\
{{{TuxedoAdapter::enqueue(queue space, queue name, data [, flags])}}}\n\
\n\
* queue space: String: Queue identifier #1.\n\
* queue name: String: Queue identifier #2.\n\
* data: NOTHING, String, Binary or Hash: Data serialized into the Tuxedo format and put to the queue. Hash is converted either into FML or FML32, based on the hint in \'flags\' or on the settings \'DefaultFmlType\' passed into the constructor.\n\
* [flags]: Integer or Hash: Integer with values as described in [[tpenqueue()]] documentation. The Hash may contain: bool value \'use_fml32\' (hint whether Hash data are converted into FML or FML32), integer value \'flags\' (the same as for [[tpenqueue()]]), integer queue control parameters \'queue_control_flags, \'queue_control_deq_time\', \'queue_control_priority\', \'queue_control_exp_time\', \'queue_control_delivery_qos\', queue_control_reply_qos\', \'queue_control_urcode\' and binary queue parameters queue_control_msgid\', \'queue_control_corrid\'. See [[tpenqueue()]] documentation for details on queue control parameters. If the TuxedoAdapter constructor did not specified \'DefaultFlagsForEnqueue\' settings then the \'flags\' needs to be present (either as the integer or part of the hash).\n\
\n\
*Return Value*\n\
Hash: Result of the operation is returned: binary value \'queue_control_msgid\' contains generated ID for the data put into the queue, integer value \'queue_control_diagnostic\' contains diagnostic of the [[tpenqueue()]] call. See [[tpenqueue()]] for details.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-ENQUEUE}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.',
'= dequeue()\n\
*Synopsis*\n\
Retrieves data from a Tuxedo queue. For details see [[tpdequeue()]]. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter::dequeue(queue space, queue name, [, flags])}}}\n\
\n\
* queue space: String: Queue identifier #1.\n\
* queue name: String: Queue identifier #2.\n\
* [flags]: Integer or Hash: Integer with values as described in [[tpdequeue()]] documentation. The Hash may contain: integer value \'flags\' (the same as for [[tpdequeue()]]), integer queue control parameter \'queue_control_flags\' and binary queue control parameters \'queue_control_msgid\' and \'queue_control_corrid\'. If the TuxedoAdapter constructor did not specified \'DefaultFlagsForDequeue\' settings then the \'flags\' needs to be present (either as the integer or part of the hash).\n\
\n\
*Return Value*\n\
Hash: Result of the call: data fetched from the queue (the value named \'data\') and integer queue control parameters \'queue_control_flags\' and \'queue_control_priority\'. See tpdequeue() documentation for details.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-DEQUEUE}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
',
'= joinConversation()\n\
*Synopsis*\n\
Connects a Tuxedo service in conversational mode, if provided a data is sent. See [[tpconnect()]] for details. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter::joinConversation(service name, data [, flags])}}}\n\
\n\
* service name: String: As defined in configuration file (TUXCONFIG).\n\
* data: NOTHING,String, Binary or Hash: Data serialized into the Tuxedo format and passed to the service. Hash is converted either into FML or FML32, based on the hint in \'flags\' or on the settings \'DefaultFmlType\' passed into the constructor.\n\
* [flags]: Integer or Hash: If the value is Integer then it is equivalent with flags used by the [[tpconnect()]]. Hash value may contrain following items: bool value \'use_fml32\' (whether to process Hash data as FML or FML32) and integer value \'flags\' (the same as for [[tpconnect()]]). If the TuxedoAdapter constructor did not specified \'DefaultFlagsForJoinConversation\' settings then the \'flags\' needs to be present (either as the Integer or part of the Hash).\n\
\n\
*Return Value*\n\
Integer: Descriptor of the established conversation. The descriptor is used by [[TuxedoAdapter::sendConversationData()]], [[TuxedoAdapter::receiveConversationData()]] and [[TuxedoAdapter::breakConversation()]]. When the TuxedoAdapter instance gets destroyed all remaining opened conversations are broken automatically. \n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-JOIN-CONVERSATION}}}: invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
',
'= breakConversation()\n\
\n\
*Synopsis*\n\
Forcibly breaks an established conversational mode. See [[tpdiscon()]] documentation for details. This is NOT the recomended way to close such a connection. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter::breakConversation(conversation descriptor)}}}\n\
* conversation descriptor: Integer: A valid conversation descriptor returned by [[TuxedoAdapter::joinConversation()]].\n\
\n\
*Return Value*\n\
This method doesn\'t return any value. \n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-BREAK-CONVERSATION}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
',
'= sendConversationData()\n\
*Synopsis*\n\
Sends data in conversational mode. See [[tpsend()]] for details. \n\
\n\
*Usage*\n\
{{{TuxedoAdapter:sendConversationData(conversation descriptor, data [, flags])}}}\n\
\n\
* conversation descriptor: Integer: A valid descriptor returned by [[TuxedoAdapter::joinConversation()]].\n\
* data: NOTHING,String, Binary or Hash: Data serialized into the Tuxedo format and passed to the service. Hash is converted either into FML or FML32, based on the hint in \'flags\' or on the settings \'DefaultFmlType\' passed into the constructor.\n\
* [flags]: Integer or Hash: If the value is Integer then it is equivalent with flags used by [[tpsend()]]. Hash value may contrain following items: bool value \'use_fml32\' (whether to process Hash data as FML or FML32) and integer value \'flags\' (the same as for [[tpsend()]]). If the TuxedoAdapter constructor did not specified \'DefaultFlagsForSendConversationData\' settings then the \'flags\' needs to be present (either as the Integer or part of the Hash).\n\
\n\
*Return Value*\n\
Integer: Event, indicating state of the conversation. See [[tpsend()]] documentation for allowed values and their interpretation.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-SEND-CONVERSATION-DATA}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
',
'= receiveConversationData()\n\
*Synopsis*\n\
Receive data in conversational mode. See [[tprecv()]] for details. \n\
\n\
*Usage*\n\
\n\
    TuxedoAdapter:receiveConversationData(conversation descriptor [, flags])\n\
\n\
Table 5.259. Arguments for TuxedoAdapter::receiveConversationData()\n\
\n\
Argument\n\
	\n\
\n\
Type\n\
	\n\
\n\
Description\n\
\n\
conversation descriptor\n\
	\n\
\n\
Integer\n\
	\n\
\n\
A valid descriptor returned by TuxedoAdapter::joinConversation().\n\
\n\
[flags]\n\
	\n\
\n\
Integer or Hash\n\
	\n\
\n\
If the value is Integer then it is equivalent with flags used by the tprecv(). Hash value may contrain following items: integer value \'flags\' (the same as for tprecv()) and string value \'DefaultReturnedDataType\' (allowed values \'CARRAY\', \'STRING\', \'FML\' or \'FML32\') giving a hint of output data type. If the TuxedoAdapter constructor did not specified \'DefaultFlagsForReceiveConversationData\' settings then the \'flags\' needs to be present (either as the Integer or part of the Hash).\n\
\n\
Table 5.260. Return Values for TuxedoAdapter::receiveConversationData()\n\
\n\
Return Type\n\
	\n\
\n\
Description\n\
\n\
Hash\n\
	\n\
\n\
The retrned Hash contains item \'data\' with received reply converted into a Qore datatype (FML and FML32 are encoded into a Hash) and item \'event\' indicating state of the conversation. See tprecv() documentation for details about the events.\n\
\n\
*Exceptions*\n\
* {{{TUXEDO-ADAPTER-RECEIVE-CONVERSATION-DATA}}}: Missing or invalid parameter.\n\
* {{{TUXEDO-ERROR}}}: A Tuxedo call failed. Hash exception parameter has member \'error\' with Tuxedo error code.\n\
'
];

/* DFQRCTsKlU-0000471-END */

/* ]]> */ </script>
<style type="text/css">/* existent link */

a.link {
  color: blue;
}
a.link:hover {
  text-decoration: underline;
}

/* unexistent link */
a.unlink {
  color: red;
}
a.unlink:hover {
  text-decoration: underline;
}

/* outside world link */
a.world {
  color: darkgreen;
  text-decoration: underline;
}

a {
	cursor: pointer;
	/* FOR IE5.5/IE6 */
	/* cursor: hand; */
}

/* Main text */
div.text_area {
  border-width: 1pt;
  border-color: grey;
  border-style: solid;
  background-color: white;
  padding: 10pt;
}

/* since v0.9 */
body { font-family: tahoma; }

h1 { font-size: 23px; }

h2 { font-size: 20px; }

h3 { font-size: 17px; }

h4 { font-size: 14px; }

h5 { font-size: 12px; }

h6 { font-size: 10px; }

div.taglinks {
	border: 1px solid #aaa;
/*	background-color: #f9f9f9; */
	padding: 5px;
	margin-top: 1em;
	clear: both;
}

div.search_results {
	border: 1px solid #aaa;
	background-color: #f9f9f9;
	padding: 5px;
	margin-top: 1em;
	clear: both;
}

a.link.tag {
  color: navy;
}

/* main wiki pane when locked */
div.text_area.locked,
#woas_pwd_mask {
	background-image: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAAAAACMmsGiAAAALHRFWHRDcmVhdGlvbiBUaW1lAGdpbyAyOSBtYXIgMjAwNyAxMTo1MToxMCArMDEwME%2BTNUAAAAAHdElNRQfXAx0JNByGxueSAAAACXBIWXMAAAsSAAALEgHS3X78AAAABGdBTUEAALGPC%2FxhBQAAABlJREFUeNpj%2FM%2FwmYHpMwMvAxOQwcvECyQBO1oE%2BlG5iisAAAAASUVORK5CYII%3D);
	background-color: #eeeeee;
}

div.menu {
}

/* page title */
.title {
  font-size: 24pt;
  font-weight: bold;
  margin-bottom: 0pt;
  margin-top: 0pt;
  display:inline;
}

.bg {
	background-color: #F0F0F5;
}

#wiki_text {
	position: relative;
	left: 16%;
	width: 81%;
	z-index: 0;
	top: -20px;
	text-align:justify;
}

table.text_area {
	border-color: black;
	border-spacing: 0px;
	border-style: solid; 
	border-width: 1px;
}

table.text_area td {
	border-style: solid; 	 
	border-width: 1px;	
	padding: 5px;
}

/* Left menu */
div.menu_area {
	border-width: 1pt;
	border-color: grey;
	border-style: solid;
	font-size: 9pt;
	background-color: white;
	padding: 5pt;
	width: 13%;
	left: 1%;
}

div.wiki_header {
	top: 0px;
	left: 0px;
	border: 1px solid #aaa;
	-moz-opacity:.75;opacity:.75;
	z-index: 1;
	width: 99%;
}

div.wiki_toc {
	border: 1px dashed #aaa;
	background-color: #f9f9f9;
	padding: 5px;
	width: 50%;
	font-size: 95%;
}

div.wiki_toc ol, li {
	margin-left: 0.65em;
	padding-left: 0em;
}

p.wiki_toc_title {
	font-weight: bold;
	text-align: center;
}

/* since v0.9.3 Beta */
.search_highlight { background-color: yellow; }

#loading_overlay {
	position: absolute;
	width: 100%;
	height: 100%;
	text-align: center;
	padding-top: 25%;
	z-index: 100;
	background-color: white;
	font-size: large;
	left: 0px;
	top: 0px;
	cursor: wait;
}

div.menu_area ul li, div.menu_area ol li,
div.ns_menu_area ul li, div.ns_menu_area ol li {
	margin-left: -2em;
}

/* since v0.9.4 Beta */
.wiki_preformatted {
	/* Mozilla, since 1999 */
	white-space: -moz-pre-wrap !important;
	/* css-3 */
/*	white-space: pre-wrap;*/
	/* Opera 4-6 */
/*	white-space: -pre-wrap;  */
	/* Opera 7 */
/*	white-space: -o-pre-wrap;  */
	/* Internet Explorer 5.5+ */
/*	word-wrap: break-word;     */
}

/* since v0.9.7B */

#woas_pwd_query {
    border: 1px solid #666666; 
    text-align: center;
    position: absolute;
    top: 50%;
    margin-top: -100px;
    left: 50%;
    margin-left: -150px;
 height: 100px;
width: 300px;
background-color: #d6dff7;
visibility: hidden;
z-index: 100;
}

#woas_pwd_mask {
	position: absolute;
	width: 100%;
	height: 100%;
	text-align: center;
	z-index: 99;
	visibility: hidden;
	font-size: large;
	left: 0px;
	top: 0px;
}

</style><title>Wiki on a Stick loading</title>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** aes.js ***/
// AES encryption for StickWiki
// adapted by legolas558
// license: GNU/GPL
// original code from http://home.versatel.nl/MAvanEverdingen/Code/
// this is a javascript conversion of a C implementation by Mike Scott

var bData;
var sData;
var aes_i;
var aes_j;
var tot;
var key = [];

var wMax = 0xFFFFFFFF;
function rotb(b,n){ return ( b<<n | b>>>( 8-n) ) & 0xFF; }
function rotw(w,n){ return ( w<<n | w>>>(32-n) ) & wMax; }
function getW(a,i){ return a[i]|a[i+1]<<8|a[i+2]<<16|a[i+3]<<24; }
function setW(a,i,w){ a.splice(i,4,w&0xFF,(w>>>8)&0xFF,(w>>>16)&0xFF,(w>>>24)&0xFF); }
function setWInv(a,i,w){ a.splice(i,4,(w>>>24)&0xFF,(w>>>16)&0xFF,(w>>>8)&0xFF,w&0xFF); }
function getB(x,n){ return (x>>>(n*8))&0xFF; }

	var utf8sets = [0x800,0x10000,0x110000];

	function unExpChar(c){
	  return "unexpected character '"+String.fromCharCode(c)+"' (code 0x"+c.toString(16)+").";
	}

	function utf8Encrypt(sData){
	  var k, i=0, z=sData.length;
	  var bData = [];
	  while (i<z) {
	    c = sData.charCodeAt(i++);
	    if (c<0x80){ bData.push(c); continue; }
	    k=0; while(k<utf8sets.length && c>=utf8sets[k]) k++;
	    if (k>=utf8sets.length) {
			alert("UTF-8: "+unExpChar(c));
			return null;
		}
		j=bData.length;
	    for (var n=j+k+1;n>j;n--){ bData[n]=0x80|(c&0x3F); c>>>=6; }
	    bData[j]=c+((0xFF<<(6-k))&0xFF);
	    j += k+2;
	  }
	  return bData;
	}

	function utf8Decrypt(bData){
	  var z=bData.length;
	  var c;
	  var k, d = 0, i = 0;
	  var sData = "";
	  while (i<z) {
	    c = bData[i++];
	    k=0; while(c&0x80){ c=(c<<1)&0xFF; k++; }
	    c >>= k;
	    if (k==1||k>4) {
	//		throw
			log('UTF-8: invalid first byte');	// log:1
			return null;
		}
	    for (var n=1;n<k;n++){
	      d = bData[i++];
	      if (d<0x80||d>0xBF) break;
	      c=(c<<6)+(d&0x3F);
	    }
	    if ( (k==2&&c<0x80) || (k>2&&c<utf8sets[k-3]) ) {
			log("UTF-8: invalid sequence");	// log:1
			return null;
		}
	    sData+=String.fromCharCode(c);
	  }
	  return sData;
	}

function split_bytes(s) {
	var l=s.length;
	var arr=[];
	for(var i=0;i<l;i++)
		arr.push(s.charCodeAt(i));
	return arr;
}
	
function merge_bytes(arr) {
	var l=arr.length;
	var s="";
	for(var i=0;i<l;i++)
		s+=String.fromCharCode(arr[i]);
	return s;
}

var aesNk;
var aesNr;

var aesPows;
var aesLogs;
var aesSBox;
var aesSBoxInv;
var aesRco;
var aesFtable;
var aesRtable;
var aesFi;
var aesRi;
var aesFkey;
var aesRkey;

function aesMult(x, y){ return (x&&y) ? aesPows[(aesLogs[x]+aesLogs[y])%255]:0; }

function aesPackBlock() {
  return [ getW(bData,aes_i), getW(bData,aes_i+4), getW(bData,aes_i+8), getW(bData,aes_i+12) ];
}

function aesUnpackBlock(packed){
  for ( var mj=0; mj<4; mj++,aes_i+=4) setW( bData, aes_i, packed[mj] );
}

function aesXTime(p){
  p <<= 1;
  return p&0x100 ? p^0x11B : p;
}

function aesSubByte(w){
  return aesSBox[getB(w,0)] | aesSBox[getB(w,1)]<<8 | aesSBox[getB(w,2)]<<16 | aesSBox[getB(w,3)]<<24;
}

function aesProduct(w1,w2){
  return aesMult(getB(w1,0),getB(w2,0)) ^ aesMult(getB(w1,1),getB(w2,1))
       ^ aesMult(getB(w1,2),getB(w2,2)) ^ aesMult(getB(w1,3),getB(w2,3));
}

function aesInvMixCol(x){
  return aesProduct(0x090d0b0e,x)     | aesProduct(0x0d0b0e09,x)<<8 |
         aesProduct(0x0b0e090d,x)<<16 | aesProduct(0x0e090d0b,x)<<24;
}

function aesByteSub(x){
  var y=aesPows[255-aesLogs[x]];
  x=y;  x=rotb(x,1);
  y^=x; x=rotb(x,1);
  y^=x; x=rotb(x,1);
  y^=x; x=rotb(x,1);
  return x^y^0x63;
}

function aesGenTables(){
  var i,y;
  aesPows = [ 1,3 ];
  aesLogs = [ 0,0,null,1 ];
  aesSBox = new Array(256);
  aesSBoxInv = new Array(256);
  aesFtable = new Array(256);
  aesRtable = new Array(256);
  aesRco = new Array(30);

  for ( i=2; i<256; i++){
    aesPows[i]=aesPows[i-1]^aesXTime( aesPows[i-1] );
    aesLogs[aesPows[i]]=i;
  }

  aesSBox[0]=0x63;
  aesSBoxInv[0x63]=0;
  for ( i=1; i<256; i++){
    y=aesByteSub(i);
    aesSBox[i]=y; aesSBoxInv[y]=i;
  }

  for (i=0,y=1; i<30; i++){ aesRco[i]=y; y=aesXTime(y); }

  for ( i=0; i<256; i++){
    y = aesSBox[i];
    aesFtable[i] = aesXTime(y) | y<<8 | y<<16 | (y^aesXTime(y))<<24;
    y = aesSBoxInv[i];
    aesRtable[i]= aesMult(14,y) | aesMult(9,y)<<8 |
                  aesMult(13,y)<<16 | aesMult(11,y)<<24;
  }
}

function aesInit(){
  key=key.slice(0,32);
  var i,k,m;
  var j = 0;
  var l = key.length;

  while ( l!=16 && l!=24 && l!=32 ) key[l++]=key[j++];
  aesGenTables();

  aesNk = key.length >>> 2;
  aesNr = 6 + aesNk;

  var N=4*(aesNr+1);
  
  aesFi = new Array(12);
  aesRi = new Array(12);
  aesFkey = new Array(N);
  aesRkey = new Array(N);

  for (m=j=0;j<4;j++,m+=3){
    aesFi[m]=(j+1)%4;
    aesFi[m+1]=(j+2)%4;
    aesFi[m+2]=(j+3)%4;
    aesRi[m]=(4+j-1)%4;
    aesRi[m+1]=(4+j-2)%4;
    aesRi[m+2]=(4+j-3)%4;
  }

  for (i=j=0;i<aesNk;i++,j+=4) aesFkey[i]=getW(key,j);

  for (k=0,j=aesNk;j<N;j+=aesNk,k++){
    aesFkey[j]=aesFkey[j-aesNk]^aesSubByte(rotw(aesFkey[j-1], 24))^aesRco[k];
    if (aesNk<=6)
      for (i=1;i<aesNk && (i+j)<N;i++) aesFkey[i+j]=aesFkey[i+j-aesNk]^aesFkey[i+j-1];
    else{
      for (i=1;i<4 &&(i+j)<N;i++) aesFkey[i+j]=aesFkey[i+j-aesNk]^aesFkey[i+j-1];
      if ((j+4)<N) aesFkey[j+4]=aesFkey[j+4-aesNk]^aesSubByte(aesFkey[j+3]);
      for (i=5;i<aesNk && (i+j)<N;i++) aesFkey[i+j]=aesFkey[i+j-aesNk]^aesFkey[i+j-1];
    }
  }

  for (j=0;j<4;j++) aesRkey[j+N-4]=aesFkey[j];
  for (i=4;i<N-4;i+=4){
    k=N-4-i;
    for (j=0;j<4;j++) aesRkey[k+j]=aesInvMixCol(aesFkey[i+j]);
  }
  for (j=N-4;j<N;j++) aesRkey[j-N+4]=aesFkey[j];
}

function aesClose(){
  aesPows=aesLogs=aesSBox=aesSBoxInv=aesRco=null;
  aesFtable=aesRtable=aesFi=aesRi=aesFkey=aesRkey=null;
}

function aesRounds( block, key, table, inc, box ){
  var tmp = new Array( 4 );
  var i,j,m,r;

  for ( r=0; r<4; r++ ) block[r]^=key[r];
  for ( i=1; i<aesNr; i++ ){
    for (j=m=0;j<4;j++,m+=3){
      tmp[j]=key[r++]^table[block[j]&0xFF]^
			rotw(table[(block[inc[m  ]]>>> 8)&0xFF], 8)^
			rotw(table[(block[inc[m+1]]>>>16)&0xFF],16)^
			rotw(table[(block[inc[m+2]]>>>24)&0xFF],24);
    }
    var t=block; block=tmp; tmp=t;
  }

  for (j=m=0;j<4;j++,m+=3)
    tmp[j]=key[r++]^box[block[j]&0xFF]^
           rotw(box[(block[inc[m  ]]>>> 8)&0xFF], 8)^
           rotw(box[(block[inc[m+1]]>>>16)&0xFF],16)^
           rotw(box[(block[inc[m+2]]>>>24)&0xFF],24);
  return tmp;
}

function aesEncrypt(){
  aesUnpackBlock( aesRounds(aesPackBlock(), aesFkey, aesFtable, aesFi, aesSBox ) );
}

function aesDecrypt(){
  aesUnpackBlock( aesRounds(aesPackBlock(), aesRkey, aesRtable, aesRi, aesSBoxInv ) );
}

// Blockcipher

function blcEncrypt(enc){
  if (tot==0){
//    prgr = name;
    if (key.length<1) return;
    //if (cbc)
	for (aes_i=0; aes_i<16; aes_i++) bData.unshift( _rand(256) );
    while( bData.length%16!=0 ) bData.push(0);
    tot = bData.length;
    aesInit();
  }else{
    //if (cbc)
	for (aes_j=aes_i; aes_j<aes_i+16; aes_j++) bData[aes_j] ^= bData[aes_j-16];
    enc();
  }
  if (aes_i>=tot) aesClose();
}

function blcDecrypt(dec){
  if (tot==0){
//    prgr = name;
    if (key.length<1) return;
    //if (cbc)
	{ aes_i=16; }
    tot = bData.length;
    if ( (tot%16) || tot<aes_i ) throw 'AES: Incorrect length (tot='+tot+', aes_i='+aes_i+')';
    aesInit();
  }else{
    //if (cbc)
	aes_i=tot-aes_i;
    dec();
    //if (cbc)
{
      for (aes_j=aes_i-16; aes_j<aes_i; aes_j++) bData[aes_j] ^= bData[aes_j-16];
      aes_i = tot+32-aes_i;
    }
  }
  if (aes_i>=tot){
    aesClose();
    //if (cbc)
	bData.splice(0,16);
	while(bData[bData.length-1]==0) bData.pop();
  }
}

// sets global key to the utf-8 encoded key
function AES_setKey(sKey) {
	key = utf8Encrypt(sKey);
//	key = split_bytes(sKey);
}

function AES_clearKey() {
	key = [];
}

// returns an array of encrypted characters
function AES_encrypt(raw_data) {
	
	bData = utf8Encrypt(raw_data);
	
	aes_i=tot=0;
	do{ blcEncrypt(aesEncrypt); } while (aes_i<tot);
	
	return bData;
}

// decrypts an array of encrypted characters
function AES_decrypt(raw_data) {
	bData = raw_data;
	
	aes_i=tot=0;
	do{ blcDecrypt(aesDecrypt); } while (aes_i<tot);
	
	sData = utf8Decrypt(bData);
	bData = [];
	return sData;
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** framework.js ***/

woas["debug"] = false;			// toggle debug mode (and console)

var _doctype = "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.1//EN\" \"http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd\">\n";

// browser flags - not to be in WoaS object
var ie = false;
var ie6 = false;
var firefox = false;
//var ff3 = false;
var opera = false;

if((navigator.userAgent).indexOf("Opera")!=-1)
	opera = true;
else if(navigator.appName == "Netscape") {
	firefox = true;
//	if (navigator.userAgent.match("Firefox/3"))
//		ff3 = true;
} else if((navigator.appName).indexOf("Microsoft")!=-1) {
	ie = true;
	ie6 = (navigator.userAgent.search(/msie 6\./i)!=-1);
}

// finds out if Opera is trying to look like Mozilla
if (firefox && (navigator.product != "Gecko"))
	firefox = false;

// finds out if Opera is trying to look like IE
if (ie && opera)
	ie = false;
	
var is_windows = (navigator.appVersion.toLowerCase().indexOf("windows")!=-1);

woas["_server_mode"] = (document.location.toString().match(/^file:\/\//) ? false:true);

// returns the DOM element object given its id
function $(id){return document.getElementById(id);}

$["hide"] = function(id) {
	$(id).style.display = "none";
	$(id).style.visibility = "hidden";
}

$["show"] = function(id) {
	$(id).style.display = "inline";
	$(id).style.visibility = "visible";
}

// logging function has not to be in WoaS object
var log;
if (woas.debug) {
	// logging function - used in development
	log = function (aMessage)
	{
	    var logbox = $("swlogger");
		nls = logbox.value.match(/\n/g);
		if (nls!=null && typeof(nls)=='object' && nls.length>11)
			logbox.value = "";
		logbox.value += aMessage + "\n";
	};
} else {
	log = function(aMessage) { };
}

// fixes the Array prototype for older browsers
if (typeof Array.prototype.push == "undefined") {
  Array.prototype.push = function(str) {
    this[this.length] = str;
  }
}

// the following methods complete the Array object for non-compliant browsers
if (typeof Array.prototype.splice == "undefined") {
  Array.prototype.splice = function(offset, length) {
    var temp = [];
    for (var i = this.length - 1; i >= 0; i--) {
      if (i < offset || i > (offset + length - 1)) {
        temp[temp.length] = this[i];
      }
      this.length--;
    }
    for (i = temp.length - 1; i >= 0; i--) {
      this[this.length] = temp[i];
    }
  }
}

if (typeof Array.prototype.indexOf == "undefined") {
	Array.prototype.indexOf = function(val, fromIndex) {
		if (typeof(fromIndex) != 'number') fromIndex = 0;
		for (var index = fromIndex,len = this.length; index < len; index++)
			if (this[index] == val) return index;
		return -1;
	}
}

// implements a custom function which returns an array with unique elements - deprecated
Array.prototype.toUnique = function() {
	var a_o = {}, new_arr = [];
	var l=this.length;
	for(var i=0; i<l;i++) {
		if (a_o[this[i]]==null) {
			a_o[this[i]] = true;
			new_arr.push(this[i]);
		}
	}
	if (new_arr.length!=l)
		return new_arr;
	return this;
}

// provide regex escaping
// thanks to S.Willison
RegExp.escape = function(text) {
  if (!arguments.callee.sRE) {
    var specials = [
      '/', '.', '*', '+', '?', '|', '$',
      '(', ')', '[', ']', '{', '}', '\\'
    ];
    arguments.callee.sRE = new RegExp(
      '(\\' + specials.join('|\\') + ')', 'g'
    );
  }
  return text.replace(arguments.callee.sRE, '\\$1');
}

// repeat string s for n times
function str_rep(s, n) {
	var r = "";
	while (--n >= 0) r += s;
	return r;
}

// return a random integer given the maximum value (scale)
function _rand(scale) {
	return Math.floor(Math.random() * scale);
}

// returns a random string of given string_length
function _random_string(string_length) {
	var chars = "ABCDEFGHIJKLMNOPQRSTUVWXTZabcdefghiklmnopqrstuvwxyz";
	var randomstring = '';
	for (var i=0; i<string_length; i++) {
		var rnum = _rand(chars.length);
		randomstring += chars.charAt(rnum);
	}
	return randomstring;
}

// format a decimal number to specified decimal precision
function _number_format(n, prec) {
	return n.toString().replace(new RegExp("(\\."+str_rep("\\d", prec)+")\\d*$"), "$1");
}

// converts the number of bytes to a human readable form
function _convert_bytes(bytes) {
//	log("Converting "+bytes+" bytes");	// log:0
	if (bytes < 1024)
		return Math.ceil(bytes)+ " bytes";
	var k = bytes / 1024, n;
	if (k >= 1024) {
		var m = k / 1024;
		if (m >= 1024)
			n = _number_format(m/1024,2)+' GB';
		else
			n = _number_format(m,2)+' MB';
	} else
		n = _number_format(k,2)+' KB';
	return n.replace(/\.00/, "");
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** loadsave.js ***/

function _get_this_filename() {
	var filename = unescape(document.location.toString().split("?")[0]);
	if (filename.indexOf("file://") === 0) // all browsers
		filename = filename.substr(7);
	if (filename.indexOf("///")===0) // firefox
		filename = filename.substr(1);
	filename = filename.replace(/#.*$/g, ""); // remove fragment
	if (is_windows) {
		// convert unix path to windows path
		filename = filename.replace(/\//g, "\\");
		if (filename.substr(0,2)!="\\\\") { // if this is not a network path - will be true in case of Firefox for example
			// remove leading slash before unit:
			if (filename.match(/^\\\w:\\/))
				filename = filename.substr(1);
			if (filename.charAt(1)!=':') {
				if (ie)
					filename = "\\\\"+filename;
			}
		}
	}
	return filename;
}

//alert(_get_this_filename());

function _saveThisFile(new_data, old_data) {
	var filename = _get_this_filename();
	
	r = saveFile(filename,
	_doctype+"<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n<head>\n"+
	"<meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n"+
	"<sc"+"ript type=\"text/javascript\">" + new_data + "\n" + old_data + "</html>");
	if (r==true)
		log("\""+filename+"\" saved successfully");	// log:1
	else
		alert("Save to file \""+filename+"\" failed!\n\nMaybe your browser is not supported");
	return r;
}

function saveFile(fileUrl, content)
{
	var r = null;
	r = mozillaSaveFile(fileUrl, content);
	if((r == null) || (r == false))
		r = ieSaveFile(fileUrl, content);
	if((r == null) || (r == false))
		r = javaSaveFile(fileUrl, content);
	return r;
}

// original source was from TiddyWiki

function loadFile(fileUrl)
{
	var r = null;
	if((r == null) || (r == false))
		r = mozillaLoadFile(fileUrl);

	log("mozillaLoadFile() returned " + r);

	if((r == null) || (r == false))
		r = ieLoadFile(fileUrl);
	if((r == null) || (r == false))
		r = operaLoadFile(fileUrl);
	return r;
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function ieSaveFile(filePath, content)
{
	try
	{
		var fso = new ActiveXObject("Scripting.FileSystemObject");
	}
	catch(e) {
		log("Exception while attempting to save: " + e.toString());	// log:1
		return(false);
	}
/*	if (_force_binary) {
		alert("Binary write with Internet Explorer is not supported");
		return false;
	}	*/
	var mode = _force_binary ? -1:0;
	var file = fso.OpenTextFile(filePath,2,-1, mode);
	file.Write(content);
	file.Close();
	return(true);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function ieLoadFile(filePath)
{
	try
	{
		var fso = new ActiveXObject("Scripting.FileSystemObject");
		var file = fso.OpenTextFile(filePath,1);
		var content = file.ReadAll();
		file.Close();
	}
	catch(e) {
		log("Exception while attempting to load\n\n" + e.toString());	// log:1
		return(null);
	}
	return(content);
}

// Returns null if it can't do it, false if there's an error, true if it saved OK
function mozillaSaveFile(filePath, content)
{
	if(window.Components)
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if (!file.exists())
				file.create(0, 0664);
			else
				log("File \""+filePath+"\" exists, overwriting");	// log:1
			var out = Components.classes["@mozilla.org/network/file-output-stream;1"].createInstance(Components.interfaces.nsIFileOutputStream);
			out.init(file, 0x20 | 0x02, 00004,null);
			out.write(content, content.length);
			out.flush();
			out.close();
			return(true);
		}
		catch(e)
		{
			log("Exception while attempting to save\n\n" + e);	// log:1
			return(false);
		}
	return(null);
}

// Returns null if it can't do it, false if there's an error, or a string of the content if successful
// Returns null if it can't do it, false if there's an error, or a string of the content if successful
function mozillaLoadFile(filePath)
{
   log("window.Components: " + (window.Components ? "true" : "false"));

	if(window.Components)
		try
		{
			netscape.security.PrivilegeManager.enablePrivilege("UniversalXPConnect");
			var file = Components.classes["@mozilla.org/file/local;1"].createInstance(Components.interfaces.nsILocalFile);
			file.initWithPath(filePath);
			if (!file.exists()) {
			   log("mozillaLoadFile(): file does not exist");
				return(null);
			}
			var inputStream = Components.classes["@mozilla.org/network/file-input-stream;1"].createInstance(Components.interfaces.nsIFileInputStream);
			inputStream.init(file, 0x01, 00004, null);
			var sInputStream = Components.classes["@mozilla.org/scriptableinputstream;1"].createInstance(Components.interfaces.nsIScriptableInputStream);
			sInputStream.init(inputStream);
			if (!_force_binary)
				return sInputStream.read(sInputStream.available());
			// this byte-by-byte read allows retrieval of binary files
			var tot=sInputStream.available(), i=tot;
			var rd=[];
			while (i-->=0) {
				var c=sInputStream.read(1);
				rd.push(c.charCodeAt(0));
			}
			return(merge_bytes(rd));
		}
		catch(e)
		{
			log("oh no, exception while attempting to load\n\n" + e);	// log:1
			log("error: " + e.toString());	// log:1
			return(false);
		}
	return(null);
}

function _javaUrlToFilename(url)
{
	var f = "//localhost";
	if(url.indexOf(f) == 0)
		return url.substring(f.length);
	var i = url.indexOf(":");
	if(i > 0)
		return url.substring(i-1);
	return url;
}

function javaSaveFile(filePath,content)
{
	try {
		if(document.applets["TiddlySaver"])
			return document.applets["TiddlySaver"].saveFile(_javaUrlToFilename(filePath),"UTF-8",content);
	} catch(ex) {
	}
	try {
		var s = new java.io.PrintStream(new java.io.FileOutputStream(_javaUrlToFilename(filePath)));
		s.print(content);
		s.close();
	} catch(ex) {
		if(window.opera) {
			opera.postError(e);
			return false;
		}
		return null;
	}
	return true;
}

function javaLoadFile(filePath)
{
	try {
		if(document.applets["TiddlySaver"])
			return String(document.applets["TiddlySaver"].loadFile(_javaUrlToFilename(filePath),"UTF-8"));
	} catch(ex) {
	}
	var content = [];
	try {
		var r = new java.io.BufferedReader(new java.io.FileReader(_javaUrlToFilename(filePath)));
		var line;
		while((line = r.readLine()) != null)
			content.push(new String(line));
		r.close();
	} catch(ex) {
		if(window.opera)
			opera.postError(e);
		log("Exception in javaLoadFile(\""+filePath+"\"): "+e)
		return null;
	}
	return content.join("\n");
}

// force binary file write
var _force_binary = false;

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** base64.js ***/
var _b64arr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";

function encode64(input) {
	var c1, c2, c3, enc1, enc2, enc3, enc4, i = 0, z = input.length;
	var output = "";
	
	do {
		c1 = input.charCodeAt(i++);
		c2 = input.charCodeAt(i++);
		c3 = input.charCodeAt(i++);

		enc1 = c1 >> 2;
		enc2 = ((c1 & 3) << 4) | (c2 >> 4);
		enc3 = ((c2 & 15) << 2) | (c3 >> 6);
		enc4 = c3 & 63;

		if (isNaN(c2))	enc3 = enc4 = 64;
		else if (isNaN(c3))
			enc4 = 64;

		output += _b64arr.charAt(enc1) + _b64arr.charAt(enc2) + _b64arr.charAt(enc3) +
		_b64arr.charAt(enc4);

	} while (i < z);
	return output;
}

function decode64(input, z) {
	var c1, c2, c3, enc1, enc2, enc3, enc4, i = 0;
	var output = "";
	
	var l=input.length;
	if (typeof z=='undefined') z = l;
	else if (z>l) z=l;

	do {
		enc1 = _b64arr.indexOf(input.charAt(i++));
		enc2 = _b64arr.indexOf(input.charAt(i++));
		enc3 = _b64arr.indexOf(input.charAt(i++));
		enc4 = _b64arr.indexOf(input.charAt(i++));

		c1 = (enc1 << 2) | (enc2 >> 4);
		c2 = ((enc2 & 15) << 4) | (enc3 >> 2);
		c3 = ((enc3 & 3) << 6) | enc4;

		output += String.fromCharCode(c1);
		if (enc3 != 64)
			output += String.fromCharCode(c2);
		if (enc4 != 64)
			output += String.fromCharCode(c3);

	} while (i < z);

	return output;
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** parser.js ***/

woas["parser"] = {
	"has_toc":null,
	"toc":"",
	"force_inline":false,		// used not to break layout when presenting search results
	"script_extension":[]	// external javascript files to be loaded
};

woas.parser["header_anchor"] = function(s) {
	// apply a hard normalization
	// WARNING: will not preserve header ids uniqueness
	return s.replace(/[^a-zA-Z0-9]/g, '_');
}

var reParseOldHeaders = /(^|\n)(\!+)\s*([^\n]+)/g;
var reParseHeaders = /(^|\n)(=+)\s*([^\n]+)/g;
woas.parser["header_replace"] = function(str, $1, $2, $3) {
		var header = $3;
		var len = $2.length;
		if (header.indexOf($2)==header.length - len)
			header = header.substring(0, header.length - len);
		// automatically build the TOC if needed
		if (woas.parser.has_toc) {
			woas.parser.toc += str_rep("#", len)+" <a class=\"link\" href=\"#" +
			woas.parser.header_anchor(header) + "\">" + header + "<\/a>\n";
		}
		return "</div><h"+len+" id=\""+woas.parser.header_anchor(header)+"\">"+header+"</h"+len+"><div class=\"level"+len+"\">";
}

woas.parser["sublist"] = function (lst, ll, suoro, euoro) {   
	if (!lst.length)
		return '';
	
	if (lst[0][1].length > ll)
		return this.sublist(lst, ll+1, suoro, euoro);
	
	var item, sub;
	var s = '';
	while (lst[0][1].length == ll ) {
                item = lst.shift();
                sub = this.sublist(lst, ll + 1, suoro, euoro);
                if (sub.length)
                    s += '<li>' + item[2] + suoro + sub + euoro + '</li>' ;
                else
                    s += '<li>' + item[2] + '</li>';
		if (!lst.length)
			break;
	}
	return s;  
}

// XHTML lists and tables parsing code by plumloco
// This is a bit of a monster, if you know an easier way please tell me!
// There is no limit to the level of nesting and it produces
// valid xhtml markup.
var reReapLists = /(?:^|\n)([\*#@])[ \t].*(?:\n\1+[ \t][^\n]+)*/g;
woas.parser["parse_lists"] = function(str, type, $2) {
        var uoro = (type!='*')?'ol':'ul';
        var suoro = '<' + uoro + ((type=='@') ? " type=\"a\"":"")+'>';
        var euoro = '</' + uoro + '>';
        var old = 0;
        var reItems = /^([\*#@]+)[ \t]([^\n]+)/mg;

		var stk = [];
	    str.replace( reItems,
                function(str, p1, p2)
                {
                    level = p1.length;
                    old = level;
                    stk.push([str, p1, p2]);
                }
            );

		return "\n"+suoro + woas.parser.sublist(stk, 1, suoro, euoro) + euoro;
	}

var reReapTables = /(?:^|\n)\{\|.*((?:\n\|.*)*)(?:\n|$)/g;	
woas.parser["parse_tables"] =  function (str, p1)
    {
        var caption = false;
        var stk = [];
        p1.replace( /\n\|([+ -])(.*)/g, function(str, pp1, pp2)
            {
                if (pp1 == '-')
                {
                    return;
                }
                if (pp1 == '+')
                {
                    caption = caption || pp2;
                    return;
                }
                stk.push('<td>' + pp2.split(' ||').join('</td><td>') + '</td>');
            } 
        );
        return  '<table class="text_area">' +
                    (caption?('<caption>' + caption + '</caption>'):'') +
                    '<tr>' + stk.join('</tr><tr>') + '</tr>' +
                '</table>' 
    }

// remove wiki and html that should not be viewed when previewing wiki snippets
function _filter_wiki(s) {
	return s.replace(/\{\{\{((.|\n)*?)\}\}\}/g, "").
		replace(/<script[^>]*>((.|\n)*?)<\/script>/gi, "").
		replace(/\<\w+\s[^>]+>/g, "").
		replace(/\<\/\w[^>]+>/g, "");
}

// THIS is the method that you should override for your custom parsing needs
// text is the raw wiki source
// export_links is set to true when exporting wiki pages and is used to generate proper href for hyperlinks
// js_mode can be 0 = leave script tags as they are (for exporting), 1 - place script tags in <head /> (dynamic),
//		2 - re-add script tags after parsing
woas.parser["parse"] = function(text, export_links, js_mode) {
	if (this.debug) {
		if (text===null)
			log("Called parse() with null text!");	// log:1
		return null;
	}
	// default fallback
	if (typeof export_links == "undefined") {
		export_links = false;
		js_mode=1;
	}
	
	// this array will contain all the HTML snippets that will not be parsed by the wiki engine
	var html_tags = [];
	
	// put away stuff contained in inline nowiki blocks {{{ }}}
	text = text.replace(/\{\{\{(.*?)\}\}\}/g, function (str, $1) {
		var r = "<!-- "+parse_marker+"::"+html_tags.length+" -->";
		html_tags.push("<tt class=\"wiki_preformatted\">"+woas.xhtml_encode($1)+"</tt>");
		return r;
	});
	
	// transclusion code - originally provided by martinellison
	if (!this.force_inline) {
		var trans_level = 0;
		do {
			var trans = 0;
			text = text.replace(/\[\[Include::([^\]]+)\]\]/g, function (str, $1) {
				var parts = $1.split("|");
				var templname = parts[0];
				log("Transcluding "+templname+"("+parts.slice(0).toString()+")");	// log:1
				var templtext = woas.get_text_special(templname);
				if (templtext == null) {
					var templs="[["+templname+"]]";
					if (parts.length>1)
						templs += "|"+parts.slice(1).join("|");
					return "[<!-- -->[Include::"+templs+"]]";
				}
				// in case of embedded file, add the inline file or add the image
				if (!woas.is_reserved(templname) && woas.is_embedded(templname)) {
					var r = "<!-- "+parse_marker+"::"+html_tags.length+" -->";
					log("Embedded file transclusion: "+templname);	// log:1
					if (woas.is_image(templname)) {
						var img, img_name = woas.xhtml_encode(templname.substr(templname.indexOf("::")+2));
						if (export_links)
							img = "<img class=\"embedded\" src=\""+woas._export_get_fname(templname)+"\" alt=\""+img_name+"\" ";
						else
							img = "<img class=\"embedded\" src=\""+templtext+"\" ";
						if (parts.length>1) {
							img += parts[1];
							// always add the alt attribute to images
							if (!export_links && !parts[1].match(/alt=('|").*?\1/))
								img += " alt=\""+img_name+"\"";
						}
						html_tags.push(img+" />");
					} else { // embedded file but not image
						if ((parts.length>1) && (parts[1]=="raw"))
							html_tags.push(decode64(templtext));
						else
							html_tags.push("<pre class=\"embedded\">"+
									woas.xhtml_encode(decode64(templtext))+"</pre>");
					}
					templtext = r;
				} else { // wiki source transclusion
					templtext = templtext.replace(/%(\d+)/g, function(param, paramno) {
						if (paramno < parts.length)
							return parts[paramno];
						else
							return param;
					} );
				}
				trans = 1;
				return templtext;	
			});
			// keep transcluding when a transclusion was made and when transcluding depth is not excessive
		} while (trans && (++trans_level < 16));
		if (trans_level == 16) // remove Include:: from the remaining inclusions
			text = text.replace(/\[\[Include::([^\]\|]+)(\|[\]]+)?\]\]/g, "[<!-- -->[Include::[[$1]]$2]]");
	}
	
	// thank you IE, really thank you
	if (ie)
		text = text.replace("\r\n", "\n");

	var tags = [];

	// put away raw text contained in multi-line nowiki blocks {{{ }}}
	text = text.replace(/\{\{\{((.|\n)*?)\}\}\}/g, function (str, $1) {
		var r = "<!-- "+parse_marker+"::"+html_tags.length+" -->";
		html_tags.push("<pre class=\"wiki_preformatted\">"+woas.xhtml_encode($1)+"</pre>");
		return r;
	});
	
	// reset the array of custom scripts
	this.script_extension = [];
	if (js_mode) {
		// gather all script tags
		text = text.replace(/<script([^>]*)>((.|\n)*?)<\/script>/gi, function (str, $1, $2) {
			if (js_mode==2) {
				var r = "<!-- "+parse_marker+"::"+html_tags.length+" -->";
				html_tags.push(str);
				return r;
			}
			var m=$1.match(/src=(?:"|')([^\s'">]+)/);
			if (m!=null)
				woas.parser.script_extension.push(new Array(m[1]));
			else
				woas.parser.script_extension.push($2);
			return "";
		});
	}
	
	// put a placeholder for the TOC
	var p = text.indexOf("[[Special::TOC]]");
	if (p != -1) {
		this.has_toc = true;
		text = text.substring(0, p) + "<!-- "+parse_marker+":TOC -->" + text.substring(p+16
//		+ 	((text.charAt(p+16)=="\n") ? 1 : 0)
		);	
	} else this.has_toc = false;

	// put away big enough HTML tags sequences (with attributes)
	text = text.replace(/(<\/?\w+[^>]+>[ \t]*)+/g, function (tag) {
		var r = "<!-- "+parse_marker+'::'+html_tags.length+" -->";
		html_tags.push(tag);
		return r;
	});
	
	// links with | 
	text = text.replace(/\[\[([^\]\]]*?)\|(.*?)\]\]/g, function(str, $1, $2) {
			if ($1.search(/^\w+:\/\//)==0) {
				var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
				html_tags.push("<a class=\"world\" href=\"" + $1.replace(/^mailto:\/\//, "mailto:") + "\" target=\"_blank\">" + $2 + "<\/a>");
				return r;
			}
				var page = $1;
				var hashloc = $1.indexOf("#");
				var gotohash = "";
				if (hashloc > 0) {
					page = $1.substr(0, hashloc);
					gotohash = "; window.location.hash= \"" + $1.substr(hashloc) + "\"";
				}
				if (woas.page_exists(page)) {
					var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
					var wl;
					if (export_links) {
//						if (this.page_index(page)==-1)
//							wl = " onclick=\"alert('not yet implemented');\"";		else
						wl = " href=\""+woas._export_get_fname(page)+"\"";
					} else
						wl = " onclick=\"go_to('" + woas.js_encode(page) +	"')" + gotohash + "\"";
					html_tags.push("<a class=\"link\""+ wl + " >" + $2 + "<\/a>");
					return r;
				} else {
					if ($1.charAt(0)=="#") {
						var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
						var wl;
						if (export_links)
							wl = woas._export_get_fname(page);
						else wl = "";
						html_tags.push("<a class=\"link\" href=\""+wl+"#" +this.header_anchor($1.substring(1)) + "\">" + $2 + "<\/a>");
						return r;
					} else {
						var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
						var wl;
						if (export_links)
							wl=" href=\"#\"";
						else wl = " onclick=\"go_to('" +woas.js_encode($1)+"')\"";
						html_tags.push("<a class=\"unlink\" "+wl+">" + $2 + "<\/a>");
						return r;
					}
				}
			}); //"<a class=\"wiki\" onclick='go_to(\"$2\")'>$1<\/a>");
	// links without |
	var inline_tags = 0;
	text = text.replace(/\[\[([^\]]*?)\]\]/g, function(str, $1) {
		if ($1.search(/^\w+:\/\//)==0) {
			var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
			$1 = $1.replace(/^mailto:\/\//, "mailto:");
			html_tags.push("<a class=\"world\" href=\"" + $1 + "\" target=\"_blank\">" + $1 + "<\/a>");
			return r;
		}
		
		found_tags = woas._get_tags($1);
		
		if (found_tags.length>0) {
			tags = tags.concat(found_tags);
			if (!this.force_inline)
				return "";
			inline_tags++;
			return "<!-- "+parse_marker+":"+inline_tags+" -->";
		}
		
		if (woas.page_exists($1)) {
			var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
			var wl;
			if (export_links)
				wl = " href=\""+woas._export_get_fname($1)+"\"";
			else
				wl = " onclick=\"go_to('" + woas.js_encode($1) +"')\"";
				
			html_tags.push("<a class=\"link\""+wl+">" + $1 + "<\/a>");
			return r;
		} else {
			var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
			if ($1.charAt(0)=="#") {
				html_tags.push("<a class=\"link\" href=\"#" +woas.parser.header_anchor($1.substring(1)) + "\">" + $1.substring(1) + "<\/a>");
			} else {
				var r="<!-- "+parse_marker+'::'+html_tags.length+" -->";
				var wl;
				if (export_links)
					wl=" href=\#\"";
				else
					wl = " onclick=\"go_to('" +woas.js_encode($1)+"')\"";
				html_tags.push("<a class=\"unlink\" "+wl+">" + $1 + "<\/a>");
			}
			return r;
		}
	}); //"<a class=\"wiki\" onclick='go_to(\"$1\")'>$1<\/a>");

	// allow non-wrapping newlines
	text = text.replace(/\\\n/g, "");
	
	// <u>
	text = text.replace(/(^|[^\w])_([^_]+)_/g, "$1"+parse_marker+"uS#$2"+parse_marker+"uE#");
	
	// italics
	// need a space after ':'
	text = text.replace(/(^|[^\w:])\/([^\n\/]+)\/($|[^\w])/g, function (str, $1, $2, $3) {
		if (str.indexOf("//")!=-1) {
			return str;
		}
		return $1+"<em>"+$2+"</em>"+$3;
	});
	
	// ordered/unordered lists parsing (code by plumloco)
	text = text.replace(reReapLists, this.parse_lists);
	
	// headers (from h1 to h6, as defined by the HTML 3.2 standard)
	text = text.replace(reParseHeaders, this.header_replace);
	text = text.replace(reParseOldHeaders, this.header_replace);
	
	if (this.has_toc) {
		// remove the trailing newline
//		this.parser.toc = this.parser.toc.substr(0, this.parser.toc.length-2);
		// replace the TOC placeholder with the real TOC
		text = text.replace("<!-- "+parse_marker+":TOC -->",
				"<div class=\"wiki_toc\"><p class=\"wiki_toc_title\">Table of Contents</p>" +
				this.toc.replace(reReapLists, this.parse_lists)
				/*.replace("\n<", "<") */
				+ "</div>" );
		this.toc = "";
	}
	
	// <strong> for bold text
	text = text.replace(/(^|[^\w\/\\])\*([^\*\n]+)\*/g, "$1"+parse_marker+"bS#$2"+parse_marker+"bE#");

	// <strike>
	//text = text.replace(/(^|\n|\s|\>|\*)\--(.*?)\--/g, "$1<strike>$2<\/strike>");
	
	text = text.replace(new RegExp(parse_marker+"([ub])([SE])#", "g"), function (str, $1, $2) {
		if ($2=='E') {
			if ($1=='u')
				return "</span>";
			return "</strong>";
		}
		if ($1=='u')
			tag = "<span style=\"text-decoration:underline;\">";
		else
			tag = "<strong>";
		return tag;
	});

	// <hr> horizontal rulers made with 3 hyphens. 4 suggested
	text = text.replace(/(^|\n)\s*\-{3,}\s*(\n|$)/g, "<hr />$2");
	
	// tables-parsing pass
	text = text.replace(reReapTables, this.parse_tables);
	
	// cleanup \n after headers and lists
	text = text.replace(/((<\/h[1-6]><div class="level[1-6]">)|(<\/[uo]l>))(\n+)/g, function (str, $1, $2, $3, trailing_nl) {
		if (trailing_nl.length>2)
			return $1+trailing_nl.substr(2);
		return $1;
	});
	
	// remove \n before list start tags
	text = text.replace(/\n(<[uo]l>)/g, "$1");

	// end-trim
	if (end_trim)
		text = text.replace(/\s*$/, "");

	// compress newlines characters into paragraphs (disabled)
//	text = text.replace(/\n(\n+)/g, "<p>$1</p>");
//	text = text.replace(/\n(\n*)\n/g, "<p>$1</p>");

	// make some newlines cleanup after pre tags
	text = text.replace(/(<\/?pre>)\n/gi, "$1");

	// convert newlines to br tags
	text = text.replace(/\n/g, "<br />");

	// put back in place all HTML snippets
	if (html_tags.length>0) {
		text = text.replace(new RegExp("<\\!-- "+parse_marker+"::(\\d+) -->", "g"), function (str, $1) {
			return html_tags[$1];
		});
	}
	
	tags = tags.toUnique();
	if (tags.length && !export_links) {
		var s;
		if (this.force_inline)
			s = "";
		else
			s = "<div class=\"taglinks\">";
		s += "Tags: ";
		for(var i=0;i<tags.length-1;i++) {
			s+="<a class=\"link tag\" onclick=\"go_to('Tagged::"+woas.js_encode(tags[i])+"')\">"+tags[i]+"</a>&nbsp;&nbsp;";
		}
		if (tags.length>0)
			s+="<a class=\"link tag\" onclick=\"go_to('Tagged::"+woas.js_encode(tags[tags.length-1])+"')\">"+tags[tags.length-1]+"</a>";
		if (!this.force_inline) {
			s+="</div>";
			text += s;
		} else {
			text = text.replace(new RegExp("<\\!-- "+parse_marker+":(\\d+) -->", "g"), function (str, $1) {
				if ($1==inline_tags)
					return s;
				return "";
			});
		}
	}
	if (this.force_inline)
		this.force_inline = false;
		
	if (text.substring(0,5)!="</div")
		return "<div class=\"level0\">" + text + "</div>";
	return text.substring(6)+"</div>";
}


/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** special.js ***/
// Here begins the special pages' code

woas["special_encrypted_pages"] = function(locked) {
	var pg = [];
	for(var i=0;i<pages.length;i++) {
		if (locked == this.is__encrypted(i))
			pg.push(page_titles[i]);
	}
	return this._join_list(pg);
}

woas["special_orphaned_pages"] = function() {
	var pg = [];
	var found = false;
	for(j=0; j<page_titles.length; j++) {
		if (this.is_reserved(page_titles[j]))
			continue;
		if (this.is_menu(page_titles[j])) {	// check if the namespace has some pages
			var ns = this.get_namespace(page_titles[j]);
			if (ns == "") continue;
			for(var i=0;i<page_titles.length;i++) {
				if (page_titles[i].indexOf(ns)==0) {
					found = true;
					break;
				}
			}
		} else {
		// search for pages that link to it
			var tmp;
			for(var i=0; i<page_titles.length; i++) {
				if ((i==j) || this.is_reserved(page_titles[i]))
					continue;
				tmp = this.get_src_page(i);
				if (tmp==null)
					continue;
				var re = new RegExp("\\[\\[" + RegExp.escape(page_titles[j]) + "(\\]\\]|\\|)", "i");
//			log("matching "+re+" into "+page_titles[i]);	// log:0
				if (tmp.search(re)!=-1) {
					found = true;
					break;
				}
			}
		}
		if(found == false) {
			pg.push( page_titles[j] );
		} else found = false;
	}
	if (!pg.length)
		return "/No orphaned pages found/";
	else
		return this._join_list(pg); // TODO - Delete repeated data
}

woas["special_backlinks"] = function()
{
	var pg = [];
	var tmp;
	var reg = new RegExp("\\[\\["+RegExp.escape(current)+"(\\||\\]\\])", "gi");
	for(j=0; j<pages.length; j++)
	{
		// search for pages that link to it
		tmp = this.get_src_page(j);
		if (tmp==null)
			continue;
		if (tmp.match(reg)) {
			pg.push( page_titles[j] );
		}
	}
	if(pg.length == 0)
		return "/No page links here/";
	else
		return "== Links to "+current+"\n"+this._join_list(pg);
}

//var hl_reg;

// Returns a index of search pages (by miz & legolas558)
woas["special_search"] = function( str ) {
	document.body.style.cursor = "wait";
	var pg_body = [];
	var title_result = "";
	log("Searching "+str);
	
	var count = 0;
	// matches the search string and nearby text
	var reg = new RegExp( ".{0,30}" + RegExp.escape(this.trim(str)).
					replace(/\s+/g, ".*?") + ".{0,30}", "gi" );
	_hl_reg = new RegExp("("+RegExp.escape(str)+")", "gi");
/*	hl_reg = new RegExp( ".*?" + RegExp.escape(str).
					replace(/^\s+/, "").
					replace(/\s+$/, "").
					replace(/([^\s]+)/g, "($1)").
					replace(/\s+/g, ".*?") + ".*", "gi" );	*/
	var tmp;
	result_pages = [];
	for(var i=0; i<pages.length; i++) {
		if (this.is_reserved(page_titles[i]))
			continue;
		
		tmp = this.get_src_page(i);
		if (tmp==null)
			continue;
//		log("Searching into "+page_titles[i]);	// log:0
		
		var added = false;
		//look for str in title
		if(page_titles[i].match(reg)) {
			title_result += "* [[" + page_titles[i] + "]]\n";
			result_pages.push(page_titles[i]);
			added = true;
		}

		//Look for str in body
		res_body = tmp.match(reg);
		if (res_body!=null) {
			if (!added)
				result_pages.push(page_titles[i]);
			count = res_body.length;
			res_body = "..."+res_body.join("...\n")+"..."; //.replace(/\n/g, " ");
			pg_body.push( "* [[" + page_titles[i] + "]]: found *" + count + "* times :<div class=\"search_results\">{{{" + res_body +"\n}}}\n</div>");
		}
	}
	document.body.style.cursor = "auto";
	if (!pg_body.length && !title_result.length)
		return "/No results found for *"+str+"*/";
	woas.parser.force_inline = true;
	return "Results for *" + woas.xhtml_encode(str) + "*\n" + title_result + "\n\n----\n" + this._simple_join_list(pg_body, false);
}

woas["special_tagged"] = function() {
	var utags = [];
	var tags_tree = [];
	var tmp = null, ipos;
	for(var i=0; i<pages.length; i++)
	{
		tmp = this.get_src_page(i);
		if (tmp==null)
			continue;
		tmp.replace(/\[\[Tags?::([^\]]+)\]\]/g,
			function (str, $1) {
				var tmp=$1.split(",");
				for(var j=0;j<tmp.length; j++) {
					var tag=woas.trim(tmp[j]);
					if (!tag.length) continue;
					ipos = utags.indexOf(tag);
					if (ipos==-1) {
						ipos = utags.length;
						utags.push(tag);						
						tags_tree[ipos] = [];
					}
					tags_tree[ipos].push(page_titles[i]);
				}
			});
	}
	var s="";
	var tag = null, obj = null;
	var l=utags.length;
	for(var j=0;j<l;j++) {
		obj = tags_tree[j].sort();
		s += "\n== [[Tagged::"+utags[j]+"]]\n";
		for(var i=0;i<obj.length;i++) {
			s+="* [["+obj[i]+"]]\n";
		}
	}
	return s;
}

woas["special_untagged"] = function() {
	var tmp;
	var pg = [];
	for(var i=0; i<pages.length; i++) {
		tmp = this.get_src_page(i);
		if (tmp==null)
			continue;
		if (!tmp.match(/\[\[Tags?::([^\]]+)\]\]/))
			pg.push("[["+page_titles[i]+"]]");
	}
	if (!pg.length)
		return '/No untagged pages/';
	return this._simple_join_list(pg, true);
}

// Returns a index of all pages
woas["special_all_pages"] = function() {
	var pg = [];
	for(var i=0; i<page_titles.length; i++)
	{
		if (!this.is_reserved(page_titles[i]))
			pg.push( page_titles[i] );
	}
	return this._join_list(pg);
}

// Returns a index of all dead pages
woas["special_dead_pages"] = function() {
	var dead_pages = [];
	var from_pages = [];
	var page_done = false;
	var tmp;
	for (j=0;j<pages.length;j++) {
		tmp = this.get_src_page(j);
		if (tmp==null)
			continue;
		tmp.replace(/\[\[([^\]\]]*?)(\|([^\]\]]+))?\]\]/g,
			function (str, $1, $2, $3) {
				if (page_done)
					return false;
				if ($1.charAt(0)=="#")
					return;
				if ($1.search(/^\w+:\/\//)==0)
					return;
				if ($1.match(/Tag(s|ged)?:/gi))
					return;
				p = $1;
				if (!woas.page_exists(p) && (p!=page_titles[j])) {
					for(var i=0;i<dead_pages.length;i++) {
						if (dead_pages[i]==p) {
							from_pages[i].push(page_titles[j]);
							page_done = true;
							break;
						}
					}
					if (!page_done) {
						dead_pages.push(p);
						from_pages.push(new Array(page_titles[j]));
						page_done = true;
					}
				}
	        }
		);
		page_done = false;
	}

	var pg = [], s;
	for(var i=0;i<dead_pages.length;i++) {
		s = "[["+dead_pages[i]+"]] from ";
		var from = from_pages[i];
		for(j=0;j<from.length-1;j++) {
			s+="[["+from[j]+"]], ";
		}
		if (from.length>0)
			s+="[["+from[from.length-1]+"]]";
		pg.push(s);
	}

  result_pages = dead_pages;	
  if (!pg.length)
	return '/No dead pages/';
	return this._simple_join_list(pg, true);
}

// used in Special::Options
function bool2chk(b) {
	if (b) return "checked";
	return "";
}

$["checked"] =function(id) {
	cfg_changed = true;
	if ($(id).checked)
		return true;
	return false;
}

// Used by Special::Options
function _set_layout(fixed) {
	$("sw_menu_area").style.position = $("sw_wiki_header").style.position = (fixed ? "fixed" : "absolute");
}

// End of special pages' code

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** stickwiki.js ***/

// page attributes bits are mapped to (readonly, encrypted, ...)

var end_trim = false;		// trim pages from the end

var forstack = [];			// forward history stack, discarded when saving
var cached_search = "";		// cached XHTML content of last search
var cfg_changed = false;	// true when configuration has been changed
var search_focused = false;	// true when a search box is currently focused
var _custom_focus = false;	// true when an user control is currently focused
var _prev_title = current;	// used when entering/exiting edit mode
var _decrypt_failed = false;	// the last decryption failed due to wrong password attempts (pretty unused)
var result_pages = [];			// the pages indexed by the last result page
var last_AES_page;				// the last page on which the cached AES key was used on
var current_namespace = "";		// the namespace(+subnamespaces) of the current page
var floating_pages = [];				// pages which need to be saved and are waiting in the queue
var _bootscript = null;					// bootscript
var _hl_reg = null;						// search highlighting regex

// Automatic-Save TimeOut object
woas["_asto"] = null;

// left and right trim
woas["trim"] = function(s) {
	return s.replace(/(^\s*)|(\s*$)/, '');
}

// general javascript-safe string quoting
// NOTE: not completely binary safe!
// should be used only for titles (which ought not to contain binary bytes)
woas["js_encode"] = function (s, split_lines) {
	// not to counfound browsers with saved tags
	s = s.replace(/([\\<>'])/g, function (str, ch) {
//		return "\\x"+ch.charCodeAt(0).toString(16);
		switch (ch) {
			case "<":
				return	"\\x3C";
			case ">":
				return "\\x3E";
			case "'":
				return "\\'";
//			case "\\":
		}
		return "\\\\";
	});
	// escape newlines (\r\n happens only on the stupid IE) and eventually split the lines accordingly
	if (!split_lines)
		s = s.replace(new RegExp("\r\n|\n", "g"), "\\n");
	else
		s = s.replace(new RegExp("\r\n|\n", "g"), "\\n\\\n");
	// and fix also the >= 128 ascii chars (to prevent UTF-8 characters corruption)
	return s.replace(new RegExp("([^\u0000-\u007F])", "g"), function(str, $1) {
				var s = $1.charCodeAt(0).toString(16);
				for(var i=4-s.length;i>0;i--) {
					s = "0"+s;
				}
				return "\\u" + s;
	});
}

// used to escape blocks of source into HTML-valid output
woas["xhtml_encode"] = function(src) {
	return this.utf8_encode(src.replace(/[<>&]+/g, function ($1) {
		var l=$1.length;
		var s="";
		for(var i=0;i<l;i++) {
			switch ($1.charAt(i)) {
				case '<':
					s+="&lt;";
					break;
				case '>':
					s+="&gt;";
					break;
//				case '&':
				default:
					s+="&amp;";
			}
		}
		return s;
	}));
}

woas["utf8_encode"] = function(src) {
	return src.replace(/[^\u0000-\u007F]+/g, function ($1) {
		var l=$1.length;
		var s="";
		for(var i=0;i<l;i++) {
			s+="&#"+$1.charCodeAt(i)+";";
		}
		return s;
	});
}

// create a centered popup given some options
woas["popup"] = function (name,fw,fh,extra) {
	var hpos=Math.ceil((screen.width-fw)/2);
	var vpos=Math.ceil((screen.height-fh)/2);
	var wnd = window.open("about:blank",name,"width="+fw+",height="+fh+		
	",left="+hpos+",top="+vpos+extra);
	wnd.focus();
	return wnd;
}

//DANGER: will corrupt your WoaS!
var edit_override = false;

var reserved_namespaces = ["Special", "Lock", "Locked", "Unlocked", "Unlock", "Tags", "Tagged", "Untagged", "Include", "Javascript", "WoaS"];

// create the regex for reserved namespaces
var reserved_rx = "^";
for(var i = (edit_override ? 1 : 0);i<reserved_namespaces.length;i++) {
	reserved_rx += /*RegExp.Escape(*/reserved_namespaces[i] + "::";
	if (i<reserved_namespaces.length-1)
		reserved_rx += "|";
}
woas["_reserved_rx"] = new RegExp(reserved_rx, "i"); reserved_namespaces = reserved_rx = null;

woas["aliases"] = [];

woas["page_index"] = function(title) {
	for(var i=0;i<this.aliases.length;++i) {
		title = title.replace(this.aliases[i][0], this.aliases[i][1]);
	}
	return page_titles.indexOf(title);
}

woas["is_reserved"] = function(page) {
	return (page.search(this._reserved_rx)==0);
}

woas["is_menu"] = function(page) {
	return (page.indexOf("::Menu")==page.length-6);
}

// returns namespace with trailing ::
woas["get_namespace"] = function(page) {
	var p = page.lastIndexOf("::");
	if (p==-1) return "";
	return page.substring(0,p+2);	
}

woas["is_readonly"] = function(page) {
	return this.is_readonly_id(this.page_index(page));
}

woas["is_readonly_id"] = function(pi) {
	if (page_attrs[pi] & 1)
		return true;
	return false;
}

woas["is__encrypted"] = function (pi) {
	if (page_attrs[pi] & 2)
		return true;
	return false;
}

woas["is_encrypted"] = function(page) {
	return this.is__encrypted(this.page_index(page));
}

woas["is__embedded"] = function(pi) {
	if (page_attrs[pi] & 4)
		return true;
	return false;
}
woas["is_embedded"] = function(page) {return this.is__embedded(this.page_index(page));}

woas["is__image"] = function(pi) {
	if (page_attrs[pi] & 8)
		return true;
	return false;
}
woas["is_image"] = function(page) { return this.is__image(this.page_index(page)); }

// a page physically exists if it is not part of a reserved namespace, if it is not a (sub)namespace and if it actually exists
woas["page_exists"] = function(page) {
	return (this.is_reserved(page) || (page.substring(page.length-2)=="::") || (this.page_index(page)!=-1));
}

var	parse_marker = "#"+_random_string(8);

woas["_get_tags"] = function(text) {
	var tags = [];
	if (text.indexOf("Tag::")==0)
		tags.push(this.trim(text.substring(5)));
	else if (text.indexOf("Tags::")==0) {
		text = this.trim(text.substring(6));
		if (!text.length)
			return tags;
		var alltags;
		if (text.indexOf("|")!=-1)
			alltags = text.split("|");
		else
			alltags = text.split(",");
		for(var i=0;i<alltags.length;i++) {
			tags.push(this.trim(alltags[i]));
		}
	}
	return tags;
}

// joins a list of pages
woas["_join_list"] = function(arr) {
	if (!arr.length)
		return "";
	result_pages = arr.slice(0);
	return "* [["+arr.sort().join("]]\n* [[")+"]]";
}

woas["_simple_join_list"] = function(arr, sorted) {
	if (sorted)
		arr = arr.sort();
	// a newline is added here
	return arr.join("\n")+"\n";
}

// with two trailing double colon
woas["_get_namespace_pages"] = function (ns) {
	var pg = [];
	switch (ns) {
		case "Locked::":
			return "= Pages in "+ns+" namespace\n" + this.special_encrypted_pages(true);
		case "Unlocked::":
			return "= Pages in "+ns+" namespace\n" + this.special_encrypted_pages(false);
		case "Untagged::":
			return "= Pages in "+ns+" namespace\n" + this.special_untagged(false);
		case "Tagged::": // to be used in wiki source
		case "Tags::":
			return "= Pages in "+ns+" namespace\n" + this.special_tagged(false);
	}

	for(var i=0;i<page_titles.length;i++) {
		if (page_titles[i].indexOf(ns)===0)
			pg.push(page_titles[i]);
	}
	return "= Pages in "+ns+" namespace\n" + this._join_list(pg);
}

woas["_get_tagged"] = function(tag_filter) {
	var pg = [];
	
	// allow tags filtering
	var tags = tag_filter.split(','), tags_ok = [], tags_not = [];
	for(var i=0;i<tags.length;++i) {
		if (!tags[i].length)
			continue;
		if (tags[i].charAt(0)=='!')
			tags_not.push( tags[i] );
		else
			tags_ok.push(tags[i]);
	} tags = null;

	var tmp, b, fail;
	for(var i=0; i<pages.length; i++) {
		tmp = this.get_src_page(i);
		if (tmp==null)
			continue;
		tmp.replace(/\[\[([^\|]*?)\]\]/g, function(str, $1)
			{
				if ($1.search(/^\w+:\/\//)==0)
					return;
					
				found_tags = woas._get_tags($1);
				
//				alert(found_tags);
				fail = false;
				for (var t=0;t<found_tags.length;t++) {
					for (b=0;b<tags_ok.length;++b) {
						if (found_tags[t] != tags_ok[b]) {
							fail = true;
							break;
						}
					}
					if (!fail) {
						for (b=0;b<tags_not.length;++b) {
							if (found_tags[t] == tags_not[b]) {
								fail = true;
								break;
							}
						}
					}
					if (!fail)
						pg.push(page_titles[i]);
				}

				
			});
	}
	
	if (!pg.length)
		return "No pages tagged with *"+tag_filter+"*";
	return "= Pages tagged with " + tag_filter + "\n" + this._join_list(pg);
}

// return a plain page or a decrypted one if available through the latest key
woas["get_page"] = function(pi) {
	if (this.is__embedded(pi))
		return null;
	if (!this.is__encrypted(pi))
		return pages[pi];
	if (!key.length) {
		latest_AES_page = "";
		return null;
	}
	var pg = AES_decrypt(pages[pi].slice(0));	/*WARNING: may not be supported by all browsers*/
	last_AES_page = page_titles[pi];
	return pg;	
}

woas["get_src_page"] = function(pi) {
	var pg = this.get_page(pi);
	if (pg===null) return null;
	return _filter_wiki(pg);
}

woas["get_text"] = function (title) {
	var pi = this.page_index(title);
	if (pi==-1)
		return null;
	return this.get__text(pi);
}

//TODO: check consistency of special pages inclusion
woas["get_text_special"] = function(title) {
	var p = title.indexOf("::");
	var text = null;
	if (p!=-1) {
		var namespace = title.substring(0,p);
//		log("namespace of "+title+" is "+namespace);	// log:0
		title = title.substring(p+2);
		if (!title.length) return this._get_namespace_pages(namespace+"::");
		switch (namespace) {
			case "Special":
				text = this._get_special(title, false);
			break;
			case "Tagged": // deprecated?
			case "Tags":
				text = this._get_tagged(title);
			break;
			default:
				text = this.get_text(namespace+"::"+title);
		}
	} else
		text = this.get_text(title);
	return text;
}

woas["__last_title"] = null;

woas["__password_finalize"] = function(pwd_obj) {
//	this.setHTML($("woas_pwd_msg"), msg);
//	$.show("wiki_text");
	document.title = this.__last_title;
	$("wiki_text").style.visibility = "visible";
	$("woas_pwd_query").style.visibility = "hidden";
	$("woas_pwd_mask").style.visibility = "hidden";
//	scrollTo(0,0);
	// hide input form
	pwd_obj.value = "";
	pwd_obj.blur();
	custom_focus(false);
}

woas["_set_password"] = function() {
	this.__last_title = document.title;
	document.title = "Enter password";
	// hide browser scrollbars and show mask
	$("woas_pwd_mask").style.visibility = "visible";
//	this.setHTML($("woas_pwd_msg"), msg);
//	$.hide("wiki_text");
	$("wiki_text").style.visibility = "hidden";
	scrollTo(0,0);
	// show input form
	$("woas_pwd_query").style.visibility = "visible";
	custom_focus(true);
	$("woas_password").focus();	
}

woas["_password_cancel"] = function() {
	this.__password_finalize($("woas_password"));
}

woas["_password_ok"] = function() {
	var pwd_obj = $("woas_password");
	var pw = pwd_obj.value;
	if (!pw.length) {
		alert("Please enter a password.");
		return;
	}
	AES_setKey(pw);
	this.__password_finalize(pwd_obj);
}

//TODO: specify interactive-mode
woas["get__text"] = function(pi) {
	// is the page encrypted or plain?
	if (!this.is__encrypted(pi))
		return pages[pi];
	_decrypt_failed = true;
	if (!key.length) {
		alert("No password set for decryption of page \""+page_titles[pi]+"\"");
		return null;
	}
	document.body.style.cursor = "wait";
//	var pg = null;
			//TODO: use form-based password input
//			this._get_password('The latest entered password (if any) was not correct for page "'+page_titles[pi]+"\"");
//			var pw = prompt('The latest entered password (if any) was not correct for page "'+page_titles[pi]+"'\n\nPlease enter the correct password.", '');
//			if ((pw==null) || !pw.length) {
			// we are waiting for the password to be set programmatically
/*			if (!pw.length) {
				latest_AES_page = "";
				AES_clearKey();
				document.body.style.cursor = "auto";
				return null;
			}
			AES_setKey(pw);
			retry++;
*/
//			return null;
//		}
		// pass a copied instance to the decrypt function
		var pg = AES_decrypt(pages[pi].slice(0));	/*WARNING: may not be supported by all browsers*/
		last_AES_page = page_titles[pi];
//		if (pg != null)
//			break;
	if (!this.config.key_cache)
		AES_clearKey();
	if (pg != null) {
		_decrypt_failed = false;
//		if (this.config.key_cache)			latest_AES_page = page_titles[pi];
	} else {
		alert("Access denied to page \""+page_titles[pi]+"\"");
//		AES_clearKey();
		latest_AES_page = "";
	}
	document.body.style.cursor = "auto";
	return pg;
}

woas["set__text"] = function(pi, text) {
	log("Setting wiki text for page #"+pi+" \""+page_titles[pi]+"\"");	// log:1
	if (this.is__embedded(pi) && !this.is__image(pi))
		text = encode64(text);
//	text = _new_syntax_patch(text);
	if (!this.is__encrypted(pi)) {
		pages[pi] = text;
		return;
	}
	pages[pi] = AES_encrypt(text);
	last_AES_page = page_titles[pi];
}

// Sets text typed by user
woas["set_text"] = function(text) {
	var pi = this.page_index(current);
	if (pi==-1) {
		log("current page \""+current+"\" is not cached!");	// log:1
		return;
	}
	this.set__text(pi, text);
}

// triggered by UI graphic button
function page_print() {
	var wnd = woas.popup("print_popup", Math.ceil(screen.width*0.75),Math.ceil(screen.height*0.75),
	",status=yes,menubar=yes,resizable=yes,scrollbars=yes");
	var css_payload = "";
	if (ie) {
		if (ie6)
			css_payload = "div.wiki_toc { align: center;}";
		else
			css_payload = "div.wiki_toc { position: relative; left:25%; right: 25%;}";
	} else
		css_payload = "div.wiki_toc { margin: 0 auto;}\n";
	wnd.document.writeln(_doctype+"<ht"+"ml><he"+"ad><title>"+current+"</title>"+
	"<st"+"yle type=\"text/css\">"+css_payload+_css_obj().innerHTML+"</sty"+"le><scr"+"ipt type=\"text/javascript\">function go_to(page) { alert(\"Sorry, you cannot browse the wiki while in print mode\");}</sc"+"ript></h"+"ead><"+"body>"+
	$("wiki_text").innerHTML+"</bod"+"y></h"+"tml>\n");
	wnd.document.close();
}

woas["clear_search"] = function() {
	if (!cached_search.length)
		return;
	cached_search = "";
	this.assert_current("Special::Search");
}

woas["assert_current"] = function(page) {
	if( current != page )
		go_to( page ) ;
	else
		this.set_current( page, true);
}

woas["_create_page"] = function (ns, cr, ask, fill_mode) {
	if (this.is_reserved(ns+"::")) {
		alert("You are not allowed to create a page titled \""+ns+"::"+cr+"\" because namespace \""+ns+"\" is reserved");
			return false;
	}
	if ((ns=="File") || (ns=="Image")) {
		if (!fill_mode)
			alert("Cannot duplicate into File:: or Image:: namespace!");
		else
			go_to(cr);
		return false;
	}
	if (!fill_mode && ask && !confirm("Page not found. Do you want to create it?"))
		return false;
	// create and edit the new page
	if (cr!="Menu")
		pages.push("= "+cr+"\n");
	else
		pages.push("\n");
	if (ns.length)
		cr = ns+"::"+cr;
	page_attrs.push(0);
	page_titles.push(cr);
	log("Page "+cr+" added to internal array");	// log:1
	if (!fill_mode) {
		current = cr;
//		this.save_page(cr);	// do not save
		// proceed with a normal wiki source page
		this.edit_page(cr);
	}
	return true;
}

woas["_get_embedded"] = function(cr, etype) {
	log("Retrieving embedded source "+cr);	// log:1
	var pi=this.page_index(cr);
	if (pi==-1) {
		return this.parser.parse("[[Include::Special::Embed|"+etype+"]]");
	}
	return this._get__embedded(cr, pi, etype);
}

woas["_get__embedded"] = function (cr, pi, etype) {
	var text=this.get__text(pi);
	if (text==null) return null;
	var xhtml = "";
	var slash_c = (navigator.appVersion.indexOf("Win")!=-1)?"\\":"/";
	if (etype=="file") {
		var fn = cr.substr(cr.indexOf("::")+2);
		var pview_data = decode64(text, 1024), pview_link = "";
		var ext_size = Math.ceil((text.length*3)/4);
		if (ext_size-pview_data.length>10)
			pview_link = "<div id='_part_display'><em>Only the first 1024 bytes are displayed</em><br /><a href='javascript:show_full_file("+pi+")'>Display full file</a></div>";
		var _del_cmd, _del_lbl;
		if (!this.is_reserved(cr)) {
			_del_cmd = "function query_delete_file() {if (confirm('Are you sure you want to delete this file?')){delete_page('"+this.js_encode(cr)+"');back_or(main_page);woas.save_page('"+this.js_encode(cr)+"');}}\n";
			_del_lbl = "\n\n<a href=\"javascript:query_delete_file()\">Delete embedded file</a>\n";
		} else
			_del_lbl = _del_cmd = ""
		xhtml = "<pre id='_file_ct' class=\"embedded\">"+this.xhtml_encode(pview_data)+"</pre>"+
		pview_link+
		"<br /><hr />File size: "+_convert_bytes(ext_size)+"<br /><br />XHTML transclusion:"+
		this.parser.parse("\n{{{[[Include::"+cr+"]]}}}"+"\n\nRaw transclusion:\n\n{{{[[Include::"+cr+"|raw]]}}}"+
		_del_lbl+
		"\n<a href=\"javascript:query_export_file()\">Export file</a>\n"+
		"<sc"+"ript>"+_del_cmd
		+(pview_link.length?"function show_full_file(pi) { var text = this.get__text(pi); if (text==null) return; $.show('loading_overlay'); woas.setHTML($('_part_display'), ''); woas.setHTML($('_file_ct'), this.xhtml_encode(decode64(text))); $.hide('loading_overlay'); }\n":'')+
		"function query_export_file() {\nvar exp_path = _get_this_filename().replace(/\\"+slash_c+"[^\\"+
		slash_c+"]*$/, \""+(slash_c=="\\"?"\\\\":"/")+"\")+'"+this.js_encode(fn)+"';if (confirm('Do you want to export this file in the below specified path?'+\"\\n\\n\"+exp_path)){woas.export_file('"+this.js_encode(cr)+"', exp_path);}}"+
		"</sc"+"ript>"
		);
	} else {
		var img_name = cr.substr(cr.indexOf("::")+2);
		xhtml = this.parser.parse("= "+img_name+"\n\n"+
		"<img id=\"img_tag\" class=\"embedded\" src=\""+text+"\" alt=\""+this.xhtml_encode(img_name)+"\" />"+
		"\n\n<div id=\"img_desc\">Loading...</div>"+
		"<sc"+"ript>function _to_img_display() { var img=$('img_tag');\nwoas.setHTML($('img_desc'), 'Mime type: "+text.match(/^data:\s*([^;]+);/)[1]+"<br />File size: "+_convert_bytes(((text.length-(text.match(/^data:\s*[^;]*;\s*[^,]*,\s*/)[0]).length)*3)/4)+
		" (requires "+_convert_bytes(text.length)+" due to base64 encoding)"+
		"<br />Width: '+img.width+'px<br />Height: '+img.height+'px');} setTimeout('_to_img_display()', 0); function query_delete_image() {if (confirm('Are you sure you want to delete this image?')){delete_page('"+this.js_encode(cr)+"');back_or(main_page);woas.save_page('"+this.js_encode(cr)+"');}}\n"+
		"function query_export_image() {\nvar exp_path = _get_this_filename().replace(/\\"+slash_c+"[^\\"+
		slash_c+"]*$/, \""+(slash_c=="\\"?"\\\\":"/")+"\")+'"+this.js_encode(img_name)+"';if (confirm('Do you want to export this image in the below specified path?'+\"\\n\\n\"+exp_path)){woas.export_image('"+this.js_encode(cr)+"', exp_path);}}"+
		"</sc"+"ript>"+
		"\nSimple transclusion:\n\n{{{[[Include::"+cr+"]]}}}\n\nTransclusion with additional attributes:\n\n{{{[[Include::"+cr+"|border=\"0\" onclick=\"go_to('"+
		this.js_encode(cr)+"')\" style=\"cursor:pointer\"]]}}}\n"+
		"\n<a href=\"javascript:query_delete_image()\">Delete embedded image</a>\n"+
		"\n<a href=\"javascript:query_export_image()\">Export image</a>\n");
	}
	return xhtml;
}

woas["export_image"] = function(page, dest_path) {
	var pi=this.page_index(page);
	if (pi==-1)
		return false;
	var data=this.get__text(pi);
	if (data==null)
		return false;
	return this._b64_export(data, dest_path);
}

// save a base64 data: stream into an external file
woas["_b64_export"] = function(data, dest_path) {
	// decode the base64-encoded data
	data = decode64(data.replace(/^data:\s*[^;]*;\s*base64,\s*/, ''));
	// attempt to save the file
	_force_binary = true;
	var r = saveFile(dest_path, data);	
	_force_binary = false;
	return r;
}

woas["export_file"] = function(page, dest_path) {
	var pi=this.page_index(page);
	if (pi==-1)
		return false;
	var data=this.get__text(pi);
	if (data==null)
		return false;
	// attempt to save the file (binary mode)
	data = decode64(data);
	_force_binary = true;
	var r = saveFile(dest_path, data);	
	_force_binary = false;
	if (r)
		alert("Written "+data.length+" bytes");
	return r;
}

woas["_embed_process"] = function(etype) {
	var filename = $("filename_").value;
	if(filename == "") {
		alert("A file must be selected");
		return false;
	}

	_force_binary = true;
	var ct = loadFile(filename);
	_force_binary = false;
	if (ct == null || !ct.length) {
		alert("Could not load file "+filename);
		return false;
	}
	
	ct = encode64(ct);
	
	// calculate the flags for the embedded file
	if (etype == "image") {
		var m=filename.match(/\.(\w+)$/);
		if (m==null) m = "";
		else m=m[1].toLowerCase();
		var guess_mime = "image";
		switch (m) {
			case "png":
				guess_mime = "image/png";
			break;
			case "gif":
				guess_mime = "image/gif";
				break;
			case "jpg":
			case "jpeg":
				guess_mime = "image/jpeg";
				break;
		}
		ct = "data:"+guess_mime+";base64,"+ct;
		etype = 12;
	} else etype = 4;
	
	pages.push(ct);
	page_attrs.push(etype);
	page_titles.push(current);
	
	// save everything
	this.save_to_file(true);
	
	this.refresh_menu_area();
	this.set_current(current, true);
	
	return true;
}

woas["cmd_duplicate_page"] = function() {
	var pname = this._new_page("Insert duplicate page title", true, current+" (duplicate)");
	if (pname == null)
		return;
	var pi = this.page_index(current);
	var dpi = this.page_index(pname);
	// duplicate the page
	pages[dpi] = pages[pi]; // .slice ?
	page_attrs[dpi] = page_attrs[pi];	
	// go to new page
	go_to(pname);
}

woas["cmd_new_page"] = function() {
	this._new_page("Insert new page title", false, '');
}

woas["_new_page"] = function(msg, fill_mode, def_title) {
	var title = def_title;
	do {
		title = prompt(msg, title);
		if (title == null) break;
		if (!title.match(/\[\[/) && !title.match(/\]\]/))
			break;
		alert("Cannot use \"[[\" or \"]]\" in a page title");
	} while (1);
	if ((title!=null) && title.length) {
		if (this.page_index(title)!=-1)
			alert("A page with title \""+title+"\" already exists!");
		else {
			cr = title;
			if (cr.substring(cr.length-2)=="::") {
				alert("You cannot create a page as a namespace");
			} else {
				var p = cr.indexOf("::");
				if (p!=-1) {
					ns = cr.substring(0,p);
//					log("namespace of "+cr+" is "+ns);	// log:0
					cr = cr.substring(p+2);
				} else ns="";
				if (!this._create_page(ns, cr, false, fill_mode))
					return ns+cr;
				var upd_menu = (cr=='Menu');
				if (!upd_menu && confirm("Do you want to add a link into the main menu?")) {
					var menu = this.get_text("::Menu");
					var p = menu.indexOf("\n\n");
					if (p==-1)
						menu += "\n[["+ns+cr+"]]";
					else
						menu = menu.substring(0,p)+"\n[["+title+"]]"+menu.substring(p);
					this.set__text(this.page_index("::Menu"), menu);
					upd_menu = true;
				}
				if (upd_menu)
					this.refresh_menu_area();
				return ns+cr;
			}
		}
	}
	return null;
}

woas["cmd_erase_wiki"] = function() {
	if (erase_wiki()) {
		this.save_to_file(true);
		back_or(main_page);
	}
	return null;
}

woas["cmd_main_page"] = function() {
	go_to(main_page);
	return null;
}

woas["cmd_edit_css"] = function() {
	if (!this.config.permit_edits && !edit_override) {
		alert("This Wiki on a Stick is read-only");
		return null;
	}
	_servm_alert();
	this.current_editing("Special::Edit CSS", true);
	this.edit_ready(_css_obj().innerHTML);
	return null;
}

woas["cmd_edit_bootscript"] = function() {
	if (!this.config.permit_edits && !edit_override) {
		alert("This Wiki on a Stick is read-only");
		return null;
	}
	_servm_alert();
	cr = "WoaS::Bootscript";
	var tmp = this.get_text(cr);
	if (tmp == null)
		return;
	this.current_editing(cr, true);
	// setup the wiki editor textbox
	this.current_editing(cr, this.config.permit_edits | this._server_mode);
	this.edit_ready(decode64(tmp));
	return null;
}

woas["cmd_edit_aliases"] = function() {
	if (!this.config.permit_edits && !edit_override) {
		alert("This Wiki on a Stick is read-only");
		return null;
	}
	_servm_alert();
	cr = "WoaS::Aliases";
	var tmp = this.get_text(cr);
	if (tmp == null)
		return;
	this.current_editing(cr, true);
	// setup the wiki editor textbox
	this.current_editing(cr, this.config.permit_edits | this._server_mode);
	this.edit_ready(tmp);
	return null;
}

woas["cmd_go_to"] = function() {
	var pname = prompt("Go to page:", current);
	if ((pname === null) || !pname.length)
		return null;
	go_to(pname);
}

woas["cmd_delete"] = function() {
	var pname = prompt("Delete page:", current);
	if ((pname === null) || !pname.length)
		return;
	var pi = this.page_index(pname);
	if (pi == -1) {
		alert("Page \""+pname+"\" does not exist!");
		return;
	}
	if ((pname != null) && confirm("Are you sure you want to DELETE page \""+pname+"\"?")) {
		delete_page(pname);
		this.save_page(pname);
	}
}

woas["shortcuts"] = ["New Page", "Duplicate Page", "All Pages", "Orphaned Pages", "Backlinks", "Dead Pages", "Erase Wiki", "Edit CSS", "Main Page", "Edit Bootscript", "Aliases", "Go to", "Delete Page"];
woas["shortcuts_js"] = ["cmd_new_page", "cmd_duplicate_page", "special_all_pages", "special_orphaned_pages", "special_backlinks",
					"special_dead_pages", "cmd_erase_wiki", "cmd_edit_css", "cmd_main_page",
					"cmd_edit_bootscript", "cmd_edit_aliases", "cmd_go_to", "cmd_delete"];

woas["_get_special"] = function(cr, interactive) {
	var text = null;
	var pi = this.shortcuts.indexOf(cr);
	cr = "Special::" + cr;
	if (pi != -1) {
		var fn = this.shortcuts_js[pi];
		var is_cmd = (fn.substr(0,4)=="cmd_");
		if (!interactive && is_cmd)
			return null;
		text = this[fn]();
		// skip the cmd shortcuts
		if (is_cmd)
			return null;
	} else
//	log("Getting special page "+cr);	// log:0
/*			if (this.is_embedded(cr)) {
				text = this._get_embedded(cr, this.is_image(cr) ? "image":"file");
				if (text == null) {
					if (_decrypt_failed)
						_decrypt_failed = false;
					return;
				}
				this._add_namespace_menu("Special");
				
				this.load_as_current(cr, text);
				return;
			}	*/
		text = this.get_text(cr);
	if(text == null) {
		if (edit_override & interactive) {
			this._create_page("Special", cr.substr(9), true, false);
			return null;
		}
		if (interactive)
			alert("Invalid special page.");
	}
	return text;
}

woas["get_javascript_page"] = function(cr) {
	var emsg = "-", text;
	try {
		text = eval(cr);
		if (text == null)
			return null;
	}
	catch (e) {
		emsg = e.toString();
	}
	if (text == null) {
		alert("Dynamic evaluation of '"+cr+"' failed!\n\nError message:\n\n"+emsg);
		return null;
	}
	return text;
}

// Load a new current page
woas["set_current"] = function (cr, interactive) {
	var text, namespace;
	result_pages = [];
	// eventually remove the previous custom script
	this._clear_swcs();
	if (cr.substring(cr.length-2)=="::") {
		text = this._get_namespace_pages(cr);
		namespace = cr.substring(0,cr.length-2);
		cr = "";
	} else {
		var p = cr.indexOf("::");
		if (p!=-1) {
			namespace = cr.substring(0,p);
//			log("namespace of "+cr+" is "+namespace);	// log:0
			cr = cr.substring(p+2);
				switch (namespace) {
					case "Javascript":
					// this namespace will deprecate many others
					text = this.get_javascript_page(cr);
					if (text == null)
						return;
					break;
					case "Special":
						text = this._get_special(cr, interactive);
						if (text == null)
							return;
						break;
					case "Tagged": // deprecated?
					case "Tags":
						text = this._get_tagged(cr);
						if (text == null)
							return;
						break;
					case "Lock":
						pi = this.page_index(cr);
						if (key.length) {
							if (confirm("Do you want to use the last password (last time used on page \""+latest_AES_page+"\") to lock this page \""+cr+"\"?")) {
								this._finalize_lock(pi);
								return;
							}
						}
						text = this.get_text("Special::Lock");
						break;
					case "Unlock":
						pi = this.page_index(cr);
						if (!confirm("Do you want to remove encryption for page \""+cr+"\"?"))
							return;
						text = this.get_text(cr);
						if (_decrypt_failed) {
							_decrypt_failed = false;
							return;
						}
						pages[pi] = text;
						page_attrs[pi] -= 2;
						if (!this.config.key_cache)
							AES_clearKey();
						this.set_current(cr, true);
						this.save_page(cr);
						return;
					case "WoaS":
						pi = woas.page_index(namespace+"::"+cr);
						var real_t = page_titles[pi];
						if (this.is__embedded(pi)) {
							//TODO: do not use namespace to guess the embedded file type
							text = this._get__embedded(real_t, pi, "file");
						} else
							text = this.get_text(real_t);
						if(text == null) {
							if (_decrypt_failed)
								_decrypt_failed = false;
							return;
						}
						this._add_namespace_menu(namespace);
						if (namespace.length)
							cr = real_t;
						this.load_as_current(cr, text);
						return;
					case "File":
					case "Image":
						text = this._get_embedded(namespace+"::"+cr, namespace.toLowerCase());
						if(text == null) {
							if (_decrypt_failed)
								_decrypt_failed = false;
							return;
						}
						this._add_namespace_menu(namespace);
						if (namespace.length)
							cr = namespace + "::" + cr;
						this.load_as_current(cr, text);
						return;
						break;
					default:
						text = this.get_text(namespace+"::"+cr);
				}

		} else {
			namespace = "";
			text = this.get_text(cr);
		}
	}
	
	if(text == null) {
		if (_decrypt_failed) {
			_decrypt_failed = false;
			return;
		}
		if (!this._create_page(namespace, cr, true, false))
			return;
//		log("Editing new page "+namespace+cr);	// log:0
		return;
	}
	
	this._add_namespace_menu(namespace);
	if (namespace.length)
		cr = page_titles[this.page_index(namespace + "::" + cr)];
	else
		cr = page_titles[this.page_index(cr)];
	this.load_as_current(cr, this.parser.parse(text));
}

woas["swcs"] = [];

woas["_clear_swcs"] = function () {
//	setHTML(swcs, "");
	if (!this.swcs.length) return;
	for(var i=0;i<this.swcs.length;i++) {
		document.getElementsByTagName("head")[0].removeChild(this.swcs[i]);
	}
	this.swcs = [];
}

woas["create_breadcrumb"] = function(title) {
	var tmp=title.split("::");
	if (tmp.length==1)
		return title;
	var s="", partial="";
	for(var i=0;i<tmp.length-1;i++) {
		partial += tmp[i]+"::";
		s += "<a href=\"#\" onclick=\"go_to('"+this.js_encode(partial)+"')\">"+tmp[i]+"</a> :: ";		
	}
	return s+tmp[tmp.length-1];
}

woas["_activate_scripts"] = function() {
	// add the custom scripts (if any)
	if (this.parser.script_extension.length) {
//		log(this.parser.script_extension.length + " javascript files/blocks to process");	// log:0
		var s_elem, is_inline;
		for (var i=0;i<this.parser.script_extension.length;i++) {
			s_elem = document.createElement("script");
			s_elem.type="text/javascript";
			s_elem.id = "sw_custom_script_"+i;
			is_inline = new String(typeof(this.parser.script_extension[i]));
			is_inline = (is_inline.toLowerCase()=="string");
			if (!is_inline)
				s_elem.src = this.parser.script_extension[i][0];
			document.getElementsByTagName("head")[0].appendChild(s_elem);
			if (is_inline)
				woas.setHTML(s_elem, this.parser.script_extension[i]);
			this.swcs.push(s_elem);
		}
	}
}

woas["_set_title"] = function (new_title) {
	var wt=$("wiki_title");
	// works with IE6, FF, etc.
	wt.innerHTML = this.create_breadcrumb(new_title);
	document.title = new_title;
}

// actually load a page given the title and the proper XHTML
woas["load_as_current"] = function(title, xhtml) {
	scrollTo(0,0);
	log("load_as_current(\""+title+"\") - "+xhtml.length+" bytes");	// log:1
	$("wiki_text").innerHTML = xhtml;
	this._set_title(title);
	this.update_nav_icons(title);
	current = title;
	this._activate_scripts();
}

woas["_finalize_lock"] = function(pi) {
	this._perform_lock(pi);
	var title = page_titles[pi];
	this.set_current(title, true);
	if (!this.config.key_cache) {
		AES_clearKey();
		latest_AES_page = "";
	} else
		last_AES_page = title;
	this.save__page(pi);
}

woas["_perform_lock"] = function(pi) {
	pages[pi] = AES_encrypt(pages[pi]);
//	log("E: encrypted length is "+pages[pi].length);	// log:0
	page_attrs[pi] += 2;
}

var _pw_q_lock = false;

// Used by Special::Lock
function pw_quality() {

	if (_pw_q_lock)
		return;
		
	_pw_q_lock = true;

function _hex_col(tone) {
	var s=Math.floor(tone).toString(16);
	if (s.length==1)
		return "0"+s;
	return s;
}

	// original code from http://lxr.mozilla.org/seamonkey/source/security/manager/pki/resources/content/password.js
	var pw=$('pw1').value;

	//length of the password
	var pwlength=pw.length;
	
	if (pwlength!=0) {

	//use of numbers in the password
	  var numnumeric = pw.match(/[0-9]/g);
	  var numeric=(numnumeric!=null)?numnumeric.length/pwlength:0;

	//use of symbols in the password
	  var symbols = pw.match(/\W/g);
	  var numsymbols= (symbols!=null)?symbols.length/pwlength:0;

	//use of uppercase in the password
	  var numupper = pw.match(/[^A-Z]/g);
	  var upper=numupper!=null?numupper.length/pwlength:0;
	// end of modified code from Mozilla
	
	var numlower = pw.match(/[^a-z]/g);
	var lower = numlower!=null?numlower.length/pwlength:0;
	
	var u_lo = upper+lower;

	//   var pwstrength=((pwlength*10)-20) + (numeric*10) + (numsymbols*15) + (upper*10);
	  
		// 80% of security defined by length (at least 16, best 22 chars), 10% by symbols, 5% by numeric presence and 5% by upper case presence
		var pwstrength = ((pwlength/18) * 65) + (numsymbols * 10 + u_lo*20 + numeric*5);
		
		var repco = split_bytes(pw).toUnique().length/pwlength;
		if (repco<0.8)
			pwstrength *= (repco+0.2);
		log("pwstrength = "+_number_format(pwstrength/100, 2)+", repco = "+repco);	// log:1
	} else
		var pwstrength = 0;
  
	if (pwstrength>100)
		color = "#00FF00";
	else
		color = "#" + _hex_col((100-pwstrength)*255/100) + _hex_col((pwstrength*255)/100) + "00";
  
	$("pw1").style.backgroundColor = color;
	$("txtBits").innerHTML = "Key size: "+(pwlength*8).toString() + " bits";
	
	_pw_q_lock = false;
}

woas["_add_namespace_menu"] = function(namespace) {
//	log("adding namespace menu for \""+namespace+"\"");	// log:0
//	log("current namespace is \""+current_namespace+"\"");	// log:0
	if (current_namespace == namespace)
		return;
	var pi;
	if (namespace == "")
		pi = -1;
	else
		pi = this.page_index(namespace+"::Menu");
	if (pi==-1) {
//		log("no namespace menu found");	// log:0
		$("ns_menu_area").innerHTML = "";
		if (current_namespace!="") {
			$.hide("ns_menu_area");
			$.hide("ns_menu_edit_button");
		}
		current_namespace = namespace;
		return;
	}
	var menu = this.get__text(pi);
	if (menu == null) {
//		log("Could not retrieve namespace menu");	// log:0
		$("ns_menu_area").innerHTML = "";
	} else {
//		log("Parsing "+menu.length+" bytes for namespace menu");	// log:0
		$("ns_menu_area").innerHTML = this.parser.parse(menu);
	}
	// if the previous namespace was empty, then show the submenu areas
//	if (current_namespace=="") {
		$.show("ns_menu_area");
		$.show("ns_menu_edit_button");
//	}
	current_namespace = namespace;	
}

woas["refresh_menu_area"] = function() {
	var tmp = current_namespace;
	current_namespace=parse_marker;
	this._add_namespace_menu(tmp);
	var menu = this.get_text("::Menu");
	if (menu == null)
		$("menu_area").innerHTML = "";
	else {
		$("menu_area").innerHTML = this.parser.parse(menu);
		this._activate_scripts();
	}
}

woas["_gen_display"] = function(id, visible, prefix) {
	if (visible)
		$.show(prefix+"_"+id);
	else
		$.hide(prefix+"_"+id);
}

woas["img_display"] = function(id, visible) {
	if (!ie) {
		this._gen_display(id, visible, "img");
		this._gen_display(id, !visible, "alt");
	} else {
		this._gen_display(id, !visible, "img");
		this._gen_display(id, visible, "alt");
	}
}

woas["menu_display"] = function(id, visible) {
	this._gen_display(id, visible, "menu");
//	log("menu_"+id+" is "+$("menu_"+id).style.display);
}

function _auto_saver() {
	if (floating_pages.length && !kbd_hooking) {
		this.save_to_file(true);
		this.menu_display("save", false);
	}
	if (_this.config.auto_save)
		woas._asto = setTimeout("_auto_saver()", woas.config.auto_save);
}

// save configuration on exit
woas["before_quit"] = function () {
	if (floating_pages.length)
		this.save_to_file(true);
	else {
		if (this.config.save_on_quit && cfg_changed)
			this.save_to_file(false);
	}
	return true;
}

woas["setHTML"] = woas["getHTML"] = null;

// when the page is loaded - onload, on_load
woas["after_load"] = function() {
	log("***** Woas v"+this.version+" started *****");	// log:1
	
//	alert("page_titles: "+page_titles.length+"\npages: "+pages.length+"\npage_attrs: "+page_attrs.length);
	
	document.body.style.cursor = "auto";
	
	if (ie) {	// some hacks for IE
		this.setHTML = function(elem, html) {elem.text = html;};
		this.getHTML = function(elem) {return elem.text};
		var obj = $("sw_wiki_header");
		obj.style.filter = "alpha(opacity=75);";
		if (ie6) {
			$("sw_wiki_header").style.position = "absolute";
			$("sw_menu_area").style.position = "absolute";
		}
	} else {
		this.setHTML = function(elem, html) {elem.innerHTML = html;};
		this.getHTML = function(elem) {return elem.innerHTML;};
//		setup_uri_pics($("img_home"),$("img_back"),$("img_forward"),$("img_edit"),$("img_cancel"),$("img_save"),$("img_advanced"));
//		WONT WORK _css_obj().innerHTML += "\na {  cursor: pointer;}";
	}
	
	$('a_home').title = main_page;
	$('img_home').alt = main_page;
	
	if (this.debug)
		$.show("debug_info");
	else
		$.hide("debug_info");

	this.img_display("back", true);
	this.img_display("forward", true);
	this.img_display("home", true);
	this.img_display("edit", true);
	this.img_display("print", true);
	this.img_display("advanced", true);
	this.img_display("cancel", true);
	this.img_display("save", true);
	this.img_display("lock", true);
	this.img_display("unlock", true);
	
	// customized keyboard hook
	document.onkeydown = kbd_hook;

	// Go straight to page requested
	var qpage=document.location.href.split("?")[1];
	if(qpage)
		current = unescape(qpage);
		
//	this.swcs = $("sw_custom_script");

	this._load_aliases(this.get_text("WoaS::Aliases"));

	this._create_bs();	//moved here to fix bug 1898587
	this.set_current(current, true);
	this.refresh_menu_area();
	_prev_title = current;
	this.disable_edit();
	
	if (this.config.permit_edits)
		$.show("menu_edit_button");
	else
		$.hide("menu_edit_button");
	
	if (this.config.cumulative_save && this.config.auto_save)
		this._asto = setTimeout("_auto_saver(woas)", this.config.auto_save);
	
//	this._create_bs();
	
	this["_editor"] = new TextAreaSelectionHelper($("wiki_editor"));
	
	$.hide("loading_overlay");
}

woas["_load_aliases"] = function(s) {
	if (s==null || !s.length) return;
	var tmpl = s.split("\n"), cp, cpok;
	this.aliases = [];
	for(var i=0;i<tmpl.length;++i) {
		cp = tmpl[i].split(/\s+/);
		if (cp.length < 2) {
			alert("Invalid alias \""+tmpl[i]+"\", ignoring it.");
			continue;
		}
		cpok = [ new RegExp(RegExp.escape(cp[0]), "g"), tmpl[i].substr(cp[0].length).replace(/^\s+/, '') ];
		this.aliases.push(cpok);
	}
}

woas["_create_bs"] = function() {

	var s=this.get_text("WoaS::Bootscript");
	if (s==null || !s.length) return false;
	// remove the comments
	s = decode64(s).replace(/^\s*\/\*(.|\n)*?\*\/\s*/g, '');
	if (!s.length) return false;
	_bootscript = document.createElement("script");
	_bootscript.type="text/javascript";
	_bootscript.id = "woas_bootscript";
	document.getElementsByTagName("head")[0].appendChild(_bootscript);
	this.setHTML(_bootscript, s);
	return true;
}

woas["_clear_bs"] = function() {
	if (_bootscript!=null) {
		var head = document.getElementsByTagName("head")[0];
		head.removeChild(_bootscript);
		_bootscript = null;
	}
}

function ff_fix_focus() {
//runtime fix for Firefox bug 374786
	if (firefox)
		$("wiki_text").blur();
}

function search_focus(focused) {
	search_focused = focused;
	if (!focused)
		ff_fix_focus();
}

function custom_focus(focused) {
	_custom_focus = focused;
	if (!focused)
		ff_fix_focus();
}

var kbd_hooking=false;

function kbd_hook(orig_e) {
	if (!orig_e)
		e = window.event;
	else
		e = orig_e;
		
	if (!kbd_hooking) {
		if (_custom_focus)
			return orig_e;
		if (search_focused) {
			if (e.keyCode==13) {
				ff_fix_focus();
				do_search();
				return false;
			}
			return orig_e;
		}
		if ((e.keyCode==8) || (e.keyCode==27)) {
			go_back();
			ff_fix_focus();
			return false;
		}
	}

	if (e.keyCode==27) {
		cancel();
		ff_fix_focus();
		return false;
	}

	return orig_e;
}

// when the page is resized
woas["_onresize"] = function() {
	var we = $("wiki_editor");
	if (!we) {
		log("no wiki_editor");
		return;
	}
	we.style.width = window.innerWidth - 30 + "px";
	we.style.height = window.innerHeight - 150 + "px";
}

if (!ie)
	window.onresize = woas._onresize;

woas["update_nav_icons"] = function(page) {
	this.menu_display("back", (backstack.length > 0));
	this.menu_display("forward", (forstack.length > 0));
	this.menu_display("advanced", (page != "Special::Advanced"));
	this.menu_display("edit", this.edit_allowed(page));
	this.update_lock_icons(page);
}

woas["update_lock_icons"] = function(page) {
	var cyphered, can_lock, can_unlock;
	if (result_pages.length<2) {
		var pi = this.page_index(page);
		if (pi==-1) {
			can_lock = can_unlock = false;
			cyphered = false;
		} else {
			can_unlock = cyphered = this.is__encrypted(pi);
			can_lock = !can_unlock && this.config.permit_edits;
		}
	} else {
		log("result_pages is ("+result_pages+")");	// log:1
		can_lock = can_unlock = (result_pages.length>0);
		cyphered = false;
	}
	
	this.menu_display("lock", !kbd_hooking && can_lock);
	this.menu_display("unlock", !kbd_hooking && can_unlock);
	var cls;
	if (cyphered || (page.indexOf("Locked::")==0))
		cls = "text_area locked";
	else
		cls = "text_area";
	$("wiki_text").className = cls;
}

// Adjusts the menu buttons
woas["disable_edit"] = function() {
//	log("DISABLING edit mode");	// log:0
	kbd_hooking = false;
	// check for back and forward buttons - TODO grey out icons
	this.update_nav_icons(current);
	this.menu_display("home", true);
	if (this.config.cumulative_save)
		this.menu_display("save", floating_pages.length!=0);
	else
		this.menu_display("save", false);
	this.menu_display("cancel", false);
	this.menu_display("print", true);
	$.show("text_area");
	// aargh, FF eats the focus when cancelling edit
	$.hide("edit_area");
//	log("setting back title to "+_prev_title);	// log:0
	this._set_title(_prev_title);
}

function _lock_pages(arr) {
	alert("Not yet implemented");
}

function _unlock_pages(arr) {
	alert("Not yet implemented");
}

woas["edit_allowed"] = function(page) {
	if (edit_override)
		return (this.page_index(page) != -1);
	if (!this.config.permit_edits)
		return false;
	if (this.is_reserved(page))
		return false;
	return !this.is_readonly(page);
}

// setup the title boxes and gets ready to edit text
woas["current_editing"] = function(page, disabled) {
	log("current_editing(\""+page+"\", disabled: "+disabled+")");	// log:1
	_prev_title = current;
	$("wiki_page_title").disabled = (disabled ? "disabled" : "");
	$("wiki_page_title").value = page;
	this._set_title("Editing "+page);
	// current must be set BEFORE calling enabling menu edit
//	log("ENABLING edit mode");	// log:0
	kbd_hooking = true;
	this.menu_display("back", false);
	this.menu_display("forward", false);
	this.menu_display("advanced", false);
	this.menu_display("home", false);
	this.menu_display("edit", false);
	this.menu_display("print", false);
	this.menu_display("save", true);
	this.menu_display("cancel", true);
	this.update_lock_icons(page);
	$.hide("text_area");

	// FIXME!
	if (!ie)	{
		$("wiki_editor").style.width = window.innerWidth - 30 + "px";
		$("wiki_editor").style.height = window.innerHeight - 150 + "px";
	}
	
	$.show("edit_area");

	$("wiki_editor").focus();
	current = page;
	scrollTo(0,0);
}

// sets the text and allows changes monitoring
woas["edit_ready"] = function (txt) {
	$("wiki_editor").value = txt;
}

function _servm_alert() {
	if (woas._server_mode)
		alert("You are using Wiki on a Stick on a REMOTE server, your changes will not be saved neither remotely or locally.\n\nThe correct usage of Wiki on a Stick is LOCAL, so you should use a local copy of this page to exploit the save features. All changes made to this copy of Wiki on a Stick will be lost.");
}

woas["edit_page"] = function(page) {
	if (!this.edit_allowed(page)) {
		log("Not allowed to edit page "+page);	// log:1
		return;
	}
	_servm_alert();
	var tmp = this.get_text(page);
	if (tmp===null) return;
	if (this.is_embedded(page) && !this.is_image(page))
		tmp = decode64(tmp);
	// setup the wiki editor textbox
	this.current_editing(page, this.is_reserved(page));
	this.edit_ready(tmp);
}

woas["rename_page"] = function(previous, newpage) {
	log("Renaming "+previous+" to "+newpage);	// log:1
	if (newpage.match(/\[\[/) || newpage.match(/\]\]/)) {
		alert("Cannot use \"[[\" or \"]]\" in a page title");
		return false;
	}
	if (this.page_index(newpage)!=-1) {
		alert("A page with title \""+newpage+"\" already exists!");
		return false;
	}
	var pi = this.page_index(previous);
	page_titles[pi] = newpage;
	var re = new RegExp("\\[\\[" + RegExp.escape(previous) + "(\\]\\]|\\|)", "gi");
	var changed;
	for(var i=0; i<pages.length; i++)
	{
		//FIXME: should not replace within the nowiki blocks!
		var tmp = this.get_page(i);
		if (tmp==null)
			continue;
		changed = false;
		tmp = tmp.replace(re, function (str) {
			changed = true;
			return "[["+newpage+str.substring(previous.length+2);
		});
		if (changed)
			this.set__text(i, tmp);
	}
	if (previous == main_page)
		main_page = newpage;
	if (_prev_title == previous)
		_prev_title = newpage;
	return true;
}

// when a page is deleted
function delete_page(page) {
	for(var i=0; i<pages.length; i++) {
		if (page_titles[i] == page) {
			log("DELETED page "+page);	// log:1
			page_titles.splice(i,1);
			pages.splice(i,1);
			page_attrs.splice(i,1);
			woas.refresh_menu_area();
			break;
		}
	}
}

// applies some on-the-fly patches for the syntax changes in v0.9
function _new_syntax_patch(text) {
	//BUG: will also modify text contained in nowiki blocks
	text = text.replace(/(^|\n)(\+*)([ \t])/g, function (str, $1, $2, $3) {
		return $1+str_rep("*", $2.length)+$3;
	});
	
	return text;
}

// to set CSS, use setCSS(). To read CSS, always use .innerHTML
// it is a big IE6 inconsistency
function _css_obj() {
	return document.getElementsByTagName("style")[0];
}

woas["setCSS"] = function(new_css) {
	if (!ie) {
		_css_obj().innerHTML = new_css;
		return;
	}
	var head=document.getElementsByTagName('head')[0];
	var sty=document.styleSheets[0];
	sty.cssText = new_css;
}

// when save is clicked
woas["save"] = function() {
	if (this.config.cumulative_save && !kbd_hooking) {
		this.save_to_file(true);
		this.menu_display("save", false);
		return;
	}
	var can_be_empty = false;
	switch(current) {
		case "Special::Edit CSS":
			this.setCSS($("wiki_editor").value);
			back_to = null;
			current = "Special::Advanced";
			$("wiki_page_title").disabled = "";
			break;
		case "WoaS::Aliases":
			this._load_aliases($("wiki_editor").value);
		case "WoaS::Bootscript":
			can_be_empty = true;
		default:
			// check if text is empty
			if (!can_be_empty && ($("wiki_editor").value == "")) {
				if(confirm("Are you sure you want to DELETE this page?")) {
					var deleted = current;
					delete_page(current);
					this.disable_edit();
					back_or(main_page);
					this.save_page(deleted);
				}
				return;
			} else {
				// here the page gets actually saved
				this.set_text($("wiki_editor").value);
				new_title = woas.trim($("wiki_page_title").value);
				if (this.is_menu(new_title)) {
					this.refresh_menu_area();
					back_to = _prev_title;
				} else { if (!this.is_reserved(new_title) && (new_title != current)) {
						if (!this.rename_page(current, new_title))
							return false;
					}
					back_to = new_title;
				}				
			}
	}
	var saved = current;
	if (back_to != null)
		this.set_current(back_to, true);
	else // used for CSS editing
		back_or(main_page);
	this.refresh_menu_area();
	this.disable_edit();
	this.save_page(saved);
}

// push a page into history
function history_mem(page) {
	if (backstack.length>6)
		backstack = backstack.slice(1);
	backstack.push(page);
}

function printout_arr(arr, split_lines) {

	function elem_print(e) {
		return "'" + woas.js_encode(e, split_lines) + "'";
	}

	var s = "";
	for(var i=0;i<arr.length-1;i++) {
		s += elem_print(arr[i]) + ",\n";
	}
	if (arr.length>1)
		s += elem_print(arr[arr.length-1]) + "\n";
	return s;
}

function printout_mixed_arr(arr, split_lines, attrs) {

	function elem_print(e, attr) {
		if (attr & 2) {
			return "[" + printout_num_arr(e) + "]";
		}
		return "'" + woas.js_encode(e, split_lines) + "'";
	}

	var s = "";
	for(var i=0;i<arr.length-1;i++) {
		s += elem_print(arr[i], attrs[i]) + ",\n";
	}
	if (arr.length>1)
		s += elem_print(arr[arr.length-1], attrs[arr.length-1]) + "\n";
	return s;
}

// used to print out encrypted pages bytes and attributes
function printout_num_arr(arr) {
	var s = "";
	for(var i=0;i<arr.length-1;i++) {
		if (arr[i]>=1000)
			s += "0x"+arr[i].toString(16) + ",";
		else
			s+=arr[i].toString() + ",";
	}
	if (arr.length>1) {
		if (arr[arr.length-1]>=1000)
			s += "0x"+arr[arr.length-1].toString(16) + ",";
		else
			s+=arr[arr.length-1].toString();
	}

	return s;
}

woas["save_page"] = function(page_to_save) {
	log("Saving modified page \""+page_to_save+"\"");	// log:1
	this.save__page(this.page_index(page_to_save));
}

woas["save__page"] = function(pi) {
	//this is the dummy function that will allow more efficient file saving in future
	if (this.config.cumulative_save) {
		if (!floating_pages.length) {
			floating_pages.push(pi);
			this.menu_display("save", true);
		} else {
			if (floating_pages.indexOf(pi)==-1)
				floating_pages.push(pi);
		}
		log("floating_pages = ("+floating_pages+")");	// log:1
		return;
	}
	this.save_to_file(true);
}

function _get_data(marker, source, full, start) {
	var offset;
	// always find the end marker to make the XHTML fixes
	offset = source.indexOf("/* "+marker+ "-END */");
	if (offset == -1) {
		alert("END marker not found!");
		return false;
	}			
	offset += 6 + 4 + marker.length + 2;
	
	// IE ...
	var body_ofs;
	var re = new RegExp("<\\/"+"head>", "i");
	var m = re.exec(source);
	if (m != null)
		body_ofs = m.index;
	else
		body_ofs = -1;
	if (body_ofs != -1) {
		// XHTML hotfixes (FF doesn't either save correctly)
		source = source.substring(0, body_ofs) + source.substring(body_ofs).
				replace(/<(img|hr|br|input|meta)[^>]*>/gi, function(str, tag) {
					var l=str.length;
					if (str.charAt(l-1)!='/')
						str = str.substr(0, l-1)+" />";
					return str;
		});
	}
	
	if (full) {
		// offset was previously calculated
		if (start) {
			var s_offset = source.indexOf("/* "+marker+ "-START */");
			if (s_offset == -1) {
				alert("START marker not found!");
				return false;
			}
			return source.substring(s_offset, offset);
		}
	} else {
		offset = source.indexOf("/* "+marker+ "-DATA */");
		if (offset == -1) {
			alert("DATA marker not found!");
			return false;
		}
		offset += 6 + 5 + marker.length + 1;
	}
	return source.substring(offset);
}

function _inc_marker(old_marker) {
	var m = old_marker.match(/([^\-]*)\-(\d{7,7})$/);
	if (m==null) {
		return _random_string(10)+"-0000001";
	}
	var n = new Number(m[2].replace(/^0+/, '')) + 1;
	n = n.toString();
	return m[1]+"-"+str_rep("0", 7-n.length)+n;
}

woas["save_to_file"] = function(full) {
	$.show("loading_overlay");
	
	var new_marker;
	if (full) {
		new_marker = _inc_marker(__marker);
	} else new_marker = __marker;
	
	// setup the page to be opened on next start
	var safe_current;
	if (this.config.open_last_page) {
		if (!this.page_exists(current)) {
			safe_current = main_page;
		} else safe_current = current;
	} else
		safe_current = main_page;
	
	// output the javascript header and configuration flags
	var computed_js = "\n/* <![CDATA[ */\n\n/* "+new_marker+"-START */\n\nvar woas = {\"version\": \""+this.version+
	"\"};\n\nvar __marker = \""+new_marker+"\";\n\nwoas[\"config\"] = {";
	for (param in this.config) {
		computed_js += "\n\""+param+"\":";
		if (typeof(this.config[param])=="boolean")
			computed_js += (this.config[param] ? "true" : "false")+",";
		else // for numbers
			computed_js += this.config[param]+",";
	}
	computed_js = computed_js.substr(0,computed_js.length-1);
	computed_js += "};\n";
	
	computed_js += "\nvar current = '" + this.js_encode(safe_current)+
	"';\n\nvar main_page = '" + this.js_encode(main_page) + "';\n\n";
	
	computed_js += "var backstack = [\n" + printout_arr(backstack, false) + "];\n\n";

	computed_js += "var page_titles = [\n" + printout_arr(page_titles, false) + "];\n\n";
	
	computed_js += "/* " + new_marker + "-DATA */\n";
	
	if (full) {
		computed_js += "var page_attrs = [" + printout_num_arr(page_attrs) + "];\n\n";
		
		computed_js += "var pages = [\n" + printout_mixed_arr(pages, this.config.allow_diff, page_attrs) + "];\n\n";
		
		computed_js += "/* " + new_marker + "-END */\n";
	}

	// cleanup the DOM before saving
	var bak_ed = $("wiki_editor").value;
	var bak_tx = $("wiki_text").innerHTML;
	var bak_mn = $("menu_area").innerHTML;

	$("wiki_editor").value = "";
	$("wiki_text").innerHTML = "";
	$("menu_area").innerHTML = "";

	this._clear_swcs();
	this._clear_bs();
	
	var data = _get_data(__marker, document.documentElement.innerHTML, full);

	var r=false;
//	if (!this.config.server_mode || (was_local && this.config.server_mode)) {
	if (!this._server_mode)
		r = _saveThisFile(computed_js, data);
//		was_local = false;
//	}
	
	if (r) {
		cfg_changed = false;
		floating_pages = [];
	}
	
	$("wiki_editor").value = bak_ed;
	$("wiki_text").innerHTML = bak_tx;
	$("menu_area").innerHTML = bak_mn;
	
	this._create_bs();
	
	$.hide("loading_overlay");
	
	return r;
}

function erase_wiki() {
	if (!woas.config.permit_edits) {
		alert("This Wiki on a Stick is read-only");
		return false;
	}
	if (!confirm("Are you going to ERASE all your pages?"))
		return false;
	if (!confirm("This is the last confirm needed in order to ERASE all your pages.\n\nALL YOUR PAGES WILL BE LOST\n\nAre you sure you want to continue?"))
		return false;
	var static_pg = ["Special::About", "Special::Advanced", "Special::Options","Special::Import",
						"Special::Lock","Special::Search","Special::Security", "Special::Embed",
						"Special::Export", "Special::License" ];
	var backup_pages = [];
	page_attrs = [0, 0, 4];
	for(var i=0;i<static_pg.length;i++) {
		var pi = woas.page_index(static_pg[i]);
		if (pi==-1) {
			alert(static_pg[i]+" not found!");
			return false;
		}
		backup_pages.push(pages[pi]);
		page_attrs.push(0);
	}
	page_titles = ["Main Page", "::Menu", "WoaS::Bootscript", "WoaS::Aliases"];
	page_titles = page_titles.concat(static_pg);
	pages = ["This is your empty main page", "[[Main Page]]\n\n[[Special::New Page]]\n[[Special::Duplicate Page]]\n[[Special::Go to]]\n[[Special::Delete]]\n[[Special::Backlinks]]\n[[Special::Search]]", encode64("/* insert here your boot script */"), ""];
	pages = pages.concat(backup_pages);
	current = main_page = "Main Page";
	woas.refresh_menu_area();
	backstack = [];
	forstack = [];	
	return true;
}

// globla function
function _get_this_path() {
	var slash_c = (navigator.appVersion.indexOf("Win")!=-1)?"\\\\":"/";
	return _get_this_filename().replace(new RegExp("("+slash_c+")"+"[^"+slash_c+"]*$"), "$1");
}

var max_keywords_length = 250;
var max_description_length = 250;

// proper autokeywords generation functions begin here

function sortN(a,b){return b.w - a.w}

//TODO: have Special::Common Words contain all the common words
var common_words = ['a', 'the', 'is', 'for', 'of', 'to', 'in', 'an', 'be', 'that', 'all', 'or'];

function _auto_keywords(source) {
	if (!source.length) return "";
	var words = source.match(new RegExp("[^\\s\x01-\x2F\x3A-\x40\x5B-\x60\x7B-\x7E]{2,}", "g"));
	if (!words.length) return "";
	var nu_words = new Array();
	var density = new Array();
	var wp=0;
	for(var i=0;i<words.length;i++) {
		if (words[i].length==0)
			continue;
		cond = (common_words.indexOf(words[i].toLowerCase())<0);
		if (cond) {
			wp = nu_words.indexOf(words[i]);
			if (wp < 0) {
				nu_words = nu_words.concat(new Array(words[i]));
				density[nu_words.length-1] = {"i":nu_words.length-1, "w":1};
			} else
				density[wp].w = density[wp].w + 1;
		}
	}
	if (!density.length) return "";
	words = new Array();
	var keywords = "", nw = "";
	density = density.sort(sortN);
	var ol=0;
	for(i=0;i<density.length;i++) {
		nw = nu_words[density[i].i];
		if (ol+nw.length>max_keywords_length)
			break;
		keywords = keywords+","+nw;
		ol+=nw.length;
	}
	return keywords.substr(1);
}

var _br_rx = new RegExp("<"+"br\\s?\\/?>", "gi");
woas["xhtml_to_text"] = function(s) {
	return s.replace(_br_rx, "\n").replace(/<\/?\w+[^>]*>/g, ' ').replace(/&#?([^;]+);/g, function(str, $1) { if (!isNaN($1)) return String.fromCharCode($1); else return ""; });
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** import.js ***/

	function get_import_vars(data, ignore) {
		var c=[];
		// rename the variables
		data = data.replace(/([^\\])\nvar (\w+) = /g, function (str, $1, $2) {
			if (ignore && ignore.indexOf($2)!=-1)
				return "\nvar ignoreme = ";
			c.push('sw_import_'+$2);
			return $1+"\nvar sw_import_"+$2+" = ";
		});//.replace(/\\\n/g, '');
		log("collected variables = "+c);	// log:1
		
		c = eval(data+"\n["+c+"];");
		return c;
	}


woas["import_wiki"] = function(filename) {
	if(confirm("This will OVERWRITE pages with the same title.\n\nAre you sure you want to continue?") == false)
		return false;

	// set hourglass
	document.body.style.cursor= "wait";
	
	var ct = loadFile(filename);
	
	var import_css = $('cb_import_css').checked;
	var import_content = $('cb_import_content').checked;
	log("import_content = "+import_content); // log:1
	var import_icons = $('cb_import_icons').checked;
	
	// get version
	var old_version;
	var ver_str = ct.match(/<div .*?id=("version_"|version_).*?>([^<]+)<\/div>/i);
	if (ver_str && ver_str.length>1) {
		ver_str = ver_str[2];
		log("Importing wiki with version string \""+ver_str+"\"");	// log:1
		switch(ver_str)
		{
			case "0.03":
				old_version = 3;
				break;
			case "0.04": 
			case "0.04G":
				old_version = 4;
				break;
			default:
				alert("Incompatible version: " + ver_str);
				document.body.style.cursor= "auto";
				return false;
		}
	} else {
		var ver_str = ct.match(/var version = "([^"]*)";(\r\n|\n)/);
		if (!ver_str)
			ver_str = ct.match(/var woas = \{"version":\s+"([^"]+)"\s*\};(\r\n|\n)/);
		if (ver_str && ver_str.length) {
			ver_str = ver_str[1];
			log("Version string: "+ver_str);	// log:1
			switch (ver_str) {
				case "0.9B":
				case "0.9":
					old_version = 9;
				break;
				case "0.9.2B":
					old_version = 92;
				break;
				case "0.9.3B":
					old_version = 93;
				break;
				case "0.9.4B":
					old_version = 94;
				break;
				case "0.9.5B":
				case "0.9.5C":
//				case "0.9.5D": // development only
					old_version = 95;
				break;
				case "0.9.6B":
//				case "0.9.6C": // development only
					old_version = 96;
					break;
				case "0.9.7B":
//				case "0.9.6C": // development only
					old_version = 97;
					break;
				default:
					alert("Incompatible version: " + ver_str);
					document.body.style.cursor= "auto";
					return false;
			}
		} else {
			log("Maybe version 0.02? Please report as a bug");	// log:1
			old_version = 2;
			if(ct.match("<div id=\"?"+escape("Special::Advanced")))
				old_version = 3;
		}
	}

	
	// import the variables
	var new_main_page = main_page;
	var old_block_edits = !this.config.permit_edits;
	var page_names = [];
	var page_contents = [];
	var old_page_attrs = [];
	var pc = 0;

// old versions parsing
if (old_version	< 9) {
	
	var wiki;
	try {
		wiki = ct.match(/<div .*?id=(wiki|"wiki")[^_\\]*?>((.|\n|\t|\s)*)<\/div>/i)[0];
	} catch(e) {
		alert("Unrecognized file");
		document.body.style.cursor= "auto";
		return false;
	}
	
	// eliminate comments
	wiki = wiki.replace(/\<\!\-\-.*?\-\-\>/g, "");
	
	// separate variables from wiki
	var vars;
	var p = wiki.search(/<div .*?id=("variables"|variables)[^>]*?>/i);
	if (p!=-1) {
		vars = wiki.substring(p);
		wiki = wiki.substring(0, p);
	} else
		vars = "";
	
	if(old_version == 2) {
		try {
			vars = wiki.match(/\<div .*?id=("main_page"|main_page)>(.*?)\<\/div\>/i)[1];
		} catch(e) {
//			log("No variables found");	// log:0
		}
	}
	
	/* NOTES ABOUT OLD VERSIONS
	v0.9.7:
		* introduced WoaS::Aliases
	v0.9.6:
		* Special::Bootscript -> WoaS::Bootscript
		
	v0.9.5D (not released)
		* Javascript:: reserved namespace
		* some Special:: pages no more work
	v0.9.5B
		* object orientation of code
		* server_mode disappears
	v0.9.4B
		* introduced Special::Bootscript
	v0.04
		* permit_edits variable appeared here
	v0.02
		* pages were not escaped
	*/


	// get an array of variables and wikis
	var var_names = [];
	var var_values = [];
	var vc = 0;

	// eliminate headers
	wiki = wiki.substring(wiki.indexOf(">")+1);
	vars = vars.substring(vars.indexOf(">")+1);
	
	vars.replace(/<div id="?(version_|main_page_|permit_edits_|[\w_]+)"?>((\n|.)*?)<\/div>/gi, function(str, $1, $2) {
				if(old_version == 2)
					var_names[vc] = "main_page_";
				else
					var_names[vc] = $1;
				var_values[vc] = $2;
				vc++;
			});
	
//	log("Variables are ("+var_names+")");	// log:0

	// now extract the pages from old versions < 0.9
	if (import_content) {
		wiki.replace(/<div .*?id="?([^">]+)"?>((\n|.)*?)<\/div>/gi, function(str, $1, $2, $3) {
//				log("Parsing old page "+$1);	// log:0
				if (old_version != 2) {
					page_names[pc] = unescape($1);
					page_contents[pc] = unescape($2);
				} else {
					page_names[pc] = $1;
					page_contents[pc] = $2;
				}
				// throw away old special pages
				if (page_names[pc].indexOf("Special::")===0) {
					if (page_names[pc].search(/Special::Edit Menu/i)==0)
						page_names[pc] = "::Menu";
					else return;
				}
				
				old_page_attrs[pc] = 0;

				if (old_version < 9) {	// apply compatibility changes to stickwiki versions below v0.9
					page_contents[pc] = _new_syntax_patch(page_contents[pc].replace(new RegExp("(\\[\\[|\\|)Special::Import wiki\\]\\]", "ig"), "$1Special::Import]]").replace(/\[\[([^\]\]]*?)(\|([^\]\]]+))?\]\]/g,
					function (str, $1, $2, $3) {
						if ($3)
							return "[["+$3+"|"+$1+"]]";
						else
							return str;
					}));
				}
				pc++;
			}
			);

//		log("page_names is ("+page_names+")");	// log:0
	} // do not import content pages

	for(var i=0;i<var_names.length;i++) {
		if (var_names[i] == "main_page_")
			new_main_page = (old_version!=2) ? unescape(var_values[i]) : var_values[i];
		else if (var_names[i] == "permit_edits")
			old_block_edits = (var_values[i]=="0");
	}
	
}	else {	// we are importing a v0.9.x Beta

	// locate the random marker
	try {
		var old_marker = ct.match(/\nvar __marker = "([A-Za-z\-\d]+)";(\r\n|\n)/)[1];
	} catch (e) {
		alert("Marker not found!");
		document.body.style.cursor= "auto";
		return false;
	}

	if (import_css) {
		// import the CSS head tag
		var css = null;
		ct.replace(/<style\s.*?type="?text\/css"?[^>]*>((\n|.)*?)<\/style>/i, function (str, $1) {
			css = $1;
		});
		if (css!=null) {
			log("Imported "+css.length+" bytes of CSS");	// log:1
			this.setCSS(css);
		}
	}

	var data = _get_data(old_marker, ct, true, true);
	var collected = [];
	
	// for versions before v0.9.2B
	if (old_version < 92) {
		collected = get_import_vars(data);
		data = ct = null;

		var has_last_page_flag = (collected.length==14) ? 1 : 0;
		if (!has_last_page_flag && (collected.length!=13)) {
			alert("Invalid collected data!");
			document.body.style.cursor= "auto";
			return false;
		}
		
		old_block_edits = !collected[2];
		
		this.config.dblclick_edit = collected[3];
		
		this.config.save_on_quit = collected[4];
		
		if (has_last_page_flag)
			this.config.open_last_page = collected[5];
		this.config.allow_diff = collected[5+has_last_page_flag];
		
		this.config.key_cache = collected[6+has_last_page_flag];
		
		new_main_page = collected[8+has_last_page_flag];
		
		page_names = collected[10+has_last_page_flag];
		
		old_page_attrs = collected[11+has_last_page_flag];
		
		page_contents = collected[12+has_last_page_flag];
		
	} else {	// we are importing from v0.9.2 and above which has a config object for all the config flags
	
		// old-style import for content, skipping the main woas object and the marker
		// shared with v0.9.5B
		collected = get_import_vars(data, new Array('woas', '__marker', 'version', '__config'));

		//0:sw_import_current,1:sw_import_main_page,
		//2:sw_import_backstack,3:sw_import_page_titles,4:sw_import_page_attrs,5:sw_import_pages
		new_main_page = collected[1];
		if (import_content) {
			page_contents = collected[5];
			page_names = collected[3];
			old_page_attrs = collected[4];
			if (old_version==92) {
				// replace the pre tags with the new nowiki syntax
				for(var i=0;i<page_contents.length;i++) {
					// page is encrypted, leave it as is
					if (old_page_attrs[i] & 2)
						continue;
					// ignore special pages
					if (page_names[i].indexOf("Special::")===0)
						continue;
					page_contents[i] = page_contents[i].replace(/<pre(.*?)>((.|\n)*?)<\/pre>/g,
									function (str, $1, $2) {
										var s="{{{"+$2+"}}}";
										if ($1.length)
											s = "<span"+$1+">"+s+"</span>";
										return s;
									});
				}
				// done pre tags fixing
			} // v0.9.2 only
		} // do not import content pages

		// since version v0.9.5B+ we have an object oriented WoaS
		if (old_version >= 95) {
			// rename the members
			collected = [];
			data = data.replace(/([^\\])\nwoas\\["(\w+)"\\] = /g, function (str, $1, $2) {
				collected.push($2);
				return $1+"\ni__woas[\""+$2+"\"] = ";
			});//.replace(/\\\n/g, '');
			data = null;
			
			// retrieve the object containing all woas data & config
			var i__woas = eval(data+"\ni__woas");
			
			// import each member
			for(var a=0;a<collected.length;a++) {
				woas[collected[a]] = i__woas[collected[a]];
			}
			
			if (import_icons) {
				//TODO: import the icons
			} ct = null;

			i__woas = null;
		} else data=null;
		// DO NOT delete the arrays! They're referenced
//		collected = null;
	} // done importing from v0.9.2B+
}

	// this is the common import procedure
	if (import_content) {
		// add new data
		var pages_imported = 0;
		for(var i=0; i<page_names.length; i++) {
			// we are not using is_reserved() because will create chaos in case of edit_override
			if (page_names[i].indexOf("Special::")===0) {
				if ((old_version>=94) && (old_version<=96)) {
					if (page_names[i]=="Special::Bootscript") {
						pi = this.page_index("WoaS::Bootscript");
						pages[pi] = page_contents[i];
						page_attrs[pi] = 4;
						pages_imported++;
						continue;
					}
				}
				// skip special pages
			} else { // not importing a special page
				pi = this.page_index(page_names[i]);
				if (pi == -1) {
					page_titles.push(page_names[i]);
					pages.push(page_contents[i]);
					page_attrs.push( old_page_attrs[i] );
				} else {
					log("replacing "+page_names[i]);
					if (old_version==94) {
						// convert embedded files to base64 encoding
						if (old_page_attrs[i] & 4) {
							// plain copy images, which were already b64-encoded
							if (old_page_attrs[i] & 8)
								pages[pi] = page_contents[i];
							else {
								// page is encrypted, skip it
								if (old_page_attrs[i] & 2)
									continue;
							}
							pages[pi] = encode64(page_contents[i]);
						}
					} else {
						page_titles[pi] = page_names[i];
						pages[pi] = page_contents[i];
					}
					page_attrs[pi] = old_page_attrs[i];
				}
				pages_imported++;
			} // not importing a special page
		} // for cycle
		// added in v0.9.7
		if (old_version <= 96) {
			page_titles.push("WoaS::Aliases");
			pages.push("");
			page_attrs.push(0);
		}
	} // do not import content pages
	
	// apply the new main page if that page exists
	if (this.page_exists(new_main_page))
		main_page = new_main_page;
	
	this.config.permit_edits = !old_block_edits;

	// remove hourglass
	document.body.style.cursor= "auto";
	
	alert("Import completed: " + pages_imported +"/"+page_names.length.toString()+" pages imported.");
	
	// move to main page
	current = main_page;
	// save everything
	this.save_to_file(true);
	
	this.refresh_menu_area();
	this.set_current(main_page, true);
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** export.js ***/

var _export_main_index = false, _export_unix_norm = false,
	_export_default_ext;

var _title2fn;

var _export_fnames_array = [];

var _further_pages = [];

woas["_attrib_escape"] = function(s) {
	return s.replace(/"/g, '&quot;');
}

woas["_export_get_fname"] = function (title, create_mode) {
	if (typeof(_title2fn[title]) != 'undefined') {
		// return a cached title
		if (!create_mode)
			return escape(_title2fn[title]);
		return _title2fn[title];
	}
	var orig_title = title;
	// handle the valid exportable secial pages
	var sp;
	if (title.match(/::$/))
		sp = true;
	else if (this.is_reserved(title)) {
		if (title.match(/^Special::/)) {
			if (this.page_index(title)==-1)
				sp = true;
			else {
				_title2fn[title] = "#";
				return "#";
			}
		} else {
			_title2fn[title] = "#";
			return "#";
		}
	}
	if (sp) {
		// save a reference to this namespace or reserved page
		if (_further_pages.indexOf(title)==-1)
			_further_pages.push(title);
	} else {
		var pi=this.page_index(title);
		if (pi==-1) {
			alert("Page does not exist: "+title);
			_title2fn[title] = "#";
			return "#";
		}
		// beware: a special page or namespace index page cannot be main page considering the below code
		if (_export_main_index && (title==main_page)) {
			_title2fn[title] = "index."+_export_default_ext;
			_export_fnames_array.push(_title2fn[title]);
			return _title2fn[title];
		}
	}
	var ext = "";
	if (!sp && this.is__embedded(pi)) {
		title = title.substr(title.indexOf("::")+2);
		if (!this.is__image(pi))
			ext = "."+_export_default_ext;
//		emb = true;
	} else {
		ext = "."+_export_default_ext;
//		emb = false;
	}
	var fname = title
	// convert UTF8 characters to something else (cross-browser safe cheap solution)
	.replace(/[^\u0000-\u007F]+/g, function ($1) {
		var l=$1.length, r="";
		for(var i=0;i<l;i++) {
			switch ($1[i]) {
				//TODO: add most common diacritics
				case "\u00e2":
					r+="a";
					break;
				default:
					r+="_";
			}
		}
		return r;
	})
	// escape some path-unsafe characters
	.replace(/[:\\\/<>?#=!]+/g, function($1) {
		return str_rep("_", $1.length);
	});
	
	if (_export_unix_norm)
		fname = fname.toLowerCase().replace(/\s+/g, "_").replace(/::/g, "-");
	else
		fname = fname.replace(/::/g, " - ");
	var test_fname = fname+ext, i=0;
	while (_export_fnames_array.indexOf(test_fname)!=-1) {
		log(test_fname+" already created, checking next fname");	// log:1
		test_fname = fname+str_rep("_", ++i)+ext;
	}
//	if (i)		_export_replace_fname[fname+str_rep("_", i-1)+ext] = test_fname;
	_export_fnames_array.push(test_fname);
	_title2fn[orig_title] = test_fname;
	if (!create_mode)
		return escape(test_fname);
	return test_fname;
}

woas["export_parse"] = function (data, js_mode) {
	// a normal wiki page, parse it and eventually execute the attached javascript
	data = this.parser.parse(data, true, js_mode);
	if (js_mode) {
		wt = $("wiki_text");
		wt.innerHTML = data;
		this._activate_scripts();
		data = wt.innerHTML;
	}
	return data;
}

woas["export_one_page"] = function (
		data, title, fname, exp) {
	// convert UTF8 sequences of the XHTML source into &#dddd; sequences
	data = this.utf8_encode(data);
	// prepare the raw text for later description/keywords generation
	var raw_text = this.trim(this.xhtml_to_text(data));
	if (exp.exp_menus) {
		var _exp_menu = this.get_text("::Menu");
		if (_exp_menu == null)
			_exp_menu = "";
		var _ns = this.get_namespace(title);
			if (_ns.length) {
				var mpi = this.page_index(_ns+"::Menu");
				if (mpi != -1) {
					var tmp=this.get_text_special(ns+"::Menu");
					if (tmp!=null)
						_exp_menu += tmp;
				}
			}
			if (_exp_menu.length) {
				_exp_menu = this.parser.parse(_exp_menu, true, exp.js_mode);
				if (exp.js_mode)
					this._activate_scripts();
				// fix also the encoding in the menus
				_exp_menu = this.utf8_encode(_exp_menu);
			}
			data = '<div class="menu_area" id="sw_menu_area" style="position: fixed;"><div class="wiki" id="menu_area">'+_exp_menu+'</div></div><div class="text_area" id="wiki_text">'+data+'</div>';
		}
		data = "<ht"+"ml><he"+"ad><title>"+this.xhtml_encode(title)+"</title>"+exp.css+
		'<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />'+"\n"+
		'<meta name="generator" content="Wiki on a Stick v'+this.version+'" />'+"\n"+
		'<meta name="keywords" content="'+this.utf8_encode(this._attrib_escape(_auto_keywords(raw_text)))+'" />'+"\n"+
		'<meta name="description" content="'+
		this.utf8_encode(this._attrib_escape(raw_text.replace(/\s+/g, " ").substr(0,max_description_length)))+'" />'+"\n"+
		exp.meta_author+
		exp.custom_bs+
		"</h"+"ead><"+"body>"+data+"</bod"+"y></h"+"tml>\n"; raw_text = null;
	return saveFile(exp.xhtml_path+fname, _doctype+data);
}

woas["export_wiki"] = function () {
	// export settings object
	var exp = {};
	try {
		exp["xhtml_path"] = $("woas_ep_xhtml").value;
		var img_path = $("woas_ep_img").value;
		exp["js_mode"] = 0;
		if ($("woas_cb_js_dyn").checked)
			exp.js_mode = 1;
		else if ($("woas_cb_js_exp").checked)
			exp.js_mode = 2;
		var sep_css = $("woas_cb_sep_css").checked;
		exp["exp_menus"] = $("woas_cb_export_menu").checked;
		_export_main_index = $("woas_cb_index_main").checked;
		_export_default_ext = $("woas_ep_ext").value;
		exp["meta_author"] = this.trim($("woas_ep_author").value);
		if (exp.meta_author.length)
			exp.meta_author = '<meta name="author" content="'+this._attrib_escape(this.xhtml_encode(exp.meta_author))+'" />'+"\n";
		_export_unix_norm = $("woas_cb_unix_norm").checked;
	} catch (e) { alert(e); return false; }
	
	$.show("loading_overlay");
	$("loading_overlay").focus();
	exp["css"] = _css_obj().innerHTML;
	// reset export globals - remember that arrays are object and cannot be initialized in 1 line
	_export_fnames_array = [];
	_title2fn = {};
	if (sep_css) {
		var css_path = "woas.css";
		_export_fnames_array.push(css_path);
		saveFile(exp.xhtml_path+css_path, exp.css);
		exp.css = '<link rel="stylesheet" type="text/css" media="all" href="'+css_path+'" />';
	} else
		exp.css = '<style type="text/css">'+exp.css+'</style>';
	exp["custom_bs"] = "";
	if (exp.js_mode==2) {
		data = pages[this.page_index("WoaS::Bootscript")];
		if (data!=null && data.length) {
			saveFile(exp.xhtml_path+"bootscript.js", data);
			exp.custom_bs = '<sc'+'ript type="text/javascript" src="bootscript.js"></sc'+'ript>';
		}
	}

	var l=page_titles.length, data = null, fname = "", done=0, wt=null;
	for (var pi=0;pi<l;pi++) {
		// do skip physical special pages
		if (page_titles[pi].match(/^Special::/)) continue;
		// do skip menu pages (they are included in each page)
		if (page_titles[pi].indexOf("::Menu")==page_titles[pi].length-6) continue;
		data = this.get_text_special(page_titles[pi]);
		if (data == null) continue;
		fname = this._export_get_fname(page_titles[pi], true);
		if (this.is__embedded(pi)) {
			if (this.is__image(pi)) {
				if (!this._b64_export(data, img_path+fname))
					break;
				// image export was successful, continue to next page
				else { ++done; continue; }
			} else
				// show the embedded files inline
				data = '<pre class="wiki_preformatted">'+this.xhtml_encode(data)+"</pre>";
		} else
			data = this.export_parse(data, exp.js_mode);
		if (!this.export_one_page(data, page_titles[pi], fname, exp))
			break;
		++done;
	}
	log("pages yet to process: "+_further_pages);	// log:1
	// process further pages
	var title;
	// exchange arrays to parse at some extent
	var eatable = _further_pages.slice(0);
	while (eatable.length) {
		_further_pages = [];
		for(var i=0;i<eatable.length;i++) {
			title = eatable[i];
			data = this.get_text_special(title);
			if (data===null) {
				log("cannot process "+title);
				continue;
			}
			//TODO: allow special pages to have extended attributes
			data = this.export_parse(data, exp.js_mode);
			if (this.export_one_page(data, title, _title2fn[title], exp))
				++done;
		}
		eatable = _further_pages.slice(0);
	}
//	_further_pages = [];
	if (exp.js_mode) {
		this.refresh_menu_area();
		this.set_current(current, false);
	}
	$.hide("loading_overlay");
	alert(done+" pages exported successfully");
	return true;
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** editor.js ***/

woas["wiki_buttons_display"] = function (v) {
	$('wiki_format_buttons').style.display = v ? 'block' : 'none';
	$('wiki_format_buttons').style.visibility = v ? 'visible' : 'hidden';
}

woas["html_buttons_display"] = function (v) {
	$('html_format_buttons').style.display = v ? 'block' : 'none';
	$('html_format_buttons').style.visibility = v ? 'visible' : 'hidden';
}

// submitted by pr0xy

function TextAreaSelectionHelper(obj) {
 this.target=obj;
 this.target.carretHandler=this; // ?
 this.target.onchange=_textareaSaver;
 this.target.onclick=_textareaSaver;
 this.target.onkeyup=_textareaSaver;
 this.target.onfocus=_textareaSaver;
 if(!document.selection) this.target.onSelect=_textareaSaver; // ?
 
 this.start=-1;
 this.end=-1;
 this.scroll=-1;
 this.iesel=null; // ?
}

TextAreaSelectionHelper.prototype.getSelectedText=function() {
	return this.iesel? this.iesel.text: (this.start>=0&&this.end>this.start)? this.target.value.substring(this.start,this.end): "";
}

TextAreaSelectionHelper.prototype.setSelectedText=function(text, secondtag) {
 if(this.iesel) {
if(typeof(secondtag)=="string") {
  var l=this.iesel.text.length;
     this.iesel.text=text+this.iesel.text+secondtag;
  this.iesel.moveEnd("character", -secondtag.length);
   this.iesel.moveStart("character", -l);   
} else {
  this.iesel.text=text;
}
   this.iesel.select();
 } else if(this.start>=0&&this.end>=this.start) {
    var left=this.target.value.substring(0,this.start);
    var right=this.target.value.substr(this.end);
 var scont=this.target.value.substring(this.start, this.end);
 if(typeof(secondtag)=="string") {
   this.target.value=left+text+scont+secondtag+right;
   this.end=this.target.selectionEnd=this.start+text.length+scont.length;
   this.start=this.target.selectionStart=this.start+text.length;    
 } else {
      this.target.value=left+text+right;
   this.end=this.target.selectionEnd=this.start+text.length;
   this.start=this.target.selectionStart=this.start+text.length;
 }
 this.target.scrollTop=this.scroll;
 this.target.focus();
 } else {
   this.target.value+=text + ((typeof(secondtag)=="string")? secondtag: "");
if(this.scroll>=0) this.target.scrollTop=this.scroll;
 }
}

TextAreaSelectionHelper.prototype.getText=function() {
 return this.target.value;
}
TextAreaSelectionHelper.prototype.setText=function(text) {
 this.target.value=text;
}

function _textareaSaver() {
 if(document.selection) {
   this.carretHandler.iesel = document.selection.createRange().duplicate();
 } else if(typeof(this.selectionStart)!="undefined") {
   this.carretHandler.start=this.selectionStart;
this.carretHandler.end=this.selectionEnd;
this.carretHandler.scroll=this.scrollTop;
 } else {this.carretHandler.start=this.carretHandler.end=-1;}
}

function	DivTagThis(align) {
	TagThis('<div align="'+align+'">', '</div>');
}

function TagThis(starttag, endtag){
	woas._editor.setSelectedText(starttag, endtag);
}

function FullTagThis(tag){
	woas._editor.setSelectedText('<'+tag+'>','</'+tag+'>');
}

function setUrl(starttag,centertag,endtag) {
	var url=prompt('Link:','http://');
	if (url===null) return;
	var comm=prompt('Link text:','');
	if (comm===null) return;
		woas._editor.setSelectedText(starttag+woas.js_encode(url)+centertag,comm+endtag);
}

function setWikiImage() {
	setImage('[[Include::Image::',']]');
}

function setHTMLImage() {
	setImage('<img src=\'','\' />');
}

function setWikiUrl() {
	setUrl('[[','|',']]');
}

function setHTMLUrl() {
	setUrl('<a href=\'','\' target=_blank>','</a>');
}

function setImage(starttag,endtag) {
	var pic=prompt('Image:','');
	if (pic!==null)
		woas._editor.setSelectedText(starttag,woas.js_encode(pic)+endtag);
}

function setTag() {
        var tag=prompt('Set tag:','');
	if (tag!==null)
	woas._editor.setSelectedText("[[Tag::",tag+"]]");
}

/* ]]> */ </script>
<script language="javascript" type="text/javascript">
/* <![CDATA[ */
/*** ui.js ***/
/* This file contains javascript used by user interface */
// no references to 'this' are allowed - global woas object is used

// when home is clicked
function home()
{
	go_to(main_page);
}

// when Advanced is clicked
function advanced()
{
	go_to("Special::Advanced");
}

// follows a link
function go_to(cr)
{
	if(cr == current)
		return;
	history_mem(current);
	forstack = [];
	woas.set_current(cr, true);
}

function back_or(or_page) {
	if (!go_back())
		woas.set_current(or_page, true);
}

// when Back button is clicked
function go_back()
{
	if(backstack.length > 0)
	{
		forstack.push(current);
		woas.set_current(backstack.pop(), true);
		return true;
	}
	return false;
}

// when Forward button is clicked
function go_forward()
{
	if(forstack.length > 0)
	{
		history_mem(current);
		woas.set_current(forstack.pop(), true);
	}
}

// when cancel is clicked
function cancel() {
	if (!confirm("Are you sure you want to cancel this edit?"))
		return;
	if (kbd_hooking)
		woas.disable_edit();
}

function save() {
	woas.save();
}

// when edit is clicked
function edit() {	woas.edit_page(current);	}

function lock() {
	if (result_pages.length)
		_lock_pages(result_pages);
	else
		go_to("Lock::" + current);
}

function unlock() {
	if (result_pages.length)
		_unlock_pages(result_pages);
	else
		go_to("Unlock::" + current);
}

function menu_dblclick() {
	if (!woas.config.dblclick_edit)
		return false;
	edit_menu();
	return true;
}

function ns_menu_dblclick() {
	if (!woas.config.dblclick_edit)
		return false;
	edit_ns_menu();
	return true;
}

function page_dblclick() {
	if (!woas.config.dblclick_edit)
		return false;
	edit();
	return true;
}

function edit_menu() {
	woas.edit_page("::Menu");
}

function edit_ns_menu() {
	woas.edit_page(current_namespace+"::Menu");
}

/** Used by search box **/

function menu_search_focus(f) {
	if (f) {
		if (current == "Special::Search") {
//		ff_fix_focus();
			$('string_to_search').focus();
		} else
			search_focused = true;
	} else {
		if (current != "Special::Search")
			search_focused = false;
	}
}

function menu_do_search() {
    if (current == "Special::Search") {
	$('string_to_search').value = $('menu_string_to_search').value;
       do_search($('menu_string_to_search').value);
    } else {
	_raw_do_search($('menu_string_to_search').value);
    }
}

function _raw_do_search(str) {
       cached_search = woas.parser.parse(woas.special_search( str ));
       woas.assert_current("Special::Search");
}

// Used by Special::Search
// make the actual search and cache the results
function do_search() {
	var search_string = $("string_to_search").value;
	if ( !search_string.length )
		return;
	_raw_do_search(search_string);
}

// Used by Special::Options page
function save_options() {
	if (!woas.config.permit_edits) {
		alert("This Wiki on a Stick is read-only");
		return false;
	}
	woas.save_to_file(false);
	woas.set_current("Special::Advanced", true);
}

function ro_woas() {
	if (!woas.config.permit_edits) {
		alert("Sorry, this WoaS is already write-protected");
		return false;
	}
	if (confirm("Are you sure you want to set this WoaS as read-only? You will have to manually edit the file to revert this change.")) {
		woas.config.permit_edits = false;
		woas.save_to_file(false);
		woas.set_current("Special::Advanced", true);
	}
}

//TODO: make procedural
function open_table_help() {
	var w = woas.popup("help", 350, 200, ",menubar=no,toolbar=no,location=no,status=no,dialog=yes");
	w.document.writeln("<html><head><title>Building tables<\/title><\/head><body>");
	w.document.writeln("<u>Building tables:<\/u><br /><br />");
	w.document.writeln("<tt>{|   <\/tt><br />");
	w.document.writeln("<tt>|+ Table Caption<\/tt><br />");
	w.document.writeln("<tt>| *colum 1* || *column 2* || *column 3*<\/tt><br />");
	w.document.writeln("<tt>|-<\/tt><br />");
	w.document.writeln("<tt>| line 2 || [[a link]] || something<\/tt><br />");
	w.document.writeln("<tt>|-<\/tt><br />");
	w.document.writeln("<tt>| line 3 || || more stuff<\/tt><br />");
	w.document.writeln("<tt>|}   <\/tt>");
	w.document.writeln("<\/body><\/html>");
	w.document.close();
}

// Used by Special::Lock
function lock_page(page) {
	var pwd = $("pw1").value;
	if (!pwd.length) {
		$("pw1").focus();
		return;
	}
	if (pwd!=$("pw2").value) {
		$("pw2").focus();
		return;
	}
	var pi = woas.page_index(page);
	AES_setKey(pwd);
	woas._finalize_lock(pi);
}


function import_wiki() {
	if (!woas.config.permit_edits) {
		alert("This Wiki on a Stick is read-only");
		return false;
	}
	var filename = $("filename_").value;
	if(filename == "") {
		alert("A file must be selected");
		return false;
	}
	return woas.import_wiki(filename);
}

function set_key() {
	woas._set_password();
}
/* ]]> */ </script></head><body class="bg" id="body" style="cursor: auto;" onload="woas.after_load()" onunload="woas.before_quit()">
<div id="loading_overlay" style="display: inline; visibility: visible;"><noscript><h1>If you are seeing this text, your browser is not javascript-enabled. Sorry, WoaS is a javascript application</h1></noscript>Loading...</div>
<div style="visibility: hidden;" id="woas_pwd_mask">
<div style="visibility: hidden;" id="woas_pwd_query">
<form id="stealthpwd" action="" onsubmit="woas._password_ok(); return false">
<h3>Enter a decryption password</h3>
<p><input name="woas_password" id="woas_password" size="16" type="password" /><br /><br />
<input value="OK" type="submit" />&nbsp;<input value="Cancel" onclick="woas._password_cancel()" type="button" /></p>
</form>
</div>
</div>
<div class="wiki_header bg" id="sw_wiki_header" style="position: absolute;">
<table width="100%" cellspacing="0">
<tbody><tr>
<td><span class="title" id="wiki_title"><a href="#" onclick="go_to('TuxedoAdapter::')">TuxedoAdapter</a> :: receiveConversationData()</span></td>
<td align="right">
<div id="menu_back" style="display: inline; cursor: pointer; visibility: visible;"><a title="Back" onclick="go_back()"><img id="img_back" style="display: inline; visibility: visible;" alt="Back" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABexJREFUeNp9lWuMlkcVx39n5nned9+9sO6yLCy3XSg1LAVES2Itoi1YoynGJtbGhDQa+8VUqyFqtI0aYiQWEz/VSzTapImJmlY/tIENASzQ7SVtdVfcpiqUTYGyyy6yu+x7eZ5nLscP70u6UeMkk5kzk/P/zzkzc/7Cfzdp9dgyho3hboFtCv2t9WlVxqLyPDDZ8rOtPeX/NNMCR+Bea3geyFtOccl4c14zhmeBXf/pv/S0S8Ej0G+EXyvsUyX2dIrs3mLj9iGjvcuQwsPF2ah/Phdl7EI0hQcRBOVJhUeAegtXlxLcBN9sDCMxMrS8C/foZ0vy+T2p7VsuoogSjAQfNfeBhZoycTHwq2M+/OHFSFQSEV5X5V5g5iaJLGFbaw2jITL44WHjfvdoR7JmqF1i3Wp0KibWcdkCDZ+ShTK5C6ioiiAjrwd97Cnn5qqURHhVlT1A7ebFNEMQno7K7Xdvte7Y4a60d3kvRb5CSPskKZeZb1RY6N5HR+qxxRTRlMiLKDfqqreuEd6/ySQnx2ORFayn+RieA4xt5elBhW+s7hU3cqiS9r6nS13ol6RjAFtZzuyNNm4MfY+VOw9g+j8KV0fw2XUiCarIfA1ZvRwd6MWeGNcI7AROA5MGEBG+CnBwf8msGbDq8rLYchemrYeZah/1Dd9lw7aPkbgZbMcgptyLISAiiEAphbkq7N5qZM/7RFsZ+VpzFO6Kys4NK0XvvzMxsapYazDGM3u9oLH2IQY330FwOVoZwJw7BPPjkC4DERALGIwgzqOf+mAzK1HZC2wyRrgHYO8OG3s6hcwhhgVmr1Wpr32YwffuJIYcY8skfzsAE48TvCdm84SsSshqhKKBCGQFsmGVsL6fAHSJsDsBdgBsHzK4IBA9s/NlasPfZ3B4FyGbw5S7WZweo/GvKnHVl3HOU3hP4Rw+CKY6Sbg8ig+WcgqDK4SLM4rAjkSVlQC9nUjhReq1BgsbD7Jhy1587SpiK8R8gfaeW2jb9QSEAo0FMWREX6AxQzRw7uS3mTt7lLb2Et2d4eY3Xp3c/Gw+Qu4juYfuSkGMnhgcRiwKiClj8CgF4BANGAlEdaSlLpKOAZyHNIrou9VIEhGuoTA9p1q4oAVtYv9+mKx7HeW1+4jFdSTtwl09Q3H1DJp0412ODxEfAj5CY3GWS2efAWvIXdC5xRa8MpMAE8A9f52M5F7JnIDmuNEv0X3nz2hb+wlCPo9UVlO9dIrFS2MEK+ROyRxkBWQOCixRDfWGcnFWW/hMmKicBHjhjSDTcxEXotZ9Sr2IXD39MLW3j4BpI9pOeu76Dcm6j9Dw4Gwn3lYISRsxKVN4AVGdnFIuX8MCmSpnjConjfDm5WuYI68FTRJYbHga3lIvApf+9BUWL44gRohukZUfOgTt66nVqmRFICs8eRHInKLAiTFt6ojwIjBhWky/APj5kRAuTEcBdLHuaThLLQ+cP36AucljpOVl2KSdgg4aeTM1uYNqppRT9LV/qLz0ZvOKVfnJ0nJdEuFlVT6wY6P4w19MknKCZgWSJAaNHqTEytseoL7wDtPnThBIKJzScFApoW9NqRx+OrrFOinwLPDpZiDvasF2I7wQlWVbh8R/836TrOsTrefgg0iMSpH5po7aBB8UETSxyF/OK78ciW6hRirCpCq7gClahUSlSTJ9+ybzCvCZt6a0cvosznmhrxtpLyvWCjZNxSQWIaqPyOVryjOjGn9/WkMjJ13Vw6VKiU/WcyZbB9elkmnHn2gPpcTcdt8Pst/+8x2/DYjL2oUtgzauX6HS2RbFR7i+iF6YUj1/BVP4ppwMr5NTP/yC3X98PF756XPRGCFGBaxpot+1zeL+2Gnc0S7qR9eXHn9o4JFV/T3n/4fQL7XjLQNy9jufS/a/9OOSnPlRKk993ZqOtiWin5hmmXjsgZRDD5a5URfT1Q4L3ffFfOPBysuvvLrn+MlTH58YG906N/VGH2Jib6fMDK+T8Ts2m5Gdt5rRUqr+ynU11YaqiOq3ngxMvK0YgX8Db1YRHvYQ7IQAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC" /><span id="alt_back" style="display: none; visibility: hidden;">&nbsp;<strong>[Back]</strong>&nbsp;</span></a></div>
<div id="menu_forward" style="display: none; cursor: pointer; visibility: hidden;"><a title="Forward" onclick="go_forward()"><img id="img_forward" style="display: inline; visibility: visible;" alt="Forward" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABf1JREFUeNp9lX+MVUcVxz9n7r3v7ntvd4G3CywL7KLBCJWlYLGmKWgBtVGM0Yj80zSaqLVp0n+0/qDxD00kjU2aaKoxKm1CYqJNq6kQuiFCkBawKVS2uIYohYUFusvuwr4f+37ce2fm+Mc+ZKPGSSYzZybne86ZM+d8hf8e0p6+Law3hu0CQwrL2ueTqpzzynFgrK0XtO+U/zNMGxyBXYHhOJC0lfyC9c6+bgwHgQf/U3+htwvBPbDMCC8ofFYVv6RTZNs9gd+4xmipG0ktjE97ffuil3OXvUktiCAoLyo8CTTauLrQwB3wdcYw7D1rerrI9n4pJ1/eEQW9PSIKijViHZpaS6WujI479h+x7venPF4JRTiryi5g6o4RWWBtVWA46TyDW9eb7Hd7i+HKNQXxjVA1taKagpuj0XQ0fJEktSiqYpDhs06fPpBls3PkRHhLlR1A/U5i5kMQXvbKfds3BNmRH3dFpZ4SabJUJCpJkOvG+ozx+iCmOEDeXsFLTJKpVBuqH1gpbF5rwmMjPm2lDDD/GQ4BJmi/06MKT/WXJBvel49Ki7s0c8skKvahuWWYKORyZZD4/v30DH0V7Bx26hTedKCqUq6r9PeIrigRHB1RD2wBTgBjASBG2K/Q/9zXYh76SCRZq0vCQi8a90FuNUYdPr+K3nVfIHBlpO9h1NVoTZzCSoxXpVKH968QuXJT/dhNjBEWK7wUiLBdlb3vWy7606/HEqtgooJouASJFoMpoAj5dBRVh5a2QXKLqO8T+KxG/cZfsBKTOS/Oo90FzJG3VRRWAi8HgeExVbbt3hr6PVsjaSVIlAsQcYgmiC9j7DSS3SJ47zcYTaFnKy6pEPfvwGVVKtfewklEM1HpKsDpC95X6nSIMBICmwA2rjFkFjxKuVzldnQvYXE5SAiq4FcgDJL87Tid3E/PwGay5iw9H/4eSWa5evYA1ueII2VwqTA+pQhsClVZDlDqRBJnpFWvcrXrCdbu3EdkLJgcIsF81ajHuwxxZXzWBASbzLJiy1PMVW9zeeQQHYUcizrdnTLu/3dpWw+ZVRopLO8fZFF3kVwIcSTEEXSEShx6Ch1CnAvxzgKKuhQRQ2ffFjILzovo3W4koQgzKEzOqiaZVSeR5K78hGpBCAt9gAMMqmCM0Jgr0+wYondpH2nSJMgVacyOMXbm16iBNHM6W2vDK1MhMAp88p0xT2KVZhagtVskb36HIACR+RSICM26csk/wL2f+yjezhGEMUltgvOHnqAycx2ViGrTMT6tbXxGjVeOAbzxdyeTs57MqTasoUmRhi/QcEVadFFpKhdlJ5t3v8Di7hBPQDI3yfk/Pk55ZhxncoDXsQm4PkMAtFR53ahyzAgXrs9gDp9xGoZQa3qaiaWROBqpp9WscS1Zx9BnnqE7qpBlSjo3yTuvfoPyzDjexDQThwJHz+k8jwingFHTtvRLgF8cdu7ypBdAa02lmSiNVKk2oNBVorSoiEqBdG6Cc68+zuz0ONbE1BqWOIee+YfK6QvzKVblZwub3TkRdjUSVl24pvZjQyYwBm20EOsUqyFZ7Spps0zaqjJ69IeUp8dxkqPedORj9NKEyvMHfZZmRMBB4Afzgdzlgo1GeMMr3RvWiP32bhOu7hVtJJBZRBWy1GIdqBjUBKBOw0Dkr+8qvxr2WaVOJMKYKg8CE4AEbVIwwOR9a82bwBcvTWj+xHmyzELvIqTQAYERgiiUIAwwAWqdl+sz8MpJ9S+dUNdMiPqWcC2f49ONhLG247qQMoOR5wsuF5oPff5Hrd/+84YdAnx3Ae4ZED+wDOnsQKyH2zWjY5PoxRvOpHaeTtavlj8/85XgkT+N+Pd+fsgbI3ivQGDm0R8aCsj+0Gnsa13UD6/OPfvYwJODffl3/wfR35XF+LX98fnv7zGPnH4uJ68/G8mBbwWm2LGA9EMz3yae3hOx79GYWl1NoStP0Nvva7Od+aNnqjuOnp3+1Ojl6obZWtaLWt+7amhq46YtIzt3fHz4gQ/qycqZb9rrN6tmrmVURPW7LzpGrypG4F/y5h6hh4BiQgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=" /><span id="alt_forward" style="display: none; visibility: hidden;">&nbsp;<strong>[Forward]</strong>&nbsp;</span></a></div>
<div id="menu_advanced" style="display: inline; cursor: pointer; visibility: visible;"><a title="Advanced" onclick="advanced()"><img id="img_advanced" style="display: inline; visibility: visible;" alt="Advanced" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABcZJREFUeNqNVW1MlFcWfs657ywdhqXIsJRkDNuFTmKklXZTR6g7Wxs1BQsmVRvaNE2JydYlrOy6MTGrpg20KT/Kpqi7bnRd+0cEbWs/BJtqSIpJK5GMFLrQbUH5mhEWmJ2BwMI473tPf8w7Feyy6Ulubm5yz3me+9zzAaxgRORi5mKlVBoRAQDba0UXAGrJ+f/dhRPAJQACYBDAH5nZuSTQvaYSnAjM/HMiKl7pLttsz+fl5cnFixfj+/fvt9LT0wXAN0T0yP9wTDyP+T4AhwDM2MTevPd5DICYGQA6fT6fjIyMmOFw2Ors7IwVFRUJgGEiylziQ7ac2wHcdLlcsmfPHqu6utokIgFQv0RyAjMb9mEdgEmfzyc3btywpqenpbu7O5aamioAnrd9HPb+SwC6rKxMWlpa4pcuXbI6OzutTZs2CYBvkh/hFJELWut/MfNGEek1DKPy+vXrmJ6eFrfbLatWrWKn0wkAypYxuZd4vV46fPhwzDAMg4hoYGBArl27BgAnmRK3znu93mdLS0vztdYfK6W2m6b5jMfjQV5eHiKRCHp6eoxwOAwAfSICAJYNsBEA0tLSVFZWluTm5lpNTU0qFot1M/MxMPM6APFz585Z8/Pz8fLycguA5OTk6EOHDklfX5/09vZaFRUVAmDMMAyXLSMAHGFmOXXqlHnkyBGzrq5OV1VVWcwsAHYm8kupVAADBw4ckKmpKWtoaMhqb2+PDw0NmaFQSPr7+3UwGNRnz541U1JSBMDf7EQ4CkBOnz4dP3bsmAlA22uciO5mkM2kITc3V0ZHR2MzMzMyNzenZ2dn9dzcnBWJRPTw8LCIiL58+bKkpqaaAL4kIvPEiRNWY2PjHQBCRCeZ+SFmdi1NX2XncH80Gn1pYGAgff369WY0GkUgEKD6+npmZvj9fnzW0UEOQ8nI8IjcvHUz5/jx47KwsIB9+/YZRHQCwB4R+Y+IxO24ellJE9GTACZSUlLE6XRqADEAQ1lZPzPLysqECRqAKIN0Y+PbZkNDg2kzf/vHtJJkNWYAKAGwnYgeNAwjnYlHwSSZrqes1T95QbYW10hdXZ1mJhOAMHPNPXWxovEPMImaAMi65/5gnvl8WNdVN0k2fiNAjhQVP67feqvBskGqbSfjx4AoAASi8wCk4NnfmS19E7p/flFebPxIHnLv04BH/+rXRSIi+uDBgyYAUUrtToLYkq0oFYGoxQ5+p+Xrf+veqVn9ctNnuvS1d+ThxytMAOarr70q4+PjEg6HrZqamqRcLySJrgRCAJYHn5zRlc0d+umD/5B1RbtMgDQr1q2trdbg4KB0dXXJ2NiYtXv3bguAdrvd21avXv0DyZOHvwIkBTv3xpr7JnTv1Gwi+J9OSeETz90hsBDRewA6PB6PtLW1xQOBgFy5ckUCgUDc7/dLdnZ2d3NzM/Lz878PTAC0UioXQOX9jo3Y/9u9jsK8Vfjz5RsY/2qQJjo+jfd+8b5DoD8SkV1EtCsUCv2zqqrKuH37dnxiYgK3bt1S27Ztw+TkpCc9PT0zMzMTAEjZICIiXgDVufc/qfMdLjrX8y0i4WlMtH9i9nzxruPRxwo/mJ2d3RWPxxnAHDN/HI1Gy7q6urI3bNgQdzgcZkNDg+HxeL5yu91/OXPmTKJL2N0UO3bszMx+IHPSRY+IR1XFfvHTvfGHH62IAZAtW7ZcqK2tTY7F5HCCUupBAP1KKXE4HJKRkRE+evRo8Zo1a+5+tN24uK2tDbW1tb9PVGeGxZxtApDi4uILIyOjqrKykgCQYSRSnW1Hv9+fVl9fv8PhcLxYUFDwgNfr/b5wYbMAAJSXl9Pi4iJOnvz70yWlW5o3PbXxw9ffeP2VsbExIxgMUigUos2bNy/z8fl8dPXqVSopKYHdbpYHX5ZGzGhtbWURwfz8f7GwsIhIJIpgMMjj4+MUjUYRDodRWFgIAFi7di3a29uxdetWIDHdDKKkgnftO1VKiuX0HbQtAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==" /><span id="alt_advanced" style="display: none; visibility: hidden;">&nbsp;<strong>[Advanced]</strong>&nbsp;</span></a></div>
<div id="menu_home" style="display: inline; cursor: pointer; visibility: visible;"><a id="a_home" title="Tuxedo Integration into Qore" onclick="home()"><img id="img_home" style="display: inline; visibility: visible;" alt="Tuxedo Integration into Qore" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABbdJREFUeNp9lVuMVlcVx39rn/N9c7/fmKHMwBTFQaDQIRptIQNUU1ONbaxNE2IxxhcT2xBrNOXBNxpJ0yejiQk16UPTVsWYkpY0zggtEBtrZbQzVIsyOOUyzAwzzO27nLP3Wj58Z+hEjTs5Z+19Ttb/v9fae62/8N9DskezxYBz7BPYbtCZfZ8y44Iap4GJzC/K/hn/Z7gMHIGHIsdpoJw56Rq7Ol9xjteA+/7Tf+1u14Ir0OmEFwy+bIa21Ivs2Rrpjo3OWhuRxMPkjNp7l1QuXFaXeBBBMH5h8CRQyHBtLcEq+Kec45QqG9saSJ/5el4O7c9F7W0ihphoJN6rlVPPwooxNhk4/mYIJ84H1IhF+JMZDwHTqySyhu2uyHEuKH33D7j0lWfq4vUba0ULkVmKiC5RLixRDhElq6WcGggmovLGu6kdeTFN55fJi/BHM/YDK6sHUwlB+JUag/u2RembxxpyrW2tJKUOkapOiWKYSzoobvguNVUx0eJFzJTCckluL3v75IaYXZtdPDKqSSmhl8plOAm4KMvTNwy+39Mq6amjNbnW5gZLQpfkG3tQy3NdB4nueZ72gYdx3Q/jfZH5pBG36RC5hrvk9o33pbtVrLtVouFRVWA38BYwEQHihOMGPc9/u4qh3TlJkmbJ1zWzktQz3fA4bYPfo7m5BS3PA4Goa4jaDQ/QdvcDVNd3svDhSywUoL8buXLTdOImzgnNBq86EYbU2L2pS+zRz8cuFBx5WWRmsZrbPYdZf+9BavNGSMsgOVBFQoFcDKEwTUgWCUkZJyapF/vKZytZUeMAsNk54QsAB+6JtKUhorSyIFf9IOz6Geu37EX8MiGkgGEWsKyOzMA0Jd/0CVp3HUaDUiyrbFon9HYQgAYR9jhgJ8CO/hyhvMT16kdo2PsSHR2d+OItTAOoxzQF9WABMwWzzCrdg0/Rf+A5ggn5nNHXJatFttOZ0QXQWi9SKJnUt/XR0NhMUl7BTDFNsJBgmmLmK4QWMAtgiqqHUKa1bw+Sa0RDoKlOVsu4505p++BJpAY3eZzbpx+jtHSz0pBWwTXF1GPmUQ2YelQ9Lq5i9tJJRk88QXF5DiUnZnfakTgRZgGm5s3SgBVLKQsf/pri0hQi9vHu15JoimUkzkXcunKemSsfoJIn8WrzSxm8Me2AMYC/TChlbxRTKFGLqaIhQTVFNcVCioaKrUQSMMvSFuXQCIIay0WYnMkuAow5NUYAzo4HmZo30mBWLHuCTyoEPkF9uTLPSCqESRaNJ009pTKIYJdvGFdniYCSGW87M0ac8MHVWdzr7wbLxbBUUnDxnThtzRvJOnV2jpFEqMUUk0pDG75gFR0RzgNjEeCBGHjw4qT6vdvjqDZOzeWbpL59M768iPkC6guEtID6IiEtEJICmpYorcww/s7LkM7ae5eQX55Vzbrz08DfVtt1XoQ/mHHvzn7xx74VxXln5qMmiSOHYBWVUQgGIRhpgDQIKyslYgp2ZUbkx69qulQkB7wGfLUSyMdasMMJZ9Vo3LZR/A8ejeP1bd4KJSMNiFlGoOAVQqjkPI5FRi87fv5GSBdWyIkwYcZ9wA1AokwUHDA1uNm9A3ztnzes5sz7kqbB0dHkpK7aEUUOcU6cc7jIWTCRa7ccJ86LvnJGQ7FMbl0LH9Xk+VKhzES2cVsrmdHoT2pDPnaffuRo8vLfrybbAW2sFbb2Oe3tQOprEB9gbgmbmMIuXVOXeANwW3vdmWcPuYO/G9XrPz2pzgmqBkSugj60PSL5TYMLp2qZPbEuf+Spx5/c1H/3P/6H0K9d68DAlr/+6Js9B88dQ95+Li8vPh25uuo1oh+7Sk6PPJbn6BM5rs/lnN/yLL2f+Y4uzt+sGR4e2T888vsvjo+Pb5ubn28XEW1va5nesW1g9MDQ507tG7r/XJV+5P/828Nu5tpFc3HOfviCZ+xfhhP4N5gwShkDZas3AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==" /><span id="alt_home" style="display: none; visibility: hidden;">&nbsp;<strong>[Home]</strong>&nbsp;</span></a></div>
<div id="menu_unlock" style="display: none; cursor: pointer; visibility: hidden;"><a title="Unlock" onclick="unlock()"><img id="img_lock" style="display: inline; visibility: visible;" alt="Unlock" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABmJLR0QA%2FwD%2FAP%2BgvaeTAAAEnUlEQVR42o2WX2wUVRTGf3NnZ7a7tkvTdA1rlxSWthgwEpoawh9jS8SHxofqAyaGBzBBE15IBLTxwfgCGBITfZAXk%2FYBjDE09QGJpqKFGBKiDYkuVChd7KbbbbtLy3bb2dk%2Fs3N96M52t63ASU5m5t7c853zne%2FeOwoV9vDhwxpWWSgUypVelYphWfKnmnACrxd8z549rwB2yYslfwuoB9zAayWgXYBrXQQneKU3NzfvcrLs7%2B%2BXsVhMTk1NyVu3bsmK7N8EZCqVcr4PlUDXVlBpBw4ceDEajd7u7e0tJpNJDh48SDqdJpVK4ff7iUQi9Pf3A1wBWFpa4s6dOwDfA92rQdYAzM3NvQRw%2BvRp9erVq1YwGGT79u3s2LGDrVu3Eg6H87t376avr6%2B8ZnZ2lgcPHgAMAi2V%2FaribXp6WllcXLw4MTHByMgIR44ccW3YsOFDr9c76vP54vF4vKOnp6cvGo3S1NRUlVhrayvAp6vEsLYCALd7pUqPx3O%2FpaVl9OjRoxPnzp27%2FH9qOX78OMAMMF2psKoKxsfHBYBpmuUxr9c729raagQCAftJcrxw4QKACeQrx8sA4XBYDAwM1K5eaBiGb3h4uOn69es2z2bFdQG%2B%2FOiDd4bvz%2FQBDA4OkkgknAb%2BtjrCsWPHqK1dyUXXdS5dusThw4cvAreBfxyaFGeDhUIhMxUfJT8%2Fibn4iHzGIJtZYPFxCjOTAUDTNPQaN8Klorlr2NXTSywWI5FI0N7eDvAV8DUQKW3O6h4ouTS59AxGIkrWWCLzOMlcMsGSsQQSPJ4adK8HVRVo6spJUVdXx82bN9m3b98J4LsSwFoV2baNLC5TKG2wFXtZcxKEEKAoKELBtiWvn%2FqBzz45iRCCuro6VFV1wmwCtHVVBBIpJUiJlEViMynGJmYxM1kE0FBfy6aNcPZKnEgkghCCTIm%2BxsZGhoeH6erqugy8CvwJ5KopEipCCBShIIQk8Hw9HpEjs7CIRCBqdHq%2FvceNGzcoFAqMj49jWRaKoqDrOps3b2ZkZISOjo7fgZ3AXREKhbIrHBWxihZWvoCVL%2FDocZrJxBJT81kSCxne%2FfxXzp45g5TLlWqaRltbG21tbWzZsoX6%2Bnr8fj%2Fnz58H%2BAtocJUUlF0mSEFVVFSXC6G6aPR5EVkPGbeNXVJ3Z1cXhmGgKArbtm1D1%2FXl6hWl%2FOzs7HRS3ljdA9tCFjIUcovkc2mi8QTzyXlMw0RzucoBHDdNk0AgAEA0Gi2PO6BA%2FaoeKEhVQwg3Lk0nuLGBWlVimu4qwTmBQqEQwBeAbG5uPjU5OYmiKOTz%2Bf857Io2kiKyWMAqFLByuVJPLGTRAuCXoaEyHQCH3mg%2FeeLtnaecHW1ZFkNDQ870QtU9%2B%2FM3HzPx7zjZhSRZM0sulyWfzVKwiggUajw6g6Murl27hmEYaJpGMBgEIBaLoes6Y2Nj7N%2B%2FH%2BA94McywMt%2B%2FYW%2Fk%2FmpZznN9u7dy8DAALa9cv6Fw2GklHR3dwP0Aj8BdysrUAAV0EvP1X8Slfacz%2BeLp9Pp9ebeB%2F4A7gE55SnJPmneBTQAAaDO4bx06cwDFsB%2F1pf2UYdfB6cAAAAASUVORK5CYII%3D" /><span id="alt_unlock" style="display: none; visibility: hidden;">&nbsp;<strong>[Unlock]</strong>&nbsp;</span></a></div>
<div id="menu_lock" style="display: inline; cursor: pointer; visibility: visible;"><a title="Lock" onclick="lock()"><img id="img_unlock" style="display: inline; visibility: visible;" alt="Lock" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAB3RJTUUH1wMbFisGhO%2Br5wAAAAlwSFlzAAALEwAACxMBAJqcGAAAAARnQU1BAACxjwv8YQUAAANZSURBVHja3VTPT1NZGD3vvZYWGGqVNgKyEBZqwsRYtRpjJpkdMbNk5YrMZjYQF27c%2Bxe4MCxcIJmdyRAjGxMX%2FohKUGMgMAt%2BTCJ0CtqR2tLS9%2Fp%2B3eu5r8UEZphS48qbnL57b9895%2FvO970LfK%2FjKjFJlIhHxH0i9a3Ib%2Fb396%2BPj4%2FLjY0NOTMzIycmJvxEImHyv1%2BbJTP2rG8PDw9fn5ycjPX19aFYLCIWi6Gnp0cbGBgI5%2FP5XzKZjMb3nn1N5FfS6bRZKBTk%2FPx8ZWho6C337GQymR0ZGbHn5ubk1NSUHBwcLNctbHo8YHRycXFRplKpP7ieIS4TP8Xj8eejo6OmsmtsbMzh3r2m2elxMZfLyenp6QqXK8TPRCuhLEn39vZm19bWpKoN1wsH5dV3Jp2dnZFKpYJyuawIbGKeqBJq%2FSabzYrNzU10d3Wp15MHFQjtTJaWlm6xe4bry8eEl2zVb3UfO3rt71wRoegPePniBeUEWiPhoyFDlwQOd7SjI9EN27ZRyr9HV4eB5Wzx3rYbdJyl7RGMEXHCJ3KEW1h5AiE0eJ6A8F3OHVjFf%2Fj0gtSE70G4Nnzbgl%2B18ObhXfz2%2B7riOkvMhvYIlOr4MjSyWPlVlHKr8Cng2xXYTpWJCEgpKcw9x4S3XYBjbkEEssHo2lWD%2FYYQPiSjrC3okFarOnQdmq5B09QGaTQ1N0j4xRRjVw32HzKIlD9YWPgTy6vrsMxqEJlQbdYWxYnjx5CIePBdZiPkrtMNBTSdUdWjPX%2FpAk6fs%2BDRJk9lRZuEWw1sK7ERAuo9VW2cAS1SZJ7jYPbt7P4ZtNTIQ0aoOQHJUwa9NUJhnLuYxunUKbhsSZ%2BiyjqpCuxWsJ3jnPZE2w%2FzVKYJAeEFNrhOBXOzK%2FtmEIcXNITREm22BjqkEWYdIjh74Qx%2BPHOSNbAhpAgKr%2Fz3XQvlDwZaolG4bqTJGvhsU6hWdWFuleHwg1K9L%2Bqtqz4yzzah0cJo2yGU88Vdx40G9O3p%2FrbLbRo9%2FpiBVSrALH9ClVCdJDybNVDZaAxCh7W9haevlvH6nfmUZ3mv4K%2F%2FZaf6RT7uoHbhHRRPiBvEeeBfXftfGjhC9KD26YcbWlq7xz4SWeJDI4EdEUXccoCAdoZqJZf49Bkd5rOdXLtvgwAAAABJRU5ErkJggg%3D%3D" /><span id="alt_lock" style="display: none; visibility: hidden;">&nbsp;<strong>[Lock]</strong>&nbsp;</span></a></div>
<div id="menu_print" style="cursor: pointer; display: inline; visibility: visible;"><a title="Print" onclick="page_print()"><img id="img_print" style="display: inline; visibility: visible;" alt="Print" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAMAAADXqc3KAAAAB3RJTUUH1wcECDIDhMeZAwAAAAlwSFlzAAAewQAAHsEBw2lUUwAAAARnQU1BAACxjwv8YQUAAABjUExURf8f7XNzc1JSUmNjY1paWmtra3t7e0pKSggICCkpKSEhIRgYGBAQEDExMcbGxgAAADk5OYSEhK2trYyMjJycnJSUlKWlpc7OzkJCQr29vdbW1rW1td7e3v%2F%2F%2F%2Ff39%2Bfn5%2B%2Fv7w37xZMAAAABdFJOUwBA5thmAAABKUlEQVR42n2S2a6DIBRFZRKhBRkPU9X%2B%2F1de1A7el64HcsLKDmTDMPzCcnyB1vc%2BTJgSxgg9IMK8hRfLWsDVZWddvPwIBRkzrHKrWqeLsDMHz1hkMq3P5zWRGzeICIvysl4FCRRv69ZEzOH5%2BIoHB1OXddssZWjZE%2Bd986xiTqnqYunIdVnsPN3LMLTJGm%2BaLi0RhEjVXQRFhsFNGjNmitbegIJHerCpZrqLxu6BiGwyRGEIply1U7iC5BhtABKbxA3A6VdCp2gMz0qIWASr%2FbRTWNApuRhKyrduUHVBHWIMuleUUl%2FyLThVXDyFjfDGKUUUxI8IX7Cx4F9i9CF%2BCBCi9bvQs7F2%2FIelE%2BpdoUlIeduR8hikuKujRYRJrxXtj94HNhJOf%2F2cP%2B6HGtUMDq8TAAAAAElFTkSuQmCC" /><span id="alt_print" style="visibility: hidden; display: none;">&nbsp;<strong>[Print]</strong>&nbsp;</span></a></div>
<div id="menu_edit" style="display: inline; cursor: pointer; visibility: visible;"><a title="Edit" onclick="edit()"><img id="img_edit" style="display: inline; visibility: visible;" alt="Edit" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABSVJREFUeNqVlX9oXFUWxz/3vvfmR6aZyZB0YqKhlTUIldK0ILgisv6s9Rdrq1Y32P4hRcXUij/YNuLSFP3H+ttqtFiwTVfRrtbowhpo1iK7BbWg0qildfwRMzGTkNTxdd5kZt67Z//YmWnSpIoXDvdxL+98z/l+zzlXcWqFgAuBGGD4fUu01kPGmCxgAUH1QlVMgL3hcLgzGo0GIqIr56c8iMzrGMD3feV5Xk5rfZcx5k3ABvwqAEqplIik9+3bt2DlypUml8spy7JqTn9tFxEcx5GdO3eqnp4epbVeb4zZA2jA2JVINEBLSwuO46C1BsC27dq3Umpeq9yprVu3mnA4THd3926llIhIH1D5uwJijKFYLKogCFQ8HldKKVUsFpXv+yoIglnm+37t3Pd9JicnrS1btqienh5E5CWl1DmA0aeT6jgO+Xyevr4+RkdHicfjBEFAoVCgVCrNa+VyWWmtxfM8vWHDBj8ejy8QkXalFPZM50EQUFdXx+DgIF1dXbS2trJmzRrWrl1Lc3Mz4+PjGGOwbbtGW3Vva2tTlmVJoVBQFVpVjftaSSmF7/ssW7aM1tZW2s45m97eXjo7O3n22eewbZtEIk65XK4JPFP0qi4zK24OQKFQYPny5axYsYJ0Os2mTRt5/59vMzr6LTfccCMff3KYC5YsYeHChbS0tNTMcZzTy1nNdHwWkD948KC4rmvy+bzs3r1HOjouEGPyEgRGRET+PbhXzmpeIIcOfSwiRnK5nOTzefE8T1zXlWKxaNLptJ9IJAS4QinFHJEty8J1Xa6++iq0DvHFF5+idZGCd5LLLl/L80+sYt0dnfz8cw6lqIpcY+D0hpwFICI1HYLAZ+nSDvr6/g5EcCILmMh8yepVi7juyhC33LqekyddhoeHGRkZwff9Ws+cEaAahWVZnDhxgtWrb+If+97nyKHtlCYPkD78FIf/c4zt267BnfwvL+zYRTKZwPO8eQWeNwMArTWRSJSLL76Irvs2s/q2R5g4upOIU2C6pPnu6Div7/ozr+16iuPffE97+3mzOvs3KVJKkUqlsG2Hhx/axOXXb+TOv37I4rZGImGL0ZFfaIg4PP34RWzs2kQkEiUSCc87EOelqKqDMYapqSlefnE7pdAKHn1ikPP/0Igdsjjy+U+suXYJl1zosW79PYRC4VpvnLEPZmYwNjZGJpMhk8lw7NhxXtrxJPsP+rz13hDti5Og4LNPfuSZx1aRPtrPq7v2YFkWQRD8egbVVS6XKRaL+L6P67o4jkNv7w42P3mEr45N0NYaJ/dLkYmMy/33LueDf31QCdKcGaCagdaaZDJJU1MTjY2NpFIpHCfEZX+6lGeef4V1DxzAGKH93EakLPS/8yWLFi+q+Jgd6JxhFwQBxhiSyeSc2e/7AevvuJ10+juuW/c3tj34R/oHjjP0Q4revgdPJ0FmAijA1NfXEwqFTENDg7Isaw5tVQG3be0mtbCRNw4coL7xPD56bTtNTU0ANDQ0yMyGqwKUgGD//v0MDw+rfD6vbdtGKUWpVKqlrtT/34vp6WmaU0n+ctvNCEJ//7tMT08TiURkYmJCe54HUBCRWY/+5mg0ep9SqqSUUuVyGSOGumgUYwQQjAnwvGnq6+OUy6VTQmpdHRNijIl4nvcucPes2gcYGBgIZ7PZWCaTqRsYGIh1dCyNjY+nY647FZs6MRHz8l/Hrrliceyhh7tjnpePjYyMxMbGxmLZbDaWzWZjU1NTsaGhoWgikaj5/R958KLgEIeBwgAAABl0RVh0U29mdHdhcmUAQWRvYmUgSW1hZ2VSZWFkeXHJZTwAAAAASUVORK5CYII=" /><span id="alt_edit" style="display: none; visibility: hidden;">&nbsp;<strong>[Edit]</strong>&nbsp;</span></a></div>
<div id="menu_cancel" style="display: none; cursor: pointer; visibility: hidden;"><a title="Cancel" onclick="cancel()"><img id="img_cancel" style="display: inline; visibility: visible;" alt="Cancel" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAABlhJREFUeNp1lW2M3FUVh59z739mdmZ2d2a324XutkWEbl8otEpFm0LbKBVSX6IEgoKpRYONfDAKopA2MdHaqDHWQARCVCIfSDFaEiFCiWkbamybVKyUtltb3G7ftt3dbvdlZuf/cu89ftipCQZPcpOb++H3u/fcc84jfHBYwBtAhC6v3AF8BOgBDDACvGtgH8LpoNA81+b6vyFNcYywCPgtMJo36A1tJtw2Owofnx2FvnYbShYF6sBrAmuE/5rI/wq+by+gIvwgKFuWVG30jcUt+qmevM4pmZATkSwotVT1fC3I/uHM7BiIOXTZi8BLwDcVJptGgQ9wyym8nDd8ceuKkvvWslYKBWtCFiTJPIlTEg+ZBx8UCVDLvH/1TMbPjjaisVTfFbhb4XxTW68aiIAq7Kjk5P6dd7Wnn1xQySVSFm9yKsGLSetoPE2aeRoOGl6IM9GGC1JQr/3jPnv07/X8YD28I7BGYRwQ28x5AB4z8Ogrd7Wn6/oquWlbkSxX1JAvSVQsQ76IBI/xKYpAEjNdr0lIGkwFS0chilZ02HT3payn4ZkvsBMwFlArzFfY8eTyUsumZWVpUJIrpW4m1j4ihZX3IY1JZPISGEPkU9zUGIO9Kyg/9HOKNywn6z8gU7HTWQVru/Li9w67ZQIHgFNWZq7/+LyyWfeb1a1ZIcpFDmF8zSNy42e+RrF7HtHiO3Bnj2IvnUKnxniv5xPM3/wH5i65lfZbbieIMLH/dambIteV4NiENxdi7TTwkjFCDvjCfdcX6C4am3hVCU6q7e0AhCzGtJRo+fI23LV9nLrmVuY9+TId1U6mJ8ZwQGF+Hxi52gJm3bV5mPmHRVFQbgL61szJ0XCIipMoMpT++gL+5tXYWb0ElyItZXTjr5gblLZKJ0l9Cim242vjjOx8GpUIQGKP9rUaX7aU657bjcKi1ojc3JIN05nivBK8x549QvbMBtzlc0iUx6UJhWoX5Y4ukkYdKZTQrM75nzzAxKE9UCij3pMFpS0SulsMwM0GmN2aMxQMGntIPSSJwwXFnv4H6bb1TF4YwOQK+CzDZRnYHG5yhIs/vpeJA29CuQPnPV7Bh5lstUYC0B0BIaiSOsgiJSioCkGULG4w2NHBPJtHQyAERTWAKMEHGmPjZF7xKvig+ABeQVUJqgDBABenMmUs8eI8xA7SYKhNjNPfu4q5m1+h0t1DFjfAWojy+KSBqcymZ+trRAtuozE+hsPiguIVYq9MZgowZASONzzxyQlvfAg0nGhcr3Om52PcuHkH1UqVuF5DCkX85ChuZBApteFq49hShet/+EcKCz5KMl3HqQFVRpMgw4kCHDZGOAYc3Xsxw3tC7JUrU9N0fPohZnV20Zi8guSLhGSKC7/YyL+/fzfp0ACmtUo6PkKu4xp6H/wuaZqRBtSgHJsMJgmMG9hnmrP8929cyBiYCkEDknhUTx/BA7nqLEIyxemtX2L0wG5qF87R/73P0jh3inz3PKKCJR4+S+pRF1Rih9874gB2KQza5hDvjwNfaTitrp5tQ52CSU4c0mTismSTo5x97nEuH9xDKFZxNk995CIjf/szWMPowV2ceHE79dRTtMLuESe7R5wIPKxw7ipgvMAGhd89saQl+1xvIRpLg5hGTQUVyeWRlhLBe0JQvFiyJCGpx2SKprkCpSiSkzWf/vREnI8DvwS+w0xZoE1AHC5HUn1r2K2q5CRbWokkiYomi1rUSSTOeVyALEDqlAxLlm/REOWlbIX+KZ9tPxXnvfKXoGxsTmi1TR4oYHbe2f5GV8l0bD8WrxqqO11Uyfs2CyEEyfyMeNasdzSQQzVT8a9eSPTZgTS3pGLf3HJT6Z59Iy5OwgzMrJEZ9bVzcvqjFWW7/sOl12dXWgee+5dbu/N0rXx+PJEoEiJrA4h6RetedLDuZdeZWJ55L7H/rIm//0P5bU8sKT7cWzTppVjl+KRXA4iVme57emUrmxa3MK3GViotfmDB57t+PX7dpheef/aBocGBhaA230Rg2nxyW2fX2Xse/OqfNnRPPNXx1osnh33RBB/0+ITXxw5Pvw/07FlfZXlXBKLk8nlbqFSD/fpTmi68Mzp8cP/St985csu580NzvPemq2vW6NKFfcdWrFx1uPNKf/34lnu5ODRmUyKfukAtU779dp2RVPkPYy9lOpej6EMAAAAZdEVYdFNvZnR3YXJlAEFkb2JlIEltYWdlUmVhZHlxyWU8AAAAAElFTkSuQmCC" /><span id="alt_cancel" style="display: none; visibility: hidden;">&nbsp;[Cancel]&nbsp;</span></a></div>
<div id="menu_save" style="display: none; cursor: pointer; visibility: hidden;"><a title="Save" onclick="save()"><img id="img_save" style="display: inline; visibility: visible;" alt="Save" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAABGdBTUEAAK/INwWK6QAAAAZiS0dEAP8A/wD/oL2nkwAAA0FJREFUeNq1lc+KHFUUxn/n3qqu6h7tGdPByTBOEjQunK26EQRdhAGRuHGE2agLH8C1j5AXCFnkAYyBEIKoRHeabWQyJKIm+IdAdwSd0HZPdVXdc1xU9UynbZIe/xy4XG5R93z3fN937hWqeALYqGcFhH8WBkTAD8DXTCS64n18Jo6ToFo4792hAEQEVUUVc87baDR0ZvYBcEFAngO7eeatD5vHjq2XKysDee/dNxkOc9zcOIJzgXPnrhD0mfDVl+cbt29f/0zEvREBHqD9ZIckWfCdIwnLy8v0+3t47x7PiRkAcexoLy6SZW1arTaAQyq+ACSEAtVAURQyGo3I8/krMANVoSxLQigtaKjKsgkAREAEmRjOzVeBCDgnCPXecU7g8Rn+ZfzvANHkYprxsYD/GYABiExAzS+yWcX/IwEATEu8V7w3vNc5skvVvt7Qyj2zAVSVVqvJj3d6nD37MeAxJimSh+qxuj5DMVNUA7t/wFNHInSC2mhyh6AkyQrd3gOKYhcRv2/V6dOJCBoCjWSJNG2jqiSpAPrQUaLpTXk+4mhnyObma4QAWTZABNJ0AdWDk5mB98bFi9fJ8gWSxBFCybQt/gagqjSbTU6cOMknl66xvd0DjJdfWmNj41WGwwznBFVIU0+z1WQwDMRRNNMUUyJXzIYQyPOMbvcB8DSqSre7S1mOKIoc5xxmRp57NITaebMjmvlVqmq8czingOJ8Zd8DK8pB3ke0y34n26y/qutp8n45dEQ1fPA+qkU0MzMxM4q8JMsCqkpelJgZqoZz4xvU6m6vZqs6bnxYA4hEBDNz/f7vliQtnBuQNBJL0xbr68cpw6+Asf7CsyRJimpFk1klcqOR4HxEVIvsfSzeRQAmApGZfQ9c/uLz81tpupB3Oidd736X7e0dVlc7rK4u1g6LuHXru30NzMA55f5vPfLc0CCEMkgIZTkY7Hog7PebiHNLS8uXKlQpqR5+O+wQEQVCvX6/lrHq+M13PmplWf760c7QnT79Cnt7h3nRFO+Fq1e/saLoRDd3rv10986Nb0WECMTAiOMkWzv+4qfPnyrY2nqb/p97+DletDFdcSz8/EtgNFrj3r0d7nJDRMT+AqKAkRUl/oStAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAABJRU5ErkJggg==" /><span id="alt_save" style="display: none; visibility: hidden;">&nbsp;<strong>[Save]</strong>&nbsp;</span></a></div>
<div id="menu_key" style="display: inline; cursor: pointer; visibility: visible;"><a title="Set password" onclick="set_key()"><img id="img_key" style="display: inline; visibility: visible;" alt="Key" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABgAAAAYCAYAAADgdz34AAAAAXNSR0IArs4c6QAAAAZiS0dEAP8A%2FwD%2FoL2nkwAAAAlwSFlzAAAu6AAALugBK4TfhAAAA2ZJREFUSMe1ls1rXGUUxn%2FvnTsfma80JmkzWpvaVsii0lqx1VYpbWrRSYsiLbhRiqvOwoXSpSD%2BAW5cOCKIFtSFIoLWEaolIFKJMRQrRMU2HRXDtNNkviczc%2B%2B8r4ueGW%2FbaZoscuHlwuFynnOe9zzPucoYw1o%2BFmv82KuqJpVRgPKEjE4nl6VArYQiK5XxA0E5toBowAWaQFOnk%2B6qAaxUxgIiQAwIAyEBsATAARpADagA9Vs7uiOAlcrYQD%2BwDogLUB%2Fg9wC0gCWgCpSAIlDW6aReFkAqHwAGgXsEqNNFQADaQk9dqi8Ci8ACUOp00vOSJ3Z%2BsCsSLDxZrg%2BFfpo7nF2sjfgEJCL34PPwX%2FHEjMRbAnxzByc%2F3xeP2v9%2BEg5WJhQ3unTcYGv6yuEz52Zf%2BFWo6vN0UAfKUvl1IA9cA64C13U6qbsdjL15ynrukb%2B%2FDNrV%2FQ0nPJ%2BvbDwPrB%2Fpz%2B57%2FMEzzxfrw9GZ7HgeiEq1jnDvl8q9F96hstEFeGr72SNBu7p%2FqRWbPf3DGy%2FnK4k4kHh4dHJuYuf7J%2FZs%2FWbvTPbgeVD9krQJFCR5UxL3yaQFbwMI2pVxgHz1vnfzlURTkgQu%2FHVg7rFtmcJQdH7gtadThwyqKzSFMYBRSt4YgzJGgak2Rl%2BC5Ge2Z2AVQFv7tAipc3rYiVLcSE7Ablh%2Bn%2BNVN27bbmuDslIZ1QUoLW34IxIosSH%2Bz4shf32q4YQ1oHds%2Bn7bYDQ3sFAdqb1z7q1fgCGhoQbkj%2B9%2Be9NYYmqzMRYoUGgWavd%2B%2Bt7k69%2FqdNJ0AWYu7z69bnvu1XCgvCc1fuqjXPGBadvXun%2FjwJ9PgOHHS0cvyMRozx2UlNIuwOz83u8s5ba3DF886LZDLRnXm8f0xMcHRgcj2a%2BioeJDnZjjBp2pueTZyd%2BOXRJVRzxTVBtL%2FBwb6b8SyJU3X%2Fx9%2FtFpICfnqk4nm7cpOfbKh%2F5DO754NmRXd5WWhtTU5Weyhdp6vySP9dBBRabJq4NrwKJOJ%2FWdrCICDAvfg2IbcY%2BSvVbR8aGC2EReRNZYbh%2FUxVs6E%2BSKqS3nRSVRdFHid3VTSyjpUBOV6fF7AByPm5Ylec1r2XfbB0qSRlewD6pAa8X7oEc3ATm3brRWr8T%2FL1VjVn3Uya%2FVir9d69%2BW%2FwCh5sidoCxDaQAAAABJRU5ErkJggg%3D%3D" /><span id="alt_key" style="display: none; visibility: hidden;">&nbsp;<strong>[Save]</strong>&nbsp;</span></a></div>
</td></tr></tbody></table></div><p style="font-size: 20px;">&nbsp;</p>
<div id="text_area" style="display: inline; visibility: visible;">
<div class="menu_area" id="sw_menu_area" style="position: absolute;">
<div class="wiki" id="menu_area" ondblclick="menu_dblclick()"></div>
<div id="menu_edit_button" style="display: inline; visibility: visible;">
<hr />

<div style="text-align: center;"><a class="link" onclick="edit_menu()">[Edit]</a></div></div>
<div class="wiki" id="ns_menu_area" ondblclick="ns_menu_dblclick()" style="display: none; visibility: hidden;"></div>
<div id="ns_menu_edit_button" style="display: none; visibility: hidden;">
<hr />

<div style="text-align: center;"><a class="link" onclick="edit_ns_menu()">[Edit]</a></div></div></div>
<div style="visibility: visible;" class="text_area" id="wiki_text" ondblclick="page_dblclick()"></div></div>
<div id="edit_area" style="display: none; visibility: hidden;">
<div id="edit_page_title" style="display: block;">Page title: <input id="wiki_page_title" size="50" value="" />&nbsp;<a style="color: blue;" onclick="woas.wiki_buttons_display($('wiki_format_buttons').style.display != 'block')">Show/Hide wiki buttons</a>&nbsp;|&nbsp;<a style="color: blue;" onclick="woas.html_buttons_display($('html_format_buttons').style.display != 'block')">Show/Hide HTML buttons</a></div>
<div id="wiki_format_buttons" style="display: block; visibility: visible;">
Wiki Code:
<input class="wiki_button" name="btn1" value=" B " style="font-weight: bold; width: 30px;" onclick="TagThis('*', '*')" type="button" />
<input class="wiki_button" name="btn2" value=" i " style="font-style: italic; width: 30px;" onclick="TagThis('/', '/')" type="button" />
<input class="wiki_button" name="btn3" value=" u " style="text-decoration: underline; width: 30px;" onclick="TagThis('_', '_')" type="button" />
<input class="wiki_button" name="btn4" value="{{{ nowiki }}}" style="width: 82px;" onclick="TagThis('{{{\n', '\n}}}')" type="button" />
<input class="wiki_button" name="btn5" value="*" style="width: 40px;" onclick="TagThis('* ','')" type="button" />
<input class="wiki_button" name="btn6" value="#" style="width: 40px;" onclick="TagThis('# ','')" type="button" />
<input class="wiki_button" name="btn7" value="@" style="width: 40px;" onclick="TagThis('@ ','')" type="button" />
<input class="wiki_button" name="btn8" value="---" style="width: 40px;" onclick="TagThis('--- ','')" type="button" />
<input class="wiki_button" name="btn9" value="Img" style="width: 40px;" onclick="setWikiImage()" type="button" />
<input class="wiki_button" name="btn10" value="URL" style="text-decoration: underline; width: 40px;" onclick="setWikiUrl()" type="button" />
<input class="wiki_button" name="btn7" value="=" style="width: 40px;" onclick="TagThis('= ','')" type="button" />
<input class="wiki_button" name="btn8" value="==" style="width: 40px;" onclick="TagThis('== ','')" type="button" />
<input class="wiki_button" name="btn9" value="Tags" style="width: 40px;" onclick="setTag()" type="button" />
<a class="world" onclick="open_table_help()">About tables</a>
</div>
<div id="html_format_buttons" style="display: block; visibility: visible;">HTML Code:
  <input class="wiki_button" name="b" id="b" value="B" style="font-weight: bold;" onclick="FullTagThis('strong')" type="submit" />
  <input class="wiki_button" name="i" id="i" value="i" style="font-style: italic;" onclick="FullTagThis('em')" type="submit" />
  <input class="wiki_button" name="u" id="u" value="u" style="text-decoration: underline;" onclick="FullTagThis('u')" type="submit" />
  <input class="wiki_button" name="s" id="s" value="S" style="text-decoration: overline;" onclick="FullTagThis('s')" type="submit" />
  <input class="wiki_button" name="sup" id="sup" value="Sup" onclick="FullTagThis('sup')" type="submit" />
  <input class="wiki_button" name="sub" id="sub" value="Sub" onclick="FullTagThis('sub')" type="submit" />
  <input class="wiki_button" name="left" id="left" value="Left" onclick="DivTagThis('left')" type="submit" />
  <input class="wiki_button" name="center" id="center" value="Center" onclick="DivTagThis('center')" type="submit" />
  <input class="wiki_button" name="right" id="right" value="Right" onclick="DivTagThis('right')" type="submit" />
  <input class="wiki_button" name="justify" id="justify" value="Justify" onclick="DivTagThis('justify')" type="submit" />
  <input class="wiki_button" name="list" id="list" value="List" onclick="FullTagThis('ul')" type="submit" />
  <input class="wiki_button" name="list_eq" id="list_eq" value="List=" onclick="FullTagThis('ol')" type="submit" />
  <input class="wiki_button" name="li" id="li" value="li [*]" onclick="FullTagThis('li')" type="submit" />
  <input class="wiki_button" name="blockquote" id="blockquote" value="Blockquote" onclick="FullTagThis('blockquote')" type="submit" />
  <input class="wiki_button" name="img" id="img" value="Image" onclick="setHTMLImage()" type="submit" />
  <input class="wiki_button" name="url" id="url" value="Link" onclick="setHTMLUrl()" type="submit" />
</div>
<textarea id="wiki_editor" style="width: 1362px; height: 548px;" rows="0" cols="0"></textarea> 
</div>
<div id="debug_info" style="display: none; visibility: hidden; z-index: 101; text-align: right; width: 300px;">
<h2>Debug console</h2>
<p>This is a development BETA version of Wiki On a Stick; it is not suggested to use it with important data. If you want to disable this debug message and console, you will have to find the line that says <b><tt>woas["debug"] = true;</tt></b> and change it to <b><tt>false</tt></b>.</p>
<textarea id="swlogger" ondblclick="$('swlogger').value=''" style="width: 60%; background-color: rgb(204, 204, 204);" rows="12" readonly="readonly" cols="60"></textarea><p>&nbsp;</p><input onclick="$('swlogger').value=''" value="Clear" type="button" /></div>
<hr />
<div style="text-align: center;"><sub><a class="link" onclick="go_to('Special::About')">About Wiki on a Stick v0.9.7B</a></sub></div></body></html>